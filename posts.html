<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Ryo Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Ryo&#x27;s blog, build with next.js"/><link rel="icon" href="/img/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog-next/_next/static/css/9c17c2d9f3c8b9ec.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/9c17c2d9f3c8b9ec.css" data-n-g=""/><link rel="preload" href="/blog-next/_next/static/css/db3b301b0794ad3a.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/db3b301b0794ad3a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog-next/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog-next/_next/static/chunks/webpack-60a2ec5432ad43a2.js" defer=""></script><script src="/blog-next/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/blog-next/_next/static/chunks/main-5a633d052902c7b6.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/_app-ebfbab9e37daa1a2.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/posts-a145760d4ff15912.js" defer=""></script><script src="/blog-next/_next/static/SZItP4mXfzsnPoytf6hTX/_buildManifest.js" defer=""></script><script src="/blog-next/_next/static/SZItP4mXfzsnPoytf6hTX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="style_header__sRoTf"><div class="style_icon__jxr5_"><div class="style_textbox__uLqJ9"><a class="style_textlink__526pR" href="/blog-next">Ryo&#x27;s Blog</a></div></div><div class="style_navBar__9GT_e"><div class="style_navBarItem__2VL_G"><a class="style_textlink__526pR" href="/blog-next/posts">Posts</a></div><div class="style_navBarItem__2VL_G"><a class="style_textlink__526pR" href="/blog-next/tag/1">Tags</a></div></div><div class="style_headerRight__G5ePS"><div class="style_textbox__uLqJ9"><a class="style_textlink__526pR" href="/blog-next/about">About Me</a></div></div></div><div class="style_headerBg__yAoHx"></div><div class="PostList_postList__7u2vW"><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2020-01-27-Building-this-blog"><h6 class="PostList_postTitle__uczSA">搭建博客的过程</h6><time class="PostList_postDate__ns1KP" dateTime="2020-01-27T14:00:00.000Z">2020-01-27</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">&gt; “Stop Trying to Reinvent the Wheel.”</p><p class="PostList_postAbstract__wW66U">参考[BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]，先将[Huxpro][Huxpro]提供的[博客模板仓库][origin_repo]fork出来，`git clone`到本地。</p><p class="PostList_postAbstract__wW66U">整个网站文件夹大致结构如下：</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/%E6%9D%82%E6%8A%80"><span class="TagsBox_tag__PAgNP">杂技</span></a><a href="/blog-next/tag/Blog"><span class="TagsBox_tag__PAgNP">Blog</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2020-01-27-hello-world"><h6 class="PostList_postTitle__uczSA">Welcome to Ryo&#x27;s Blog!</h6><time class="PostList_postDate__ns1KP" dateTime="2020-01-27T12:00:00.000Z">2020-01-27</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">&gt; “Hello World!”</p><p class="PostList_postAbstract__wW66U">自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。</p><p class="PostList_postAbstract__wW66U">感谢[Huxpro][Huxpro]提供的博客模板，以及[BruceZhao][BruceZhao]编写的中文ReadMe。</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/%E6%9D%82%E6%8A%80"><span class="TagsBox_tag__PAgNP">杂技</span></a><a href="/blog-next/tag/%E6%9D%82%E8%B0%88"><span class="TagsBox_tag__PAgNP">杂谈</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2020-01-28-the-using-in-cpp"><h6 class="PostList_postTitle__uczSA">C++中using关键字的使用</h6><time class="PostList_postDate__ns1KP" dateTime="2020-01-28T18:00:00.000Z">2020-01-28</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">1. 引入整个命名空间中的成员</p><p class="PostList_postAbstract__wW66U">   不引入命名空间时，使用其中变量需要使用`&lt;命名空间名&gt;::&lt;变量名&gt;`的方式使用。</p><p class="PostList_postAbstract__wW66U">   ```C++</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/C++"><span class="TagsBox_tag__PAgNP">C++</span></a><a href="/blog-next/tag/%E6%9D%82%E6%8A%80"><span class="TagsBox_tag__PAgNP">杂技</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2020-08-02-python-dict"><h6 class="PostList_postTitle__uczSA">Python字典的实现原理</h6><time class="PostList_postDate__ns1KP" dateTime="2020-08-02T00:10:10.000Z">2020-08-02</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">&gt; CPython从3.6开始，字典（dict）不再是无序的了——字典的修改了原先的底层实现，变得能按字典插入的顺序进行遍历。而Python从3.7开始将字典的有序性写入语言特性，不管是Jython、IronPython还是其他Python实现，从3.7开始大家的字典都是有序的了。</p><p class="PostList_postAbstract__wW66U">以前参加Python相关的面试时，面试官经常都会问一个问题：Python里的字典（dict）是有序的吗？</p><p class="PostList_postAbstract__wW66U">这自然难不倒我，我也照本宣科地讲：Python的字典底层是用哈希表实现的，在不发生冲突时读写的时间复杂度是O（1），比读写时间复杂度为O（logn）的红黑树要更快。但红黑树可以按下标的大小顺序进行遍历，而Dict遍历时是无序的。</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/Python"><span class="TagsBox_tag__PAgNP">Python</span></a><a href="/blog-next/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="TagsBox_tag__PAgNP">数据结构</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2021-01-11-Sort-algorithm"><h6 class="PostList_postTitle__uczSA">排序算法</h6><time class="PostList_postDate__ns1KP" dateTime="2021-01-11T22:57:10.000Z">2021-01-11</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">我们知道排序是算法入门基本功，排序算法有多重要想必也不需要我在这里说明了。因此这一篇就按着我的理解，聊一聊排序算法。</p><p class="PostList_postAbstract__wW66U">当然我不打算随便弄个什么十大排序算法或是经典排序总结之类响当当的名头，各个算法走马看花一样拉出来遛一遍，最后变得跟网上搜索到的其他讲排序的文章一样换汤不换药。你会发现这篇文章的结构跟在网上搜索到的任何讲排序的文章都有所不同：</p><p class="PostList_postAbstract__wW66U">在这篇文章里，你会发现你找不到冒泡排序——因为我认为冒泡排序只不过是一种低效率的选择排序。</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="TagsBox_tag__PAgNP">数据结构</span></a><a href="/blog-next/tag/%E7%AE%97%E6%B3%95"><span class="TagsBox_tag__PAgNP">算法</span></a><a href="/blog-next/tag/%E6%8E%92%E5%BA%8F"><span class="TagsBox_tag__PAgNP">排序</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2021-03-21-Handy-heap-cheat-sheet"><h6 class="PostList_postTitle__uczSA">如何手撕一个堆</h6><time class="PostList_postDate__ns1KP" dateTime="2021-08-28T23:09:14.000Z">2021-08-28</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">在参加如AtCoder等算法竞技，或是刷Leetcode等算法题时，我们总是不可避免地遇到堆这种数据结构。</p><p class="PostList_postAbstract__wW66U">当然，一般来说我们只要理解堆，知道堆的性质，知道怎么样用堆就足够了。在做题时只需要调用系统类库即可——在参加AtCoder时你甚至不会有时间去自己实现一个堆。</p><p class="PostList_postAbstract__wW66U">但是，如果哪一天你把编程语言的类库全忘光了，又遇到一题需要频繁求最值的题目——你明知这里要用堆，却又忘记该调用的类名了，咋办？我还真遇到过这问题：三年没刷算法，只能对着一道自己明显会的题干着急，愣是想不起PriorityQueue的名字。这时候，只能自己实现一个堆出来了。</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="TagsBox_tag__PAgNP">数据结构</span></a><a href="/blog-next/tag/%E7%AE%97%E6%B3%95"><span class="TagsBox_tag__PAgNP">算法</span></a><a href="/blog-next/tag/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B"><span class="TagsBox_tag__PAgNP">算法竞赛</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2021-08-21-The-beauty-of-design-parten"><h6 class="PostList_postTitle__uczSA">设计模式之美读书笔记</h6><time class="PostList_postDate__ns1KP" dateTime="2021-08-21T08:53:27.000Z">2021-08-21</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">从7个方面评价代码的好坏：</p><p class="PostList_postAbstract__wW66U">1. 易维护性：根本</p><p class="PostList_postAbstract__wW66U">2. 可读性：最重要</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="TagsBox_tag__PAgNP">设计模式</span></a><a href="/blog-next/tag/%E7%AC%94%E8%AE%B0"><span class="TagsBox_tag__PAgNP">笔记</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2021-12-12-init-a-new-hexo-project"><h6 class="PostList_postTitle__uczSA">init-a-new-hexo-project</h6><time class="PostList_postDate__ns1KP" dateTime="2021-12-12T20:09:13.000Z">2021-12-12</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">最近使用 hexo 搭建了一个博客，并打算挂载在 github page 上。</p><p class="PostList_postAbstract__wW66U">对之前的那个博客进行替代，并将之前的文章逐渐搬移过来。</p><p class="PostList_postAbstract__wW66U">使用的[这个主题](https://github.com/Yue-plus/hexo-theme-arknights)功能还是比较完善的。</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/Blog"><span class="TagsBox_tag__PAgNP">Blog</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2022-03-26-create-blog-cicd-by-github"><h6 class="PostList_postTitle__uczSA">用 GitHub Action 自动化构建 Hexo 并发布到 S3</h6><time class="PostList_postDate__ns1KP" dateTime="2022-03-26T23:55:08.000Z">2022-03-26</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">GitHub Action 自动化构建发布到 GitHub Pages 大家都见得多了，甚至 Hexo 官方自己都有相关的文档。</p><p class="PostList_postAbstract__wW66U">但我今天要做的不是发布到 GitHub 这么简单，而是要同时发布到 GitHub 和自己的域名下。</p><p class="PostList_postAbstract__wW66U">我们需要构建一个 CI/CD 过程。这个过程需要做到以下目标：</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/Blog"><span class="TagsBox_tag__PAgNP">Blog</span></a><a href="/blog-next/tag/GitHub"><span class="TagsBox_tag__PAgNP">GitHub</span></a><a href="/blog-next/tag/AWS"><span class="TagsBox_tag__PAgNP">AWS</span></a><a href="/blog-next/tag/CI/CD"><span class="TagsBox_tag__PAgNP">CI/CD</span></a><a href="/blog-next/tag/IaC"><span class="TagsBox_tag__PAgNP">IaC</span></a><a href="/blog-next/tag/DevOps"><span class="TagsBox_tag__PAgNP">DevOps</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2022-04-03-use-paste-image-and-vscode-memo"><h6 class="PostList_postTitle__uczSA">完善 Hexo 编写环境，改善文章中使用图片的体验</h6><time class="PostList_postDate__ns1KP" dateTime="2022-04-03T21:03:03.000Z">2022-04-03</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">我平时使用 [vscode-memo](https://github.com/svsool/vscode-memo) 插件写笔记，其中插入图片使用 `![[]]` 语法，显示简短，也有较好的预览支持，体验极佳。希望这种特性也能在写 hexo 博客的时候使用。</p><p class="PostList_postAbstract__wW66U">可能有很多人不熟悉 vscode-memo 这个插件，我先来简单介绍一下。</p><p class="PostList_postAbstract__wW66U">vscode-memo 定位是一个 knowledge base ，对标的是 [Obsidian.md](https://obsidian.md/) 等软件。其功能包括且不限于：</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/Blog"><span class="TagsBox_tag__PAgNP">Blog</span></a><a href="/blog-next/tag/VSCode"><span class="TagsBox_tag__PAgNP">VSCode</span></a><a href="/blog-next/tag/Hexo"><span class="TagsBox_tag__PAgNP">Hexo</span></a><a href="/blog-next/tag/JavaScript"><span class="TagsBox_tag__PAgNP">JavaScript</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2022-06-28-graph-for-economics-1"><h6 class="PostList_postTitle__uczSA">图解经济学原理(1)</h6><time class="PostList_postDate__ns1KP" dateTime="2022-06-28T00:59:41.000Z">2022-06-28</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">&gt; 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。</p><p class="PostList_postAbstract__wW66U">&gt; 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。</p><p class="PostList_postAbstract__wW66U">我们先不讲课，先来带个货。</p></div></a></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2022-07-19-graph-for-economics-2"><h6 class="PostList_postTitle__uczSA">图解经济学原理(2)</h6><time class="PostList_postDate__ns1KP" dateTime="2022-07-19T23:12:48.000Z">2022-07-19</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">&gt; 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。</p><p class="PostList_postAbstract__wW66U">&gt; 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。</p><p class="PostList_postAbstract__wW66U">上一篇讲供给，这一篇讲需求。</p></div></a></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2022-07-31-why-homogeneous"><h6 class="PostList_postTitle__uczSA">为什么使用在齐次坐标下矩阵乘法能表示点平移？</h6><time class="PostList_postDate__ns1KP" dateTime="2022-07-31T15:35:17.000Z">2022-07-31</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">简化了一万倍来说，线性变换主要是在描述符合这两种性质的变换：一是要可加，二是要能数乘。</p><p class="PostList_postAbstract__wW66U">也就是说，对于空间中所有向量 $$\vec{v_1}, \vec{v_2}$$ ，以及任意数量 $$k_1, k_2$$ ，如果有：</p><p class="PostList_postAbstract__wW66U">$$</p></div></a></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2022-08-13-introduction-for-k8s"><h6 class="PostList_postTitle__uczSA">Kubernetes 入门 （1）</h6><time class="PostList_postDate__ns1KP" dateTime="2022-08-13T17:45:31.000Z">2022-08-13</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">我们知道 K8s 利用了容器虚拟化技术。而说到容器虚拟化就要说 Docker 。可是，容器到底是什么？ Docker 又为我们做了些什么？我们又为什么要用 K8s ？</p><p class="PostList_postAbstract__wW66U">&gt; 要把一个不知道打过多少个升级补丁，不知道经历了多少任管理员的系统迁移到其他机器上，毫无疑问会是一场灾难。 —— Chad Fowler 《Trash Your Servers and Burn Your Code》</p><p class="PostList_postAbstract__wW66U">&quot;Write once, run anywhere&quot; 是 Java 曾经的口号。 Java 企图通过 JVM 虚拟机来实现一个可执行程序在多平台间的移植性。但我们现在知道， Java 语言并没能实现他的目标，会在操作系统调用、第三方依赖丢失、两个程序间依赖的冲突等各方面出现问题。</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/Kubernetes"><span class="TagsBox_tag__PAgNP">Kubernetes</span></a><a href="/blog-next/tag/DevOps"><span class="TagsBox_tag__PAgNP">DevOps</span></a><a href="/blog-next/tag/Docker"><span class="TagsBox_tag__PAgNP">Docker</span></a><a href="/blog-next/tag/Cloud%20Native"><span class="TagsBox_tag__PAgNP">Cloud Native</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/2022-08-20-introduction-for-k8s-2"><h6 class="PostList_postTitle__uczSA">Kubernetes 入门 （2）</h6><time class="PostList_postDate__ns1KP" dateTime="2022-08-20T21:56:52.000Z">2022-08-20</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">我们之前说的都是用于部署 Pod 的资源，我们接下来介绍与创建 Pod 不相关的资源：储存与网络。</p><p class="PostList_postAbstract__wW66U">其实我们之前已经接触过储存相关的内容了：在讲 Stateful Set 时我们提过 Stateful Set 创建出来的 Pod 都会有相互独立的储存；而讲 Daemon Set 时我们提到 K8s 推荐只在 Daemon Set 的 Pod 中访问宿主机磁盘。但独立的储存具体指什么？除了访问宿主机磁盘以外还有什么其他的储存？</p><p class="PostList_postAbstract__wW66U">在 Docker 中，我们可以把宿主机磁盘上的一个路径作为一个 Volume 来给容器绑定，或者直接使用 Docker Engine 管理的 Volume 来提供持久化存储或是容器间共享文件。在 K8s 里面也沿用了 Volume 这个概念，可以通过 Mount 绑定到容器内的路径，并通过实现 CSI 的各种引擎来提供更多样的存储。</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/Kubernetes"><span class="TagsBox_tag__PAgNP">Kubernetes</span></a><a href="/blog-next/tag/DevOps"><span class="TagsBox_tag__PAgNP">DevOps</span></a><a href="/blog-next/tag/Docker"><span class="TagsBox_tag__PAgNP">Docker</span></a><a href="/blog-next/tag/Cloud%20Native"><span class="TagsBox_tag__PAgNP">Cloud Native</span></a></div></div><div class="PostList_postListElement__bxSVR"><a href="/blog-next/posts/newest"><h6 class="PostList_postTitle__uczSA">Kubernetes 入门 （1）</h6><time class="PostList_postDate__ns1KP" dateTime="2022-08-13T17:45:31.000Z">2022-08-13</time><div class="PostList_postAbstract__wW66U"><p class="PostList_postAbstract__wW66U">这里是第一行，</p><p class="PostList_postAbstract__wW66U">然后这里是第二行。</p><p class="PostList_postAbstract__wW66U">&lt;License /&gt;</p></div></a><div class="TagsBox_tagsBox__Z0lIP"><a href="/blog-next/tag/Kubernetes"><span class="TagsBox_tag__PAgNP">Kubernetes</span></a><a href="/blog-next/tag/DevOps"><span class="TagsBox_tag__PAgNP">DevOps</span></a><a href="/blog-next/tag/Docker"><span class="TagsBox_tag__PAgNP">Docker</span></a><a href="/blog-next/tag/Cloud%20Native"><span class="TagsBox_tag__PAgNP">Cloud Native</span></a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postMatters":[{"slug":"2020-01-27-Building-this-blog","title":"搭建博客的过程","created_at":"2020-01-27T14:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["杂技","Blog"],"abstract":"\u003e “Stop Trying to Reinvent the Wheel.”\n参考[BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]，先将[Huxpro][Huxpro]提供的[博客模板仓库][origin_repo]fork出来，`git clone`到本地。\n整个网站文件夹大致结构如下："},{"slug":"2020-01-27-hello-world","title":"Welcome to Ryo's Blog!","created_at":"2020-01-27T12:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["杂技","杂谈"],"abstract":"\u003e “Hello World!”\n自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。\n感谢[Huxpro][Huxpro]提供的博客模板，以及[BruceZhao][BruceZhao]编写的中文ReadMe。"},{"slug":"2020-01-28-the-using-in-cpp","title":"C++中using关键字的使用","created_at":"2020-01-28T18:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["C++","杂技"],"abstract":"1. 引入整个命名空间中的成员\n   不引入命名空间时，使用其中变量需要使用`\u003c命名空间名\u003e::\u003c变量名\u003e`的方式使用。\n   ```C++"},{"slug":"2020-08-02-python-dict","title":"Python字典的实现原理","created_at":"2020-08-02T00:10:10.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["Python","数据结构"],"abstract":"\u003e CPython从3.6开始，字典（dict）不再是无序的了——字典的修改了原先的底层实现，变得能按字典插入的顺序进行遍历。而Python从3.7开始将字典的有序性写入语言特性，不管是Jython、IronPython还是其他Python实现，从3.7开始大家的字典都是有序的了。\n以前参加Python相关的面试时，面试官经常都会问一个问题：Python里的字典（dict）是有序的吗？\n这自然难不倒我，我也照本宣科地讲：Python的字典底层是用哈希表实现的，在不发生冲突时读写的时间复杂度是O（1），比读写时间复杂度为O（logn）的红黑树要更快。但红黑树可以按下标的大小顺序进行遍历，而Dict遍历时是无序的。"},{"slug":"2021-01-11-Sort-algorithm","title":"排序算法","created_at":"2021-01-11T22:57:10.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["数据结构","算法","排序"],"abstract":"我们知道排序是算法入门基本功，排序算法有多重要想必也不需要我在这里说明了。因此这一篇就按着我的理解，聊一聊排序算法。\n当然我不打算随便弄个什么十大排序算法或是经典排序总结之类响当当的名头，各个算法走马看花一样拉出来遛一遍，最后变得跟网上搜索到的其他讲排序的文章一样换汤不换药。你会发现这篇文章的结构跟在网上搜索到的任何讲排序的文章都有所不同：\n在这篇文章里，你会发现你找不到冒泡排序——因为我认为冒泡排序只不过是一种低效率的选择排序。"},{"slug":"2021-03-21-Handy-heap-cheat-sheet","title":"如何手撕一个堆","created_at":"2021-08-28T23:09:14.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["数据结构","算法","算法竞赛"],"abstract":"在参加如AtCoder等算法竞技，或是刷Leetcode等算法题时，我们总是不可避免地遇到堆这种数据结构。\n当然，一般来说我们只要理解堆，知道堆的性质，知道怎么样用堆就足够了。在做题时只需要调用系统类库即可——在参加AtCoder时你甚至不会有时间去自己实现一个堆。\n但是，如果哪一天你把编程语言的类库全忘光了，又遇到一题需要频繁求最值的题目——你明知这里要用堆，却又忘记该调用的类名了，咋办？我还真遇到过这问题：三年没刷算法，只能对着一道自己明显会的题干着急，愣是想不起PriorityQueue的名字。这时候，只能自己实现一个堆出来了。"},{"slug":"2021-08-21-The-beauty-of-design-parten","title":"设计模式之美读书笔记","created_at":"2021-08-21T08:53:27.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["设计模式","笔记"],"abstract":"从7个方面评价代码的好坏：\n1. 易维护性：根本\n2. 可读性：最重要"},{"slug":"2021-12-12-init-a-new-hexo-project","title":"init-a-new-hexo-project","created_at":"2021-12-12T20:09:13.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["Blog"],"abstract":"最近使用 hexo 搭建了一个博客，并打算挂载在 github page 上。\n对之前的那个博客进行替代，并将之前的文章逐渐搬移过来。\n使用的[这个主题](https://github.com/Yue-plus/hexo-theme-arknights)功能还是比较完善的。"},{"slug":"2022-03-26-create-blog-cicd-by-github","title":"用 GitHub Action 自动化构建 Hexo 并发布到 S3","created_at":"2022-03-26T23:55:08.000Z","updated_at":"2022-03-27T13:31:04.000Z","tags":["Blog","GitHub","AWS","CI/CD","IaC","DevOps"],"abstract":"GitHub Action 自动化构建发布到 GitHub Pages 大家都见得多了，甚至 Hexo 官方自己都有相关的文档。\n但我今天要做的不是发布到 GitHub 这么简单，而是要同时发布到 GitHub 和自己的域名下。\n我们需要构建一个 CI/CD 过程。这个过程需要做到以下目标："},{"slug":"2022-04-03-use-paste-image-and-vscode-memo","title":"完善 Hexo 编写环境，改善文章中使用图片的体验","created_at":"2022-04-03T21:03:03.000Z","updated_at":"2022-04-03T17:47:52.000Z","tags":["Blog","VSCode","Hexo","JavaScript"],"abstract":"我平时使用 [vscode-memo](https://github.com/svsool/vscode-memo) 插件写笔记，其中插入图片使用 `![[]]` 语法，显示简短，也有较好的预览支持，体验极佳。希望这种特性也能在写 hexo 博客的时候使用。\n可能有很多人不熟悉 vscode-memo 这个插件，我先来简单介绍一下。\nvscode-memo 定位是一个 knowledge base ，对标的是 [Obsidian.md](https://obsidian.md/) 等软件。其功能包括且不限于："},{"slug":"2022-06-28-graph-for-economics-1","title":"图解经济学原理(1)","created_at":"2022-06-28T00:59:41.000Z","updated_at":"2022-06-28T14:24:43.000Z","tags":null,"abstract":"\u003e 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。\n\u003e 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。\n我们先不讲课，先来带个货。"},{"slug":"2022-07-19-graph-for-economics-2","title":"图解经济学原理(2)","created_at":"2022-07-19T23:12:48.000Z","updated_at":"2022-08-13T09:53:03.000Z","tags":null,"abstract":"\u003e 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。\n\u003e 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。\n上一篇讲供给，这一篇讲需求。"},{"slug":"2022-07-31-why-homogeneous","title":"为什么使用在齐次坐标下矩阵乘法能表示点平移？","created_at":"2022-07-31T15:35:17.000Z","updated_at":"2022-08-05T17:45:09.000Z","tags":null,"abstract":"简化了一万倍来说，线性变换主要是在描述符合这两种性质的变换：一是要可加，二是要能数乘。\n也就是说，对于空间中所有向量 $$\\vec{v_1}, \\vec{v_2}$$ ，以及任意数量 $$k_1, k_2$$ ，如果有：\n$$"},{"slug":"2022-08-13-introduction-for-k8s","title":"Kubernetes 入门 （1）","created_at":"2022-08-13T17:45:31.000Z","updated_at":"2022-08-20T14:02:18.000Z","tags":["Kubernetes","DevOps","Docker","Cloud Native"],"abstract":"我们知道 K8s 利用了容器虚拟化技术。而说到容器虚拟化就要说 Docker 。可是，容器到底是什么？ Docker 又为我们做了些什么？我们又为什么要用 K8s ？\n\u003e 要把一个不知道打过多少个升级补丁，不知道经历了多少任管理员的系统迁移到其他机器上，毫无疑问会是一场灾难。 —— Chad Fowler 《Trash Your Servers and Burn Your Code》\n\"Write once, run anywhere\" 是 Java 曾经的口号。 Java 企图通过 JVM 虚拟机来实现一个可执行程序在多平台间的移植性。但我们现在知道， Java 语言并没能实现他的目标，会在操作系统调用、第三方依赖丢失、两个程序间依赖的冲突等各方面出现问题。"},{"slug":"2022-08-20-introduction-for-k8s-2","title":"Kubernetes 入门 （2）","created_at":"2022-08-20T21:56:52.000Z","updated_at":"2022-08-20T14:02:18.000Z","tags":["Kubernetes","DevOps","Docker","Cloud Native"],"abstract":"我们之前说的都是用于部署 Pod 的资源，我们接下来介绍与创建 Pod 不相关的资源：储存与网络。\n其实我们之前已经接触过储存相关的内容了：在讲 Stateful Set 时我们提过 Stateful Set 创建出来的 Pod 都会有相互独立的储存；而讲 Daemon Set 时我们提到 K8s 推荐只在 Daemon Set 的 Pod 中访问宿主机磁盘。但独立的储存具体指什么？除了访问宿主机磁盘以外还有什么其他的储存？\n在 Docker 中，我们可以把宿主机磁盘上的一个路径作为一个 Volume 来给容器绑定，或者直接使用 Docker Engine 管理的 Volume 来提供持久化存储或是容器间共享文件。在 K8s 里面也沿用了 Volume 这个概念，可以通过 Mount 绑定到容器内的路径，并通过实现 CSI 的各种引擎来提供更多样的存储。"},{"slug":"newest","title":"Kubernetes 入门 （1）","created_at":"2022-08-13T17:45:31.000Z","updated_at":"2022-08-20T14:02:18.000Z","tags":["Kubernetes","DevOps","Docker","Cloud Native"],"abstract":"这里是第一行，\n然后这里是第二行。\n\u003cLicense /\u003e"}]},"__N_SSG":true},"page":"/posts","query":{},"buildId":"SZItP4mXfzsnPoytf6hTX","assetPrefix":"/blog-next","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>