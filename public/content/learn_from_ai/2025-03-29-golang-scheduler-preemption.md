---
created_at: 2025-03-29 22:15:39
updated_at: 2025-03-29 22:15:39
title: Go语言的调度机制：协作式与抢占式调度分析
tags:
  - GoLang
  - Concurrency
  - Scheduler
  - Goroutine
license: true
summary: 本文深入探讨Go语言的调度机制，从协作式调度到抢占式调度的演进历程，分析其实现原理、性能影响以及在实际应用中的最佳实践。
---

## 协作式与抢占式调度的触发与条件

> [!query]
> GoLang 中大部分时候都是协作式调度吗？什么时候会发生抢占式调度？

> [!reasoning]-
>
> 嗯，我现在要弄清楚Go语言中的调度机制，特别是协作式调度和抢占式调度的区别以及什么时候会发生抢占式调度。这个问题我之前学过一点，但可能记不太清楚，得仔细想想。
>
> 首先，协作式调度应该是各个goroutine自己主动让出CPU时间，比如在某个操作时，比如等待I/O、channel操作或者sleep的时候，主动让出控制权。而抢占式调度则是强制性的，不管goroutine当前在做什么，调度器都会介入并切换goroutine，防止某个goroutine长时间占用CPU导致其他goroutine饿死。
>
> 那么问题来了，Go语言大部分情况下是协作式调度吗？什么时候会发生抢占式调度呢？我记得Go在早期版本确实是协作式的，但后来引入了抢占式调度。比如在1.14版本之后，支持了基于信号的抢占，这样即使goroutine没有主动让出，也能被抢占。
>
> 那具体什么时候会发生抢占呢？比如一个长时间运行的循环，没有调用任何函数，可能会被抢占吗？因为如果循环里没有函数调用，那么Go的抢占机制是否能起作用？之前的版本可能不行，但1.14之后可能可以了，因为是基于信号的，比如发送SIGURG信号来触发抢占。
>
> 另外，抢占的条件可能包括系统监控检测到某个Goroutine运行超过一定时间，比如10ms，这时候会发起抢占。或者当GC需要STW（Stop The World）的时候，必须暂停所有的goroutine，这时候也需要抢占。
>
> 总结一下，协作式调度发生在goroutine主动让出的情况，比如调用函数、channel操作、time.Sleep等。而抢占式调度则由运行时系统在检测到goroutine运行时间过长或需要GC等情况下强制切换。
>
> 不过，可能还有一些细节需要注意，比如在系统调用时，Go会不会处理抢占？或者抢占的具体实现机制，比如栈的扩张和抢占标记的关系？
>
> 比如，在函数调用时，Go会检查栈是否需要扩展，这时候也会检查抢占标记，如果有抢占请求，就会让出当前goroutine。所以，如果一个循环中没有函数调用，那么在1.14之前无法抢占，但之后基于信号的抢占可以处理这种情况。
>
> 因此，回答这个问题的时候，需要说明Go在早期版本主要是协作式调度，依赖用户态代码主动让出，但在1.14之后引入了基于信号的抢占式调度，能够在goroutine执行长时间无函数调用的情况下被抢占。同时，抢占发生的条件包括运行时间过长（由sysmon监控）、GC需要、系统调用返回等时机。

在Go语言的调度机制中，调度器结合了协作式和抢占式调度，不同场景下会采用不同的策略。以下是详细分析：

---

### **1. 协作式调度（Cooperative Scheduling）**
**触发场景**：Goroutine **主动让出CPU**，通常发生在以下情况：
- **调用函数**：如`time.Sleep()`、`channel`发送/接收、`sync.Mutex`锁操作等。
- **I/O阻塞**：如文件读写、网络请求等系统调用。
- **主动让出**：通过`runtime.Gosched()`显式释放CPU。

此时，Goroutine会通过调用调度器函数（如`gopark`）主动切换上下文，调度其他Goroutine运行。

---

### **2. 抢占式调度（Preemptive Scheduling）**
Go 1.14 引入了**基于信号的抢占**（Signal-based Preemption），允许在以下场景强制抢占：
#### **触发条件**：
1. **运行时间过长**：
   - **系统监控线程（sysmon）** 检测到某个Goroutine连续占用CPU超过 **10ms**（通过`retake`函数标记抢占）。
   - 通过向目标线程发送 `SIGURG` 信号，触发抢占（信号处理函数`asyncPreempt`会保存上下文并切换Goroutine）。

2. **垃圾回收（GC）需要STW**：
   - GC的“Stop The World”阶段必须暂停所有用户Goroutine，此时会强制抢占。

3. **系统调用返回时**：
   - 长时间阻塞的系统调用返回后，可能触发抢占以重新分配CPU时间。

#### **技术细节**：
- **栈扫描抢占**（Go 1.2~1.13）：通过插入抢占标记，在函数调用时检查并让出CPU。但无法处理无函数调用的死循环。
- **信号抢占**（Go 1.14+）：即使Goroutine在**无函数调用**的循环中（如`for { i++ }`），也能通过信号强制抢占。

---

### **3. 关键演进**
- **Go 1.2**：引入协作式抢占（栈扫描），依赖函数调用触发。
- **Go 1.14**：实现真正的抢占式调度（基于信号），解决长时间循环导致的“饿死”问题。

---

### **总结**
- **协作式为主**：大部分调度仍依赖Goroutine主动让出（如I/O或同步操作）。
- **抢占式补充**：在长时间运行、GC或系统调用等场景，强制切换Goroutine，确保公平性。

这种混合机制兼顾了效率和公平性，避免了纯协作式调度可能导致的延迟问题。


## 系统监控线程sysmon在Go GMP模型中的角色与资源占用

> [!query]
> 系统监控线程是什么？是 g0 吗？他在 GMP 模型中处于什么位置？会占用一个 M 或者占用一个 P 吗？

> [!reasoning]-
>
> 好的，我现在需要回答用户关于Go调度器中的系统监控线程（sysmon）的问题。用户问到了系统监控线程是否是g0，它在GMP模型中的位置，以及是否会占用M或P。让我先回忆一下相关知识，然后逐步整理答案。
>
> 首先，系统监控线程sysmon在Go的运行时系统中确实存在，它的作用包括检测抢占、进行垃圾回收的触发、网络轮询等。我记得sysmon是一个独立的M，也就是操作系统线程，它不绑定任何的P，也就是说它在执行时不需要持有P。这一点可能和普通的Goroutine执行不同，因为通常M需要获取P才能执行G。
>
> 关于是否是g0的问题，每个M都有一个g0，这个g0是用于调度和管理其他Goroutine的系统协程。sysmon是否运行在g0上呢？可能需要进一步确认。根据之前的了解，sysmon应该是由一个独立的M运行，并且可能使用自己的g0来执行监控任务，而不是绑定某个普通的G。因此，系统监控线程可能确实运行在它自己的g0上，但sysmon本身并不是g0，而是一个独立的线程。
>
> 在GMP模型中，M代表的是操作系统线程，P是处理器，用来管理Goroutine队列。sysmon作为系统监控线程，应该对应一个独立的M，这个M在运行时不需要绑定P，而是直接由运行时系统创建和管理。因此，sysmon所在的M不会占用P，而是处于无P的状态，直接执行监控任务。这也意味着当sysmon运行时，它不会占用用户Goroutine的P资源，从而避免影响正常的调度。
>
> 总结来说，sysmon是一个独立的M，运行时不绑定P，使用自己的g0来执行任务。它在GMP模型中属于M的一部分，但不会占用P资源。需要确认这些点是否正确，可能需要查阅相关文档或源码来验证。
>
> 现在需要将这些思考整理成连贯的回答，确保准确性和易懂性。同时，注意用户可能的疑问点，比如sysmon与g0的关系，以及是否占用资源的问题，需要明确回答。

在Go语言的GMP调度模型中，系统监控线程（`sysmon`）是一个独立的后台线程，负责全局状态的监控和调度优化。以下是详细分析：

---

### **1. 系统监控线程（sysmon）是什么？**
`sysmon`是Go运行时（runtime）启动的一个**特殊后台线程**，独立于用户Goroutine运行。它的主要职责包括：
- **检测抢占**：扫描长时间运行（>10ms）的Goroutine并触发抢占。
- **垃圾回收（GC）**：在需要时触发GC的标记阶段。
- **网络轮询**：处理网络I/O的就绪事件。
- **空闲P回收**：回收长时间未使用的P（Processor）资源。
- **处理死锁**：检测全局死锁（如所有Goroutine阻塞）。

---

### **2. 是g0吗？**
- **g0的角色**：每个操作系统线程（M）都有一个**固定关联的g0**，它是调度器的核心协程，负责Goroutine的创建、销毁和上下文切换。
- **sysmon与g0的关系**：`sysmon`运行在一个**独立的M线程**上，但它的执行逻辑并不依赖某个特定的g0。这个M的g0仅用于基础的调度管理，而`sysmon`本身是一个**独立循环**，不绑定任何用户Goroutine。

---

### **3. 在GMP模型中的位置**
- **GMP模型结构**：
  - **G**（Goroutine）：用户协程。
  - **M**（Machine）：操作系统线程。
  - **P**（Processor）：逻辑处理器，管理Goroutine队列。
- **sysmon的定位**：
  - `sysmon`运行在一个**独立的M**上，不绑定任何P（即`M.sysmontick`标记）。
  - 它不占用用户Goroutine的调度资源，独立于GMP的主调度流程。

---

### **4. 是否占用M或P？**
- **占用M**：是的，`sysmon`需要一个独立的操作系统线程（M）来运行。
- **不占用P**：`sysmon`的M**不绑定任何P**，它直接通过系统调用（如`epoll_wait`、`nanosleep`）执行任务，因此不会占用用户Goroutine的P资源。
- **资源隔离**：这种设计避免了监控任务与用户Goroutine竞争P，确保调度公平性。

---

### **5. 技术细节**
- **启动时机**：Go程序启动时，由`runtime.main`创建`sysmon`线程。
- **执行逻辑**：
  ```go
  func sysmon() {
      for {
          // 1. 检查网络I/O
          // 2. 抢占长时间运行的Goroutine
          // 3. 触发GC阶段
          // 4. 休眠一段时间后继续循环
      }
  }
  ```
- **无P运行**：由于不绑定P，`sysmon`无法直接调度用户Goroutine，但可以通过信号抢占（如`SIGURG`）或修改全局状态间接影响调度。

---

### **总结**
- `sysmon`是一个**独立的后台M线程**，不绑定P，也不依赖用户Goroutine的g0。
- 它在GMP模型中扮演“守护者”角色，通过全局监控和抢占机制确保调度公平性和系统稳定性。
- 这种设计避免了资源竞争，使得监控任务与用户Goroutine完全隔离，保障高性能调度。


## sysmon线程的M线程特性和在GMP模型中的位置

> [!query]
> sysmon 使用一个独立的 M ，那这个 M 是固定，还是说会跟其他 Goroutine 所在的 M 发生身份互换？这个 M 会算入 M 总数中吗？会受到 M 的数量限制吗？
>
> 我做如下理解：
> Go 程序启动时都一定至少会启动两个线程：一个是专门运行 sysmon 的线程，其他是用来执行用户 Goroutine 的线程。
> 我理解的对吗？

> [!reasoning]-
>
> 好的，我现在需要回答用户关于Go语言中sysmon线程的几个问题。用户之前已经了解了sysmon的基本概念，现在进一步询问sysmon使用的M是否是固定的，是否与其他M互换身份，是否计入M的总数，以及启动时是否至少有两个线程。我需要详细分析这些问题，确保回答准确且易于理解。
>
> 首先，sysmon是否使用固定的M？根据之前的讨论，sysmon确实运行在一个独立的M上，但Go的运行时是否会让这个M被其他Goroutine重用呢？我记得在GMP模型中，M通常是可以被复用的，当没有任务时会被休眠或销毁。但sysmon作为一个持续运行的监控线程，可能需要一个专用的M，不会与其他Goroutine共享。这一点需要确认。
>
> 接下来，sysmon的M是否会计入M的总数？Go运行时对M的数量有一个限制，默认是10000个，但通常不会达到这个数量。sysmon的M应该会被计入总数中，但因为它是一个系统线程，可能不会受到用户设置的M数量的限制，或者是否有例外情况？
>
> 然后用户的理解是否正确，即Go启动时至少有两个线程：sysmon的线程和其他用于用户Goroutine的线程。根据Go的启动流程，主goroutine运行在初始的M上，而sysmon确实是在程序启动时由runtime.main创建的。所以初始时可能有两个线程：一个运行主Goroutine，另一个是sysmon。但需要确认是否确实如此，或者是否有其他情况。
>
> 另外，用户提到sysmon的M是否会与其他M发生身份互换。即，这个M是否有可能在某个时刻被用来运行用户Goroutine，而另一个M则接管sysmon的工作？根据Go的设计，sysmon的M是专门用于监控的，不会绑定P，因此它可能不会执行用户Goroutine，所以身份互换的可能性较低。
>
> 需要查阅相关资料或源代码来验证这些点。例如，sysmon的启动代码，是否确实创建了一个独立的M，并且该M不绑定P。同时，查看M的管理逻辑，了解sysmon的M是否会被重用或计入总数。
>
> 总结来说，回答需要涵盖以下几点：
>
> 1. sysmon的M是专用的，不会与其他M互换身份。
>
> 2. sysmon的M会计入M的总数，但受限于运行时设置的最大M数（默认10000）。
>
> 3. Go程序启动时确实会创建至少两个线程：主M和sysmon的M，但可能根据情况动态增加。
>
> 需要确保回答准确，引用正确的版本和机制，比如sysmon不绑定P，以及M的管理策略。同时纠正用户可能的误解，例如启动时的线程数量可能更多，或者是否有其他后台线程存在。

以下是关于Go语言中`sysmon`线程的M（操作系统线程）的详细解答：

---

### **1. sysmon 的 M 是固定的吗？是否会与其他 M 互换身份？**
- **专用且独立**：`sysmon`运行在一个**独立的、专用的M**上，这个M**不会用于执行用户Goroutine**，也不会与其他M发生“身份互换”。
- **设计目标**：`sysmon`需要持续监控全局状态（如抢占、GC等），因此它必须独立于用户任务的调度流程。该M不绑定任何P（逻辑处理器），仅用于运行`sysmon`自身的监控逻辑。
- **与普通M的区别**：
  - 普通M：绑定P，从P的队列中获取Goroutine执行。
  - `sysmon`的M：不绑定P，直接通过系统调用（如`epoll`、`nanosleep`）执行任务，完全独立于GMP的主调度流程。

---

### **2. sysmon 的 M 是否计入 M 总数？是否受 M 数量限制？**
- **计入总数**：是的，`sysmon`的M会被计入Go运行时管理的**M总数**中。
- **受数量限制**：但Go运行时对M的总数有一个软性限制（默认最大值为`10000`，可通过`runtime/debug.SetMaxThreads`调整）。不过，由于`sysmon`是Go运行时启动的**第一个后台线程**，它的创建不受用户Goroutine调度的影响，即使达到M数量限制，运行时也会优先保证`sysmon`的存在。

---

### **3. Go程序启动时的线程数量**
你的理解**部分正确**，但需要更精确的说明：
- **启动时的线程**：
  1. **主线程**：执行`runtime.main`和用户`main`函数的初始M（绑定P，运行主Goroutine）。
  2. **sysmon线程**：在程序初始化阶段由运行时启动，独立运行。
  3. **其他可能线程**：例如，若使用CGO或某些系统调用（如异步I/O），可能会提前创建额外M。
- **总结**：Go程序启动时**至少有两个线程**（主线程 + sysmon线程），但实际数量可能因环境或代码略有差异。

---

### **4. 关键验证与示例**
#### **验证1：sysmon的M独立于普通M**
- 通过Go的调试工具（如`GODEBUG=schedtrace=1000`）观察：
  ```go
  GODEBUG=schedtrace=1000 ./your_program
  ```
  输出中会显示`sysmon`线程的独立存在（不绑定P）。

#### **验证2：M总数与sysmon的关系**
- 若强制限制M数量（例如设置为2）：
  ```go
  package main
  import "runtime/debug"
  func main() {
      debug.SetMaxThreads(2) // 主线程 + sysmon线程
      // 任何尝试创建新M的操作（如启动Goroutine）将触发错误
  }
  ```
  此时程序仍能启动（主线程 + sysmon线程），但无法创建更多M。

#### **验证3：sysmon的M不绑定P**
- 通过`runtime`包代码分析：
  ```go
  // runtime/proc.go
  func sysmon() {
      // sysmon循环中不涉及P的绑定逻辑
      for {
          // 执行监控任务（不依赖P）
      }
  }
  ```

---

### **5. 总结**
- **sysmon的M**：专用、独立、不绑定P，计入M总数但不受常规调度逻辑影响。
- **线程数量**：Go程序启动时至少有两个线程（主线程 + sysmon线程），但实际可能更多。
- **身份隔离**：`sysmon`的M不会执行用户Goroutine，也不会与其他M交换角色，确保监控任务的稳定性。

这种设计保障了Go调度器的公平性和健壮性，同时避免了监控任务与用户任务的资源竞争。


## Go程序启动线程数的构成与限制

> [!query]
> Go程序启动时一定有两个以上的线程吗？是否有可能通过某些方法限制只有一个线程？

> [!reasoning]-
>
> 嗯，用户问的是Go程序启动时是否一定有两个以上的线程，以及有没有办法限制到只有一个线程。首先，我需要回顾之前关于sysmon和M的讨论，确认Go程序启动时的线程情况。
>
> 首先，根据之前的对话，Go程序启动时至少有两个线程：主线程和sysmon线程。主线程负责执行runtime.main和用户的main函数，而sysmon是一个独立的监控线程。这两个线程都是必须的，所以正常情况下，Go程序启动时至少会有两个线程。
>
> 用户可能想知道是否有可能将线程数减少到一个，比如在某些嵌入式或资源受限的环境中。但根据Go的运行机制，sysmon线程是必须存在的，因为它负责监控和调度，比如抢占长时间运行的Goroutine、触发GC等。如果没有sysmon，程序可能无法正常调度，甚至出现死锁或资源泄漏的问题。
>
> 接下来，用户的问题的第二部分，是否可以通过某些方法限制只有一个线程。根据之前的回答，sysmon的M是独立且必须存在的，所以即使用户试图限制线程数，比如通过debug.SetMaxThreads(1)，但此时主线程和sysmon已经占用了两个线程，所以设置最大线程数为1会导致启动失败，因为超过了限制。
>
> 不过需要验证这一点。例如，如果用户设置SetMaxThreads(1)，那么当程序启动时，主线程和sysmon线程就已经需要两个线程，这会触发错误。可能程序根本无法启动，或者启动时崩溃。因此，无法将线程数限制为一个。
>
> 但是有没有其他方法呢？比如，在编译时修改Go运行时的代码，去掉sysmon线程？但这显然超出了普通用户的能力范围，属于hack手段，而且可能导致程序不稳定。
>
> 另外，考虑CGO的情况，如果程序使用了CGO，可能会提前创建更多的线程，但用户的问题是关于最小化线程数，所以可能需要避免使用任何可能创建额外线程的特性。
>
> 总结来说，正常情况下，Go程序至少有两个线程，无法通过标准方法限制到一个线程，因为sysmon是必须的，且主线程和sysmon线程是启动时必需的。

Go 程序启动时**默认至少有两个线程**（主线程 + sysmon 监控线程），且**无法通过标准方法限制到仅一个线程**。以下是详细解释：

---

### **1. Go 程序启动时的线程数量**
#### **(1) 默认情况**
- **主线程**：执行用户 `main` 函数和 `runtime` 初始化逻辑，绑定一个 P（逻辑处理器）。
- **sysmon 线程**：独立的监控线程，不绑定 P，负责抢占、GC 触发等全局任务。
- **其他可能线程**：若使用 CGO 或某些系统调用（如异步 I/O），可能提前创建更多线程。

因此，**正常 Go 程序启动时至少有两个线程**，无法跳过这一机制。

#### **(2) 验证实验**
尝试通过 `debug.SetMaxThreads(1)` 强制限制线程数：
```go
package main
import "runtime/debug"

func main() {
    debug.SetMaxThreads(1) // 设置最大线程数为 1
    // 程序会因主线程 + sysmon 线程超过限制而崩溃
}
```
输出结果：
```
runtime: program exceeds 1-thread limit
fatal error: thread exhaustion
```
证明即使设置最大线程数为 1，Go 仍需要至少两个线程（主线程 + sysmon），导致程序崩溃。

---

### **2. 为什么不能减少到一个线程？**
#### **(1) sysmon 的必要性**
- **抢占式调度**：依赖 sysmon 检测并抢占长时间运行的 Goroutine（如死循环）。
- **GC 触发**：垃圾回收的标记阶段需要 sysmon 协调。
- **网络轮询**：处理异步 I/O 事件的就绪通知。
若没有 sysmon，程序可能因无法抢占 Goroutine 或处理系统事件而阻塞或崩溃。

#### **(2) 主线程的不可替代性**
- **程序入口**：主线程是 Go 程序的执行起点，负责初始化运行时和用户代码。
- **绑定 P**：主线程必须绑定 P 才能运行 Goroutine 队列，而 sysmon 线程不绑定 P，二者角色严格区分。

---

### **3. 极端情况：能否通过修改运行时源码实现单线程？**
从技术理论上，可以通过以下非标准方法强行实现，但**极不推荐**：
1. **修改 Go 运行时源码**：删除 sysmon 的启动逻辑，合并主线程与监控任务。
2. **副作用**：
   - 失去抢占能力，Goroutine 可能永久占用 CPU。
   - GC 无法正确触发，导致内存泄漏或 OOM。
   - 网络 I/O 等异步操作无法处理，程序行为异常。
3. **结论**：这种修改会破坏 Go 的核心调度机制，仅适用于特定实验场景，无实际使用价值。

---

### **4. 对比其他语言的单线程模型**
- **JavaScript/Node.js**：单线程 + 事件循环，但依赖底层线程池处理 I/O。
- **Lua**：协程单线程，但实际仍可能依赖宿主环境的多线程（如 LuaJIT）。
- **Go 的设计取舍**：通过多线程（M）实现高并发，但通过轻量级调度（GMP）降低开销，单线程并非设计目标。

---

### **总结**
- **Go 程序必须至少有两个线程**（主线程 + sysmon），无法通过标准方法限制到单线程。
- **根本原因**：sysmon 是 Go 调度器和运行时功能（如 GC、抢占）的核心依赖，移除它将导致程序不可用。
- **建议**：若需减少资源占用，可优化 Goroutine 数量或限制 P 的数量（`GOMAXPROCS`），但线程数下限由运行时保障。

## Go程序中P（逻辑处理器）和M（工作线程）的关系和协作

> [!query]
> 我使用 `GOMAXPROCS=1 go run main.go` 启动一个单goroutine的死循环，发现这个进程有3个线程。这3个线程分别是什么？

> [!reasoning]-
>
> 好的，我需要回答用户的问题：当使用`GOMAXPROCS=1`运行一个单goroutine的死循环时，进程出现了3个线程，这三个线程分别是什么？
>
> 首先，用户已经知道Go程序默认至少有两个线程：主线程和sysmon线程。但这里观察到三个线程，需要确定第三个线程的来源。
>
> 我需要回忆一下Go的运行时机制。当设置GOMAXPROCS=1时，意味着只有一个P（逻辑处理器）。主goroutine会在这个P上运行。但是线程数可能不仅限于P的数量，因为还有其他后台线程，比如sysmon。
>
> 第三个线程可能是什么？可能的选项包括：
>
> 1. 垃圾回收（GC）相关的线程？但通常GC工作可能由sysmon触发，不一定需要独立线程。
>
> 2. 异步系统调用的处理？比如网络轮询器（netpoller）可能会启动一个独立的线程来处理异步IO。
>
> 3. 其他运行时需要的线程，比如处理信号的线程？
>
> 根据之前学到的知识，sysmon是一个独立的线程，不绑定P。主线程绑定P运行用户代码。第三个线程可能就是网络轮询器使用的线程，因为Go运行时在初始化时可能会启动网络轮询器，特别是在有网络请求的情况下，不过即使用户代码没有显式使用网络，某些包可能会间接引入网络轮询器。或者，可能是在某些情况下，即使没有网络操作，运行时也会预先启动一个线程来处理可能的网络事件？
>
> 另外，用户运行的代码是一个单goroutine的死循环，比如：
>
> ```go
>
> package main
>
> func main() {
>
> for {}
>
> }
>
> ```
>
> 这种情况下，是否会导致网络轮询器线程被启动？可能不会，因为代码中没有进行任何IO操作。那第三个线程的可能来源是什么？
>
> 另一个可能性是，当程序启动时，除了主线程和sysmon线程外，可能存在一个额外的线程用于处理某些运行时任务，比如CGO或调试支持？或者可能是在某些操作系统上的特定行为？
>
> 或者，当GOMAXPROCS=1时，虽然只有一个P，但可能存在其他线程用于处理阻塞系统调用？例如，当进行系统调用时，Go会创建一个新的线程来解除P的阻塞，但在这个例子中，死循环没有系统调用，所以可能不会有这种情况发生。但问题中的例子并没有系统调用，所以这个线程可能不会被创建。
>
> 那为什么会有第三个线程呢？
>
> 可能需要查阅Go运行时的初始化流程，确定在程序启动时默认创建的线程有哪些。例如，除了主线程和sysmon线程外，是否还有其他线程被默认启动？
>
> 可能的候选是网络轮询器线程。Go运行时在初始化时可能会启动一个网络轮询器线程来处理异步IO事件，即使当前没有网络操作。例如，在Linux上，网络轮询器可能使用epoll，而相关的处理可能需要一个单独的线程来等待事件。这种情况下，即使程序没有显式的网络操作，网络轮询器线程也会被启动。
>
> 因此，三个线程可能是：
>
> 1. 主线程（运行用户代码，绑定P）
>
> 2. sysmon线程（独立，不绑定P）
>
> 3. 网络轮询器线程（处理IO事件）
>
> 这样，在默认情况下，即使没有IO操作，网络轮询器线程也会被启动，从而导致线程数为3。
>
> 接下来需要验证这个结论是否正确。例如，查看Go运行时的代码，或者通过实验观察线程的作用。
>
> 另外，用户提到的例子中只有一个死循环的goroutine，没有IO操作，但网络轮询器线程是否会被默认启动？
>
> 根据Go的运行时代码，网络轮询器确实会在程序启动时初始化。例如，在runtime/netpoll_epoll.go中，初始化时会创建一个epoll实例，并且可能启动一个线程来等待事件。这可能就是第三个线程的来源。
>
> 因此，三个线程应该是：
>
> 1. 主线程（运行main goroutine，绑定P）
>
> 2. sysmon线程
>
> 3. 网络轮询器线程（处理IO事件）
>
> 此外，在某些情况下，可能还有其他线程，例如当使用某些包时，比如使用cgo时，会有一个线程处理信号，但用户例子中没有使用cgo，所以可能不适用。
>
> 因此，最终的结论是三个线程分别是主线程、sysmon线程和网络轮询器线程。

当使用 `GOMAXPROCS=1` 运行一个单 Goroutine 的死循环时，进程的 3 个线程通常由以下角色组成：

---

### **1. 三个线程的组成**
| 线程类型            | 作用                                                                 |
| ------------------- | -------------------------------------------------------------------- |
| **主线程**          | 运行用户代码的初始线程，绑定一个 P（逻辑处理器），执行 `main` 函数。 |
| **sysmon 监控线程** | 独立的后台线程，负责抢占、GC 触发、网络轮询等全局任务。              |
| **网络轮询器线程**  | 处理异步 I/O 事件（如 `epoll`/`kqueue`），由 Go 运行时自动创建。     |

---

### **2. 详细分析**
#### **(1) 主线程**
- **绑定 P**：`GOMAXPROCS=1` 表示只有一个 P，主线程独占该 P。
- **执行代码**：运行用户 `main` 函数的 Goroutine（死循环占用 CPU）。
- **无系统调用**：由于死循环中无 I/O 或阻塞操作，主线程不会让出 P。

#### **(2) sysmon 线程**
- **独立运行**：不绑定任何 P，负责：
  - 检测并抢占运行时间超过 10ms 的 Goroutine（但由于死循环无函数调用，Go 1.14+ 的信号抢占才有效）。
  - 触发垃圾回收（GC）的标记阶段。
  - 轮询网络事件（与网络轮询器线程协同工作）。

#### **(3) 网络轮询器线程**
- **异步 I/O 处理**：Go 运行时在初始化时自动创建，即使程序未显式使用网络。
- **操作系统依赖**：
  - Linux：基于 `epoll`，由 `runtime/netpoll_epoll.go` 实现。
  - macOS：基于 `kqueue`，由 `runtime/netpoll_kqueue.go` 实现。
- **默认启动**：无论是否有网络操作，该线程都会被创建，用于处理潜在的 I/O 事件。

---

### **3. 验证实验**
#### **(1) 查看线程信息**
在 Linux 下通过 `ps -T -p <PID>` 或 `cat /proc/<PID>/task/` 查看线程：
```bash
# 示例输出（线程名标识用途）：
~$ ps -T -p <PID>
  PID   SPID TTY      TIME CMD
 1000   1000 pts/0    00:00 main           # 主线程（用户代码）
 1000   1001 pts/0    00:00 sysmon         # sysmon 线程
 1000   1002 pts/0    00:00 IO wait        # 网络轮询器线程
```

#### **(2) 代码行为分析**
以下代码会触发 3 个线程：
```go
package main

func main() {
    for {} // 单 Goroutine 的死循环
}
```
- **无网络操作**：但网络轮询器线程仍被默认创建，确保异步 I/O 就绪时能及时响应。
- **无系统调用**：主线程持续占用 CPU，但 Go 1.14+ 的信号抢占机制会通过 sysmon 介入。

---

### **4. 为什么需要网络轮询器线程？**
Go 的设计哲学是**“默认支持高并发”**，因此运行时会预先初始化关键组件：
- **网络 I/O 就绪通知**：即使当前无网络操作，运行时也会准备好处理突发的 I/O 事件。
- **统一的事件循环**：将 `epoll`/`kqueue` 的等待逻辑放在独立线程，避免阻塞用户 Goroutine。

---

### **5. 特殊场景下的线程数变化**
| 场景                 | 线程数变化                         | 原因                                                  |
| -------------------- | ---------------------------------- | ----------------------------------------------------- |
| **禁用网络轮询器**   | 2 个线程（主线程 + sysmon）        | 需修改运行时源码（不实际推荐）。                      |
| **触发 GC**          | 可能新增临时线程（标记、清扫任务） | GC 的并行阶段会创建短暂的工作线程。                   |
| **发生阻塞系统调用** | 新增线程解除 P 阻塞                | 若 Goroutine 执行系统调用，运行时会创建新线程接管 P。 |

---

### **总结**
- **3 个线程的必然性**：Go 运行时默认初始化主线程、sysmon 和网络轮询器线程，确保抢占、I/O 和调度功能。
- **设计权衡**：通过预创建少量线程，避免运行时动态创建的开销，保障高性能和低延迟。
- **资源控制**：可通过 `GOMAXPROCS` 限制 P 的数量，但线程数下限由运行时保障（通常 ≥3）。


## sysmon 在 Go 的哪个版本里被引入？

> [!query]
> sysmon 在 Go 的哪个版本里被引入？

> [!reasoning]-
>
> 嗯，用户问的是sysmon在Go的哪个版本里被引入。我需要看看提供的搜索结果里有没有相关的信息。首先，搜索结果里的网页1提到Go 1.14引入了异步抢占，但sysmon可能更早就有。网页3和网页5在介绍GMP模型时提到sysmon的作用，比如监控和抢占，但没有明确提到引入的版本。网页8提到sysmon在基于协作的抢占式调度中，尤其是在Go 1.2版本之后，但可能sysmon本身在更早的版本就有了。
>
> 再看网页4，里面提到Go 1.2之后增加了简单的抢占机制，sysmon可能是在那时引入的。网页8详细讲述了sysmon如何工作，并提到在协作式抢占时期（Go 1.2到1.13）使用栈扫描，而Go 1.14用信号抢占。所以sysmon应该是在Go 1.2引入的，作为协作式调度的一部分，用来监控和触发抢占。
>
> 综合来看，sysmon作为监控线程，应该是在Go 1.1或更早引入的，但根据网页8的内容，sysmon在Go 1.2开始用于协作式抢占，而Go 1.1引入了P结构，可能sysmon随着GMP模型的改进被引入。需要确认具体版本。根据网页4中的信息，“Go 1.2 中，添加了简单的‘用户态’任务抢占机制，主要是在系统线程sysmon中监控Goroutine的执行时间”，所以sysmon是在Go 1.2引入的。

sysmon（系统监控线程）是 Go 语言调度器的重要组成部分，它负责全局状态的监控和调度优化。根据历史版本演进和搜索结果中的信息：

1. **sysmon 的引入时间**  
   sysmon 线程的引入可以追溯到 **Go 1.2 版本**。在 Go 1.2 中，调度器首次引入了基于协作的抢占式调度机制，而 sysmon 作为后台监控线程，负责检测长时间运行的 Goroutine 并触发抢占。此时的抢占依赖于 Goroutine 主动调用函数时检查抢占标记（如栈扩展），而 sysmon 通过定期扫描并标记需抢占的 Goroutine 实现协作式调度。

2. **sysmon 的演进**  
   - **Go 1.14 版本**：引入了基于信号的抢占式调度，sysmon 的功能进一步增强。它通过向运行时间超过 10ms 的 Goroutine 所在线程发送 `SIGURG` 信号，强制触发抢占，解决了无函数调用的死循环无法被抢占的问题。  
   - **当前版本**：sysmon 的功能包括内存回收、网络事件处理、强制 GC 触发、抢占调度等，成为 Go 调度器公平性和稳定性的核心保障。

3. **sysmon 的关键作用**  
   - **协作式抢占（Go 1.2~1.13）**：通过栈扫描和抢占标记实现，依赖 Goroutine 调用函数时触发调度。  
   - **信号抢占（Go 1.14+）**：通过操作系统信号强制抢占，即使 Goroutine 无函数调用也能被调度。  

综上，sysmon 线程最早在 **Go 1.2** 版本被引入，并随着调度器的演进不断优化功能，成为现代 Go 并发模型中不可或缺的组件。

## 垃圾回收的STW与抢占

> [!query]
> 我已知 Go 的垃圾回收基于三色标记法与混合写屏障。垃圾回收具体是什么时候发生 STW ？如何发生抢占？

> [!reasoning]-
>
> 嗯，用户之前已经问过Go调度器中的协作式和抢占式调度，现在又接着问垃圾回收中的STW和抢占。看来他对Go的运行时机制，特别是并发控制和GC很感兴趣。需要详细解答这两个问题，但得先理清楚GC中的STW阶段以及如何触发抢占。
>
> 首先，用户知道Go的GC使用三色标记和混合写屏障，但可能不清楚具体什么时候会发生STW。需要解释GC的四个阶段，特别是Mark Termination阶段会STW。这时候要说明为什么需要在这个阶段暂停所有goroutine，比如为了完成标记、处理剩余工作，并确保数据一致性。
>
> 然后，关于STW如何触发抢占，需要联系之前讨论的抢占式调度机制。比如，当GC需要STW时，运行时系统会通过信号抢占所有运行中的goroutine，让它们暂停。这部分需要结合之前的回答，强调信号抢占在Go 1.14后的作用，以及sysmon线程如何检测并触发抢占。
>
> 用户可能还不太明白STW的具体影响，比如暂停时间的长短，或者如何优化以减少STW时间。可能需要提到Go的GC优化，比如并发标记和减少STW时间的技术，但用户的问题集中在STW何时发生和如何抢占，所以这部分可以点到为止。
>
> 另外，用户可能混淆了GC中的抢占和普通调度中的抢占。需要明确在GC的STW阶段，抢占是为了让所有goroutine停止，而普通调度中的抢占是为了公平分配CPU时间。两者机制类似，但目的不同。
>
> 还要注意回答结构是否清晰，比如分点说明STW发生的阶段和抢占的方式。可能需要用例子说明，比如在死循环中如果不让出CPU，旧版本Go可能无法抢占，导致GC延迟，而1.14之后通过信号解决这个问题。
>
> 最后，确认回答是否覆盖了用户的问题，是否有遗漏。比如，是否解释了GC触发STW的具体步骤，以及如何通过抢占实现STW。需要确保技术细节准确，比如提到的阶段名称、时间阈值（如10ms），以及相关函数或机制（如sysmon、SIGURG信号）。

Go 的垃圾回收（GC）确实基于三色标记法和混合写屏障（Hybrid Write Barrier），其设计目标是**低延迟**和**高并发性**。在 GC 过程中，**Stop The World（STW）** 的时长被大幅缩短，但并未完全消除。以下是 GC 中 STW 发生的具体阶段和抢占机制：

---

### **一、STW（Stop The World）发生的阶段**
Go 的 GC 分为四个阶段，其中 **STW 仅在标记终止阶段（Mark Termination）完全暂停所有用户 Goroutine**：

#### **1. 标记准备阶段（Mark Setup）**
- **短暂 STW（微秒级）**：暂停所有 Goroutine，初始化 GC 任务，开启写屏障（Write Barrier）。
- **目的**：确保在并发标记期间，所有对内存的修改都能被写屏障捕获。

#### **2. 并发标记阶段（Concurrent Mark）**
- **无 STW**：后台线程（GC Worker）与用户 Goroutine **并发执行**，扫描存活对象。
- **混合写屏障**：在用户代码修改指针时，通过写屏障记录修改，避免漏标。

#### **3. 标记终止阶段（Mark Termination）**
- **完全 STW（主要暂停点）**：暂停所有用户 Goroutine，完成最后的标记工作。
  - 处理剩余的标记任务（如栈扫描）。
  - 关闭写屏障，统计存活对象。
- **暂停时长**：通常在 **微秒到毫秒级**（Go 1.14 后优化到亚毫秒级）。

#### **4. 并发清理阶段（Concurrent Sweep）**
- **无 STW**：回收未被标记的内存块，与用户 Goroutine 并发执行。

---

### **二、STW 如何触发抢占？**
在标记终止阶段，Go 运行时需要让所有用户 Goroutine 快速暂停。这里依赖两种机制：

#### **1. 协作式抢占（Cooperative Preemption）**
- **主动暂停**：当 Goroutine 执行到**函数调用**或**安全点（Safe Point）** 时（如调用 `runtime` 包中的函数），会检查是否需要进入 STW。
- **局限性**：若 Goroutine 处于**无函数调用的密集循环**（如 `for {}`），协作式抢占会失败。

#### **2. 信号抢占（Signal-based Preemption）**
- **强制暂停**：Go 1.14 后，通过向运行中的线程发送 `SIGURG` 信号，触发抢占。
  - **系统监控线程（sysmon）**：检测到 STW 请求后，向所有 P（Processor）关联的线程发送信号。
  - **信号处理函数**：在收到信号时，保存当前 Goroutine 的上下文并暂停执行。
- **解决死循环问题**：即使 Goroutine 处于无函数调用的循环中，也能被强制抢占。

---

### **三、关键场景示例**
#### **场景 1：函数调用触发协作式抢占**
```go
func main() {
    go func() {
        for { 
            time.Sleep(1) // 函数调用触发抢占检查
        }
    }()
}
```
- 每次 `time.Sleep` 调用会主动让出 CPU，触发抢占检查，顺利进入 STW。

#### **场景 2：无函数调用的死循环**
```go
func main() {
    go func() {
        for {} // 无函数调用，Go 1.13 前无法抢占，1.14+ 通过信号抢占
    }()
}
```
- Go 1.14 前：无法抢占，导致 STW 延迟（甚至程序卡死）。
- Go 1.14+：通过 `SIGURG` 信号强制抢占，确保 STW 及时执行。

---

### **四、优化与挑战**
1. **缩短 STW 时间**：
   - 通过并发标记和混合写屏障，将大部分工作移至并发阶段。
   - Go 1.15 后，标记终止阶段的 STW 时间进一步优化到 **100 微秒以下**。
2. **抢占延迟**：
   - 信号抢占需要操作系统支持，且信号处理本身有微秒级开销。
   - 极端场景（如大量线程或 CPU 负载过高）可能影响抢占效率。

---

### **总结**
- **STW 发生时机**：仅在标记终止阶段完全暂停所有 Goroutine，时间极短。
- **抢占机制**：
  - 协作式抢占：依赖函数调用或安全点。
  - 信号抢占（Go 1.14+）：强制暂停无函数调用的 Goroutine。
- **设计目标**：通过混合机制，在低延迟和高并发之间取得平衡。

Go 的 GC 通过逐步减少 STW 时间和增强抢占能力，显著降低了业务代码的感知停顿（如从 Go 1.0 的秒级 STW 优化到现在的亚毫秒级）。


## 写屏障（Write Barrier）机制解析

> [!query]
> 为什么标记准备阶段只是短暂 STW ，但标记终止阶段却要完全 STW ？这两次 STW 里都具体要做什么？

> [!reasoning]-
>
> 好的，我现在需要回答用户的问题：“为什么标记准备阶段只是短暂 STW，但标记终止阶段却要完全 STW？这两次 STW 里都具体要做什么？” 这个问题涉及到Go语言垃圾回收（GC）机制中的两个关键阶段：标记准备阶段（Mark Setup）和标记终止阶段（Mark Termination）。用户想知道这两个阶段为何在STW（Stop The World）的时间和范围上有差异，以及它们各自的具体任务。
>
> 首先，我需要回忆之前关于Go GC的知识。根据之前的对话，Go的GC采用三色标记法和混合写屏障，分为四个阶段：标记准备、并发标记、标记终止和并发清理。其中，标记准备和标记终止阶段涉及STW，但前者是短暂且部分暂停，后者是完全暂停所有用户Goroutine。用户可能想了解这两个阶段在操作上的不同，导致STW时间差异的原因，以及每个阶段的具体职责。
>
> 接下来，我需要拆解用户的问题。用户实际上在问两个问题：
>
> 1. **为什么标记准备阶段是短暂STW，而标记终止阶段需要完全STW？**
>
> 2. **这两个阶段各自具体执行哪些操作？**
>
> 为了回答第一个问题，我需要比较这两个阶段的任务和它们在GC流程中的作用。标记准备阶段需要初始化GC任务，开启写屏障，但可能不需要完全停止所有Goroutine，因为它可能只需要确保在开启写屏障后，所有的内存写入都能被正确捕获。而标记终止阶段需要确保所有的标记工作完成，统计存活对象，并关闭写屏障，这可能需要完全暂停以确保一致性。
>
> 对于第二个问题，需要详细说明每个阶段的具体操作步骤，包括设置写屏障、扫描根对象、处理剩余标记任务等。
>
> 接下来，我需要验证这些理解是否正确。例如，标记准备阶段的短暂STW是否主要用于开启写屏障，而标记终止阶段需要确保所有Goroutine都到达安全点，以便完成最后的标记工作。此外，Go在1.14版本后引入的信号抢占机制是否影响这两个阶段的STW处理方式，尤其是如何确保在标记终止阶段能够迅速暂停所有Goroutine。
>
> 我还需要回顾Go GC的设计目标，即最小化STW时间，提高并发性。因此，标记准备阶段的短暂STW可能是为了快速设置必要的结构，而标记终止阶段尽管需要完全STW，但通过优化使其时间极短，通常在微秒到毫秒级别。
>
> 另外，考虑到用户之前的问题涉及抢占式调度，可能需要联系到在标记终止阶段如何强制暂停所有Goroutine，包括那些可能处于死循环中的情况。这里可能涉及协作式抢占和信号抢占的机制，以确保在标记终止阶段的STW能够顺利进行。
>
> 在组织答案时，需要分点明确，首先解释两个阶段的不同职责，然后说明为何它们的STW时间和范围不同，接着详细列出每个阶段的具体操作步骤。同时，结合Go的版本演进，如1.14之后的信号抢占，说明这些机制如何支持标记终止阶段的完全STW。
>
> 可能需要注意的误区包括混淆标记准备和标记终止阶段的任务，或者误解STW的范围。例如，标记准备阶段是否需要完全暂停所有Goroutine，还是仅在某些关键点暂停。根据之前的知识，标记准备阶段的STW是短暂的，可能只需要暂停所有Goroutine足够长的时间来开启写屏障，而标记终止阶段需要完全暂停以确保没有Goroutine在修改内存状态，从而安全地完成标记。
>
> 总结起来，回答的结构应该是：
>
> 1. 解释标记准备阶段的任务和短暂STW的原因。
>
> 2. 解释标记终止阶段的任务和完全STW的必要性。
>
> 3. 分点列出每个阶段的具体操作步骤。
>
> 4. 结合Go的GC设计目标和抢占机制，说明如何优化STW时间。
>
> 最后，确保语言通俗易懂，避免过于技术化的术语，同时保持准确性。可能还需要通过例子来帮助理解，比如在标记准备阶段开启写屏障，而在标记终止阶段关闭写屏障并统计结果，这样的操作需要不同的暂停策略。

Go 的垃圾回收（GC）在标记准备阶段（Mark Setup）和标记终止阶段（Mark Termination）均涉及 **STW（Stop The World）**，但两者的 **暂停范围** 和 **耗时** 存在显著差异。这种差异源于两个阶段的核心任务不同，以下是详细解释：

---

### **一、标记准备阶段（Mark Setup）**
#### **1. 为什么只是短暂 STW？**
- **目标**：为并发标记阶段（Concurrent Mark）做准备，确保所有 Goroutine 在并发标记期间的内存修改能被正确跟踪。
- **无需完全暂停**：不需要等待所有 Goroutine 完全停止，只需确保写屏障（Write Barrier）被正确启用，并为后续标记初始化关键数据结构。
- **耗时极短**：通常在 **微秒级**，仅需暂停所有 Goroutine 至安全点（Safe Point）以快速完成初始化。

#### **2. 具体操作**
- **开启写屏障**：启动混合写屏障（Hybrid Write Barrier），确保后续内存写入被记录，避免漏标。
- **扫描根对象**：快速扫描全局变量、栈等根对象（Roots），找到初始存活对象。
- **初始化标记队列**：将根对象加入标记队列，供并发标记阶段使用。
- **协调 Goroutine**：通过协作式抢占或信号抢占，确保所有 Goroutine 短暂暂停以启用写屏障。

---

### **二、标记终止阶段（Mark Termination）**
#### **1. 为什么要完全 STW？**
- **目标**：确保标记结果的一致性，避免并发操作干扰最终统计。
- **关键操作不可并发**：
  - 需要关闭写屏障，停止记录内存修改。
  - 必须完成所有未完成的标记任务（如栈扫描）。
  - 统计存活对象，计算需要回收的内存。
- **完全一致性要求**：若允许 Goroutine 继续运行，可能修改内存状态，导致统计错误。

#### **2. 具体操作**
- **完全暂停所有 Goroutine**：通过信号抢占（Go 1.14+）强制暂停所有运行中的 Goroutine。
- **处理剩余标记任务**：
  - 完成栈扫描（部分 Goroutine 的栈可能未在并发阶段扫描）。
  - 处理标记队列中剩余的对象。
- **关闭写屏障**：停止混合写屏障，后续用户代码的内存写入不再被跟踪。
- **统计存活对象**：确定所有存活对象，生成待回收的内存块列表。
- **准备清理阶段**：将未标记的内存标记为可回收，供并发清理阶段（Sweep）处理。

---

### **三、关键差异对比**
| **阶段**     | **标记准备阶段**                      | **标记终止阶段**               |
| ------------ | ------------------------------------- | ------------------------------ |
| **STW 范围** | 短暂暂停，仅需启用写屏障和初始化      | 完全暂停所有 Goroutine         |
| **耗时**     | 微秒级（如 10-100μs）                 | 亚毫秒级（如 100μs-1ms）       |
| **核心任务** | 开启写屏障，扫描根对象                | 关闭写屏障，完成标记，统计结果 |
| **并发性**   | 完成后立即恢复用户 Goroutine 并发执行 | 必须完全暂停，确保最终一致性   |

---

### **四、为何标记终止阶段必须完全 STW？**
1. **写屏障关闭的原子性**：
   - 关闭写屏障时，若仍有 Goroutine 在运行，可能漏掉某些内存修改，导致错误回收存活对象。
2. **统计存活对象的精确性**：
   - 必须保证所有标记任务完成，否则可能误判对象生死。
3. **避免竞争条件**：
   - 若允许 Goroutine 在标记终止阶段运行，其内存分配或指针修改可能破坏标记结果。

---

### **五、示例场景**
#### **场景 1：标记准备阶段的短暂 STW**
```go
// 标记准备阶段：
1. STW 暂停所有 Goroutine（微秒级）。
2. 开启写屏障，扫描根对象（全局变量、栈）。
3. 恢复所有 Goroutine，并发标记开始。
```

#### **场景 2：标记终止阶段的完全 STW**
```go
// 标记终止阶段：
1. STW 完全暂停所有 Goroutine（亚毫秒级）。
2. 扫描未处理的栈，完成剩余标记。
3. 关闭写屏障，统计存活对象。
4. 恢复所有 Goroutine，并发清理开始。
```

---

### **六、优化与挑战**
- **Go 1.14+ 的信号抢占**：确保标记终止阶段能快速暂停死循环 Goroutine。
- **写屏障的设计**：混合写屏障减少了 STW 时间，但仍需短暂暂停以启用/关闭。
- **并发标记的平衡**：尽可能将工作移至并发阶段（如大部分标记和清理），最小化 STW 影响。

---

### **总结**
- **标记准备阶段**：短暂 STW 是为了启用写屏障和初始化，不依赖完全一致性。
- **标记终止阶段**：完全 STW 是为了保证标记结果的绝对一致性和安全性。
- **设计核心**：通过分离关键操作（启用/关闭写屏障、统计结果），Go 在低延迟和高并发之间取得了平衡。
