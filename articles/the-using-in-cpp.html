<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta property="og:image" content="https://ryojerryyu.github.io/blog-next/img/home-bg-kasumi-hanabi.jpg" data-next-head=""/><meta name="twitter:image" content="https://ryojerryyu.github.io/blog-next/img/home-bg-kasumi-hanabi.jpg" data-next-head=""/><meta property="og:url" content="https://blog.ryo-okami.xyz/articles/the-using-in-cpp" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:site" content="@ryo_okami" data-next-head=""/><meta name="twitter:creator" content="@ryo_okami" data-next-head=""/><link rel="icon" href="/blog-next/favicon.ico" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" data-next-head=""/><title data-next-head="">C++中using关键字的使用 | Ryo&#x27;s Blog</title><meta property="og:title" content="C++中using关键字的使用" data-next-head=""/><meta property="og:site_name" content="Ryo&#x27;s Blog" data-next-head=""/><meta name="twitter:title" content="C++中using关键字的使用 | Ryo&#x27;s Blog" data-next-head=""/><meta name="description" content="1. 引入整个命名空间中的成员
   不引入命名空间时，使用其中变量需要使用`&lt;命名空间名&gt;::&lt;变量名&gt;`的方式使用。
   ```C++" data-next-head=""/><meta property="og:description" content="1. 引入整个命名空间中的成员
   不引入命名空间时，使用其中变量需要使用`&lt;命名空间名&gt;::&lt;变量名&gt;`的方式使用。
   ```C++" data-next-head=""/><meta name="twitter:description" content="1. 引入整个命名空间中的成员
   不引入命名空间时，使用其中变量需要使用`&lt;命名空间名&gt;::&lt;变量名&gt;`的方式使用。
   ```C++" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="article:published_time" content="2020-01-28T18:00:00.000Z" data-next-head=""/><meta property="article:modified_time" content="2022-03-27T13:30:33.000Z" data-next-head=""/><meta property="article:tag" content="C++" data-next-head=""/><meta property="article:tag" content="杂技" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog-next/_next/static/css/8db32621d94754ab.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/8db32621d94754ab.css" data-n-g=""/><link rel="preload" href="/blog-next/_next/static/css/5bd958681a4509b5.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/5bd958681a4509b5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog-next/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog-next/_next/static/chunks/webpack-b8c897526ea80e96.js" defer=""></script><script src="/blog-next/_next/static/chunks/framework-898697981b1ca118.js" defer=""></script><script src="/blog-next/_next/static/chunks/main-a0a5fc4e603d1ed2.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/_app-861c1dc7f33f622c.js" defer=""></script><script src="/blog-next/_next/static/chunks/ee8b1517-1aa9307a3ec34e41.js" defer=""></script><script src="/blog-next/_next/static/chunks/4785-70b0f2db3df81cbd.js" defer=""></script><script src="/blog-next/_next/static/chunks/9965-95126bbb1fbfbef4.js" defer=""></script><script src="/blog-next/_next/static/chunks/39-0a3d8a77fd97d8ce.js" defer=""></script><script src="/blog-next/_next/static/chunks/7171-d77db8c0b7156916.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/articles/%5Bslug%5D-254a27b2b1020aab.js" defer=""></script><script src="/blog-next/_next/static/cMm9PNrybYEKe5evC86tr/_buildManifest.js" defer=""></script><script src="/blog-next/_next/static/cMm9PNrybYEKe5evC86tr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="DefaultLayout_header__aepTD"><div class="DefaultLayout_icon__11sTk"><div class="DefaultLayout_textbox__H9FZG"><a class="DefaultLayout_textlink__EVwys" href="/blog-next">Ryo&#x27;s Blog</a></div></div><div class="DefaultLayout_navBar__gY4ra"><div class="DefaultLayout_navBarItem__nhL6L"><a class="DefaultLayout_textlink__EVwys" href="/blog-next/articles">Articles</a></div><div class="DefaultLayout_navBarItem__nhL6L"><a class="DefaultLayout_textlink__EVwys" href="/blog-next/ideas">Ideas</a></div><div class="DefaultLayout_navBarItem__nhL6L"><a class="DefaultLayout_textlink__EVwys" href="/blog-next/tags">Tags</a></div><div class="DefaultLayout_navBarItem__nhL6L"><a class="DefaultLayout_textlink__EVwys" href="/blog-next/clips">Clips</a></div></div><div class="DefaultLayout_headerRight__0Kj26"><div class=" flex flex-row gap-8 items-center justify-center"><a title="Twitter" href="https://twitter.com/ryo_okami"><svg class=" h-6 w-6 fill-gray-300 hover:fill-white transition-all ease-in-out" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a title="GitHub" href="https://github.com/RyoJerryYu"><svg class=" h-6 w-6 fill-gray-300 hover:fill-white transition-all ease-in-out" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a title="Pixiv" href="https://www.pixiv.net/users/9159893"><svg class=" h-6 w-6 fill-gray-300 hover:fill-white transition-all ease-in-out" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.935 0A4.924 4.924 0 0 0 0 4.935v14.13A4.924 4.924 0 0 0 4.935 24h14.13A4.924 4.924 0 0 0 24 19.065V4.935A4.924 4.924 0 0 0 19.065 0zm7.81 4.547c2.181 0 4.058.676 5.399 1.847a6.118 6.118 0 0 1 2.116 4.66c.005 1.854-.88 3.476-2.257 4.563-1.375 1.092-3.225 1.697-5.258 1.697-2.314 0-4.46-.842-4.46-.842v2.718c.397.116 1.048.365.635.779H5.79c-.41-.41.19-.65.644-.779V7.666c-1.053.81-1.593 1.51-1.868 2.031.32 1.02-.284.969-.284.969l-1.09-1.73s3.868-4.39 9.553-4.39zm-.19.971c-1.423-.003-3.184.473-4.27 1.244v8.646c.988.487 2.484.832 4.26.832h.01c1.596 0 2.98-.593 3.93-1.533.952-.948 1.486-2.183 1.492-3.683-.005-1.54-.504-2.864-1.42-3.86-.918-.992-2.274-1.645-4.002-1.646Z"></path></svg></a></div></div></header><div class="DefaultLayout_headerBg__FStmg"></div><div class="max-w-3xl mx-auto p-2"><div class="DefaultLayout_contentHeight__DabjQ"><article class="Post_post__acRqJ"><h1 class="Post_postTitle__N1NIA">C++中using关键字的使用</h1><div class="Post_postDate__SQx7A"><time dateTime="2020-01-28T18:00:00.000Z">2020-01-28</time></div><div class="TagsBox_tagsBox__WzhAf mt-2"><a href="/blog-next/tags/c++"><div class="TagsBox_tag__Rk32C">C++</div></a><a href="/blog-next/tags/%E6%9D%82%E6%8A%80"><div class="TagsBox_tag__Rk32C">杂技</div></a></div><div class="post-body Post_postContent__mJ_Ju"><h2 id="using的用法"><a href="#using的用法">using的用法</a></h2>
<h4 id="using与命名空间"><a href="#using与命名空间">using与命名空间</a></h4>
<ol>
<li>
<p>引入整个命名空间中的成员</p>
<p>不引入命名空间时，使用其中变量需要使用<code>&lt;命名空间名&gt;::&lt;变量名&gt;</code>的方式使用。</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>using namespace foo;</span></span></code></pre></figure>
<p>如此会将命名空间foo下所有的成员名称引入，可在直接以 <code>&lt;变量名&gt;</code> 的形式使用。但如此做有可能会使得命名空间foo中部分变量与当前定义的变量名冲突，违反命名空间隔离编译时名称冲突的初衷，因此不建议如此使用。</p>
</li>
<li>
<p>引入命名空间中的部分成员</p>
<p>可通过仅引入命名空间中部分的成员，避免命名冲突。</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>using foo::bar;</span></span></code></pre></figure>
<p>这种方法仅会引入在语句中明确声明的名称。如using一个枚举类时，不会连其定义的枚举常量也一同引入。</p>
</li>
</ol>
<h4 id="using与基类成员"><a href="#using与基类成员">using与基类成员</a></h4>
<ol>
<li>
<p>子类中引入基类名称</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span> class Base {</span></span>
<span data-line=""><span> public:</span></span>
<span data-line=""><span>     std::size_t size() const { return n; }</span></span>
<span data-line=""><span> protected:</span></span>
<span data-line=""><span>     std::size_t n;</span></span>
<span data-line=""><span> };</span></span>
<span data-line=""> </span>
<span data-line=""><span> class Derived : private Base {</span></span>
<span data-line=""><span> public:</span></span>
<span data-line=""><span>     using Base::size;</span></span>
<span data-line=""><span> protected:</span></span>
<span data-line=""><span>     using Base::n;</span></span>
<span data-line=""><span> // ...</span></span>
<span data-line=""><span> };</span></span></code></pre></figure>
<p>例中子类private继承基类，由于private继承使得<code>Base::size</code>与<code>Base::n</code>可视性变为private。而使用<code>using Base::size</code>、<code>using Base::n</code>后，可分别使其变为public与protected。</p>
</li>
<li>
<p>子类成员函数与基类同名时保留基类函数用以重载</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span> class Base</span></span>
<span data-line=""><span> {</span></span>
<span data-line=""><span> public:</span></span>
<span data-line=""><span>     int Func(){return 0;}</span></span>
<span data-line=""><span> };</span></span>
<span data-line=""><span> class Derived : Base</span></span>
<span data-line=""><span> {</span></span>
<span data-line=""><span> public:</span></span>
<span data-line=""><span>     using Base::Func;</span></span>
<span data-line=""><span>     int Func(int);</span></span>
<span data-line=""><span> };</span></span></code></pre></figure>
<p>子类中定义的成员函数与基类中重名时，即使函数原型不同，子类函数也会覆盖基类函数。</p>
<p>如果基类中定义了一个函数的多个重载，而子类中又重写或重定义了其中某些版本，或是定义了一个新的重载，则基类中该函数的所有重载均被隐藏。</p>
<p>此时可以在子类中使用<code>using Base::Func</code>，令基类中所有重载版本在子类中可见，再重定义需要更改的版本。</p>
</li>
</ol>
<p>又如cppreference中的<a href="https://en.cppreference.com/w/cpp/language/using_declaration#In_class_definition">例子</a>：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>#include &lt;iostream&gt;</span></span>
<span data-line=""><span>struct B {</span></span>
<span data-line=""><span>    virtual void f(int) { std::cout &lt;&lt; &quot;B::f\n&quot;; }</span></span>
<span data-line=""><span>    void g(char)        { std::cout &lt;&lt; &quot;B::g\n&quot;; }</span></span>
<span data-line=""><span>    void h(int)         { std::cout &lt;&lt; &quot;B::h\n&quot;; }</span></span>
<span data-line=""><span>protected:</span></span>
<span data-line=""><span>    int m; // B::m is protected</span></span>
<span data-line=""><span>    typedef int value_type;</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>struct D : B {</span></span>
<span data-line=""><span>    using B::m; // D::m is public</span></span>
<span data-line=""><span>    using B::value_type; // D::value_type is public</span></span>
<span data-line=""> </span>
<span data-line=""><span>    using B::f;</span></span>
<span data-line=""><span>    void f(int) { std::cout &lt;&lt; &quot;D::f\n&quot;; } // D::f(int) overrides B::f(int)</span></span>
<span data-line=""><span>    using B::g;</span></span>
<span data-line=""><span>    void g(int) { std::cout &lt;&lt; &quot;D::g\n&quot;; } // both g(int) and g(char) are visible</span></span>
<span data-line=""><span>                                        // as members of D</span></span>
<span data-line=""><span>    using B::h;</span></span>
<span data-line=""><span>    void h(int) { std::cout &lt;&lt; &quot;D::h\n&quot;; } // D::h(int) hides B::h(int)</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>int main()</span></span>
<span data-line=""><span>{</span></span>
<span data-line=""><span>    D d;</span></span>
<span data-line=""><span>    B&amp; b = d;</span></span>
<span data-line=""> </span>
<span data-line=""><span>//    b.m = 2; // error, B::m is protected</span></span>
<span data-line=""><span>    d.m = 1; // protected B::m is accessible as public D::m</span></span>
<span data-line=""><span>    b.f(1); // calls derived f()</span></span>
<span data-line=""><span>    d.f(1); // calls derived f()</span></span>
<span data-line=""><span>    d.g(1); // calls derived g(int)</span></span>
<span data-line=""><span>    d.g(&#x27;a&#x27;); // calls base g(char)</span></span>
<span data-line=""><span>    b.h(1); // calls base h()</span></span>
<span data-line=""><span>    d.h(1); // calls derived h()</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p><code>using</code>语句可以改变基类成员的可访问性，也能在子类中重载(Overload)、重写(Override)基类的函数，或是通过重定义隐藏(Hide)对应的基类函数。</p>
<h4 id="using与别名"><a href="#using与别名">using与别名</a></h4>
<p>using在C++11开始，可用于别名的声明。用法如下：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>using UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;//普通别名</span></span>
<span data-line=""><span>using FP = void (*) (int, const std::string&amp;);//函数指针别名</span></span>
<span data-line=""> </span>
<span data-line=""><span>template &lt;typename T&gt;</span></span>
<span data-line=""><span>using Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;//模板别名</span></span>
<span data-line=""><span>Vec&lt;int&gt; vec;//模板别名的使用</span></span></code></pre></figure>
<h2 id="using关键字与typedef关键字定义别名的不同"><a href="#using关键字与typedef关键字定义别名的不同">using关键字与typedef关键字定义别名的不同</a></h2>
<p>在STL容器或是其他泛型中若是再接受一个容器类型，类型名称就会写得很长。使用typedef或using定义别名会变得比较方便：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>typedef std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; UPtrMapSS;</span></span>
<span data-line=""> </span>
<span data-line=""><span>using UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;</span></span></code></pre></figure>
<p>对于函数指针，使用using语句可以把函数原型与别名强制分到左右两边，比使用typedef易读得多：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>typedef void (*FP) (int, const std::string&amp;);</span></span>
<span data-line=""> </span>
<span data-line=""><span>using FP = void (*) (int, const std::string&amp;);</span></span></code></pre></figure>
<hr/>
<p>在C++中，若试图使用typedef定义一个模板：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>template &lt;typename T&gt;</span></span>
<span data-line=""><span>typedef MyVector&lt;T, MyAlloc&lt;T&gt;&gt; Vec;</span></span>
<span data-line=""> </span>
<span data-line=""><span>// usage</span></span>
<span data-line=""><span>Vec&lt;int&gt; vec;</span></span></code></pre></figure>
<p>编译就会报错，提示：</p>
<blockquote>
<p>error: a typedef cannot be a template</p>
</blockquote>
<p>在一些STL中，通过如下方式包装一层来使用：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>template &lt;typename T&gt;</span></span>
<span data-line=""><span>struct Vec</span></span>
<span data-line=""><span>{</span></span>
<span data-line=""><span>  typedef MyVector&lt;T, MyAlloc&lt;T&gt;&gt; type;</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>// usage</span></span>
<span data-line=""><span>Vec&lt;int&gt;::type vec;</span></span></code></pre></figure>
<p>如此显得十分不美观，且要是在模板类中或参数传递时使用typename强制这为类型，而不是其他如静态成员等语法：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>template &lt;typename T&gt;</span></span>
<span data-line=""><span>class Widget</span></span>
<span data-line=""><span>{</span></span>
<span data-line=""><span>  typename Vec&lt;T&gt;::type vec;</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>而using关键字可定义模板别名，则一切都会显得十分自然：</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#232136;color:#e0def4" tabindex="0" data-language="C++" data-theme="rose-pine-moon"><code data-language="C++" data-theme="rose-pine-moon" style="display:grid"><span data-line=""><span>template &lt;typename T&gt;</span></span>
<span data-line=""><span>using Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;</span></span>
<span data-line=""> </span>
<span data-line=""><span>// usage</span></span>
<span data-line=""><span>Vec&lt;int&gt; vec;</span></span>
<span data-line=""> </span>
<span data-line=""><span>// in a class template</span></span>
<span data-line=""><span>template &lt;typename T&gt;</span></span>
<span data-line=""><span>class Widget</span></span>
<span data-line=""><span>{</span></span>
<span data-line=""><span>  Vec&lt;T&gt; vec;</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<hr/>
<p>能做到类似别名功能的，还有宏#define。但#define运行在编译前的宏处理阶段，对代码进行字符串替换。没有类型检查或其他编译、链接阶段才能进行的检查，不具备安全性。在C++11中不提倡使用#define。</p></div><div class="TagsBox_tagsBox__WzhAf mt-4"><a href="/blog-next/tags/c++"><div class="TagsBox_tag__Rk32C">C++</div></a><a href="/blog-next/tags/%E6%9D%82%E6%8A%80"><div class="TagsBox_tag__Rk32C">杂技</div></a></div><div class="mt-4 mb-4 flex justify-center"><div class="ml-0 mr-auto"><a href="/blog-next/articles/python-dict">&lt;- Python字典的实现原理</a></div><div class="mr-0 ml-auto"><a href="/blog-next/articles/Building-this-blog">搭建博客的过程 -&gt;</a></div></div><hr class="mt-4"/></article><div class="w-full"><div></div><div class="text-center">Loading comments...</div></div></div></div><footer class="DefaultLayout_footer__n5339"><div class="max-w-3xl mx-auto p-2 w-full"><div class="flex flex-row justify-center items-center"><div class="DefaultLayout_footerLeft__j0yvY">© 2023 Ryo Jerry Yu. All rights reserved.</div><div class="DefaultLayout_footerRight___Dn67"><div class=" flex flex-row gap-8 items-center justify-center"><a title="Twitter" href="https://twitter.com/ryo_okami"><svg class="DefaultLayout_footerIcon__sgrmB h-8 w-8" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a title="GitHub" href="https://github.com/RyoJerryYu"><svg class="DefaultLayout_footerIcon__sgrmB h-8 w-8" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a title="Pixiv" href="https://www.pixiv.net/users/9159893"><svg class="DefaultLayout_footerIcon__sgrmB h-8 w-8" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.935 0A4.924 4.924 0 0 0 0 4.935v14.13A4.924 4.924 0 0 0 4.935 24h14.13A4.924 4.924 0 0 0 24 19.065V4.935A4.924 4.924 0 0 0 19.065 0zm7.81 4.547c2.181 0 4.058.676 5.399 1.847a6.118 6.118 0 0 1 2.116 4.66c.005 1.854-.88 3.476-2.257 4.563-1.375 1.092-3.225 1.697-5.258 1.697-2.314 0-4.46-.842-4.46-.842v2.718c.397.116 1.048.365.635.779H5.79c-.41-.41.19-.65.644-.779V7.666c-1.053.81-1.593 1.51-1.868 2.031.32 1.02-.284.969-.284.969l-1.09-1.73s3.868-4.39 9.553-4.39zm-.19.971c-1.423-.003-3.184.473-4.27 1.244v8.646c.988.487 2.484.832 4.26.832h.01c1.596 0 2.98-.593 3.93-1.533.952-.948 1.486-2.183 1.492-3.683-.005-1.54-.504-2.864-1.42-3.86-.918-.992-2.274-1.645-4.002-1.646Z"></path></svg></a></div></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"the-using-in-cpp","tags":[{"tag":"C++","slug":"c++","path":"/tags/c++","postSlugs":[{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"}]},{"tag":"杂技","slug":"杂技","path":"/tags/杂技","postSlugs":[{"postType":"article","postSlug":"Building-this-blog","postPagePath":"/articles/Building-this-blog"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"}]}],"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    figure: \"figure\",\n    h2: \"h2\",\n    h4: \"h4\",\n    hr: \"hr\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"using的用法\",\n      children: _jsx(_components.a, {\n        href: \"#using的用法\",\n        children: \"using的用法\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"using与命名空间\",\n      children: _jsx(_components.a, {\n        href: \"#using与命名空间\",\n        children: \"using与命名空间\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"引入整个命名空间中的成员\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"不引入命名空间时，使用其中变量需要使用\", _jsx(_components.code, {\n            children: \"\u003c命名空间名\u003e::\u003c变量名\u003e\"\n          }), \"的方式使用。\"]\n        }), \"\\n\", _jsx(_components.figure, {\n          \"data-rehype-pretty-code-figure\": \"\",\n          children: _jsx(_components.pre, {\n            style: {\n              backgroundColor: \"#232136\",\n              color: \"#e0def4\"\n            },\n            tabIndex: \"0\",\n            \"data-language\": \"C++\",\n            \"data-theme\": \"rose-pine-moon\",\n            children: _jsx(_components.code, {\n              \"data-language\": \"C++\",\n              \"data-theme\": \"rose-pine-moon\",\n              style: {\n                display: \"grid\"\n              },\n              children: _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"using namespace foo;\"\n                })\n              })\n            })\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"如此会将命名空间foo下所有的成员名称引入，可在直接以 \", _jsx(_components.code, {\n            children: \"\u003c变量名\u003e\"\n          }), \" 的形式使用。但如此做有可能会使得命名空间foo中部分变量与当前定义的变量名冲突，违反命名空间隔离编译时名称冲突的初衷，因此不建议如此使用。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"引入命名空间中的部分成员\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"可通过仅引入命名空间中部分的成员，避免命名冲突。\"\n        }), \"\\n\", _jsx(_components.figure, {\n          \"data-rehype-pretty-code-figure\": \"\",\n          children: _jsx(_components.pre, {\n            style: {\n              backgroundColor: \"#232136\",\n              color: \"#e0def4\"\n            },\n            tabIndex: \"0\",\n            \"data-language\": \"C++\",\n            \"data-theme\": \"rose-pine-moon\",\n            children: _jsx(_components.code, {\n              \"data-language\": \"C++\",\n              \"data-theme\": \"rose-pine-moon\",\n              style: {\n                display: \"grid\"\n              },\n              children: _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"using foo::bar;\"\n                })\n              })\n            })\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"这种方法仅会引入在语句中明确声明的名称。如using一个枚举类时，不会连其定义的枚举常量也一同引入。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"using与基类成员\",\n      children: _jsx(_components.a, {\n        href: \"#using与基类成员\",\n        children: \"using与基类成员\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"子类中引入基类名称\"\n        }), \"\\n\", _jsx(_components.figure, {\n          \"data-rehype-pretty-code-figure\": \"\",\n          children: _jsx(_components.pre, {\n            style: {\n              backgroundColor: \"#232136\",\n              color: \"#e0def4\"\n            },\n            tabIndex: \"0\",\n            \"data-language\": \"C++\",\n            \"data-theme\": \"rose-pine-moon\",\n            children: _jsxs(_components.code, {\n              \"data-language\": \"C++\",\n              \"data-theme\": \"rose-pine-moon\",\n              style: {\n                display: \"grid\"\n              },\n              children: [_jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" class Base {\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" public:\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"     std::size_t size() const { return n; }\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" protected:\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"     std::size_t n;\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" };\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: \" \"\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" class Derived : private Base {\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" public:\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"     using Base::size;\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" protected:\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"     using Base::n;\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" // ...\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" };\"\n                })\n              })]\n            })\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"例中子类private继承基类，由于private继承使得\", _jsx(_components.code, {\n            children: \"Base::size\"\n          }), \"与\", _jsx(_components.code, {\n            children: \"Base::n\"\n          }), \"可视性变为private。而使用\", _jsx(_components.code, {\n            children: \"using Base::size\"\n          }), \"、\", _jsx(_components.code, {\n            children: \"using Base::n\"\n          }), \"后，可分别使其变为public与protected。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"子类成员函数与基类同名时保留基类函数用以重载\"\n        }), \"\\n\", _jsx(_components.figure, {\n          \"data-rehype-pretty-code-figure\": \"\",\n          children: _jsx(_components.pre, {\n            style: {\n              backgroundColor: \"#232136\",\n              color: \"#e0def4\"\n            },\n            tabIndex: \"0\",\n            \"data-language\": \"C++\",\n            \"data-theme\": \"rose-pine-moon\",\n            children: _jsxs(_components.code, {\n              \"data-language\": \"C++\",\n              \"data-theme\": \"rose-pine-moon\",\n              style: {\n                display: \"grid\"\n              },\n              children: [_jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" class Base\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" {\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" public:\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"     int Func(){return 0;}\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" };\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" class Derived : Base\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" {\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" public:\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"     using Base::Func;\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \"     int Func(int);\"\n                })\n              }), \"\\n\", _jsx(_components.span, {\n                \"data-line\": \"\",\n                children: _jsx(_components.span, {\n                  children: \" };\"\n                })\n              })]\n            })\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"子类中定义的成员函数与基类中重名时，即使函数原型不同，子类函数也会覆盖基类函数。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"如果基类中定义了一个函数的多个重载，而子类中又重写或重定义了其中某些版本，或是定义了一个新的重载，则基类中该函数的所有重载均被隐藏。\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"此时可以在子类中使用\", _jsx(_components.code, {\n            children: \"using Base::Func\"\n          }), \"，令基类中所有重载版本在子类中可见，再重定义需要更改的版本。\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"又如cppreference中的\", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/language/using_declaration#In_class_definition\",\n        children: \"例子\"\n      }), \"：\"]\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"#include \u003ciostream\u003e\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"struct B {\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    virtual void f(int) { std::cout \u003c\u003c \\\"B::f\\\\n\\\"; }\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    void g(char)        { std::cout \u003c\u003c \\\"B::g\\\\n\\\"; }\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    void h(int)         { std::cout \u003c\u003c \\\"B::h\\\\n\\\"; }\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"protected:\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    int m; // B::m is protected\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    typedef int value_type;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"};\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"struct D : B {\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    using B::m; // D::m is public\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    using B::value_type; // D::value_type is public\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    using B::f;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    void f(int) { std::cout \u003c\u003c \\\"D::f\\\\n\\\"; } // D::f(int) overrides B::f(int)\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    using B::g;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    void g(int) { std::cout \u003c\u003c \\\"D::g\\\\n\\\"; } // both g(int) and g(char) are visible\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"                                        // as members of D\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    using B::h;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    void h(int) { std::cout \u003c\u003c \\\"D::h\\\\n\\\"; } // D::h(int) hides B::h(int)\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"};\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"int main()\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"{\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    D d;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    B\u0026 b = d;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"//    b.m = 2; // error, B::m is protected\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    d.m = 1; // protected B::m is accessible as public D::m\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    b.f(1); // calls derived f()\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    d.f(1); // calls derived f()\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    d.g(1); // calls derived g(int)\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    d.g('a'); // calls base g(char)\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    b.h(1); // calls base h()\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"    d.h(1); // calls derived h()\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"}\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"using\"\n      }), \"语句可以改变基类成员的可访问性，也能在子类中重载(Overload)、重写(Override)基类的函数，或是通过重定义隐藏(Hide)对应的基类函数。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"using与别名\",\n      children: _jsx(_components.a, {\n        href: \"#using与别名\",\n        children: \"using与别名\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"using在C++11开始，可用于别名的声明。用法如下：\"\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"using UPtrMapSS = std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e;//普通别名\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"using FP = void (*) (int, const std::string\u0026);//函数指针别名\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"template \u003ctypename T\u003e\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"using Vec = MyVector\u003cT, MyAlloc\u003cT\u003e\u003e;//模板别名\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"Vec\u003cint\u003e vec;//模板别名的使用\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"using关键字与typedef关键字定义别名的不同\",\n      children: _jsx(_components.a, {\n        href: \"#using关键字与typedef关键字定义别名的不同\",\n        children: \"using关键字与typedef关键字定义别名的不同\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在STL容器或是其他泛型中若是再接受一个容器类型，类型名称就会写得很长。使用typedef或using定义别名会变得比较方便：\"\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"typedef std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e UPtrMapSS;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"using UPtrMapSS = std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e;\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于函数指针，使用using语句可以把函数原型与别名强制分到左右两边，比使用typedef易读得多：\"\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"typedef void (*FP) (int, const std::string\u0026);\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"using FP = void (*) (int, const std::string\u0026);\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"在C++中，若试图使用typedef定义一个模板：\"\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"template \u003ctypename T\u003e\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"typedef MyVector\u003cT, MyAlloc\u003cT\u003e\u003e Vec;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"// usage\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"Vec\u003cint\u003e vec;\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"编译就会报错，提示：\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"error: a typedef cannot be a template\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在一些STL中，通过如下方式包装一层来使用：\"\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"template \u003ctypename T\u003e\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"struct Vec\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"{\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"  typedef MyVector\u003cT, MyAlloc\u003cT\u003e\u003e type;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"};\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"// usage\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"Vec\u003cint\u003e::type vec;\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如此显得十分不美观，且要是在模板类中或参数传递时使用typename强制这为类型，而不是其他如静态成员等语法：\"\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"template \u003ctypename T\u003e\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"class Widget\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"{\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"  typename Vec\u003cT\u003e::type vec;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"};\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而using关键字可定义模板别名，则一切都会显得十分自然：\"\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-rehype-pretty-code-figure\": \"\",\n      children: _jsx(_components.pre, {\n        style: {\n          backgroundColor: \"#232136\",\n          color: \"#e0def4\"\n        },\n        tabIndex: \"0\",\n        \"data-language\": \"C++\",\n        \"data-theme\": \"rose-pine-moon\",\n        children: _jsxs(_components.code, {\n          \"data-language\": \"C++\",\n          \"data-theme\": \"rose-pine-moon\",\n          style: {\n            display: \"grid\"\n          },\n          children: [_jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"template \u003ctypename T\u003e\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"using Vec = MyVector\u003cT, MyAlloc\u003cT\u003e\u003e;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"// usage\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"Vec\u003cint\u003e vec;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: \" \"\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"// in a class template\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"template \u003ctypename T\u003e\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"class Widget\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"{\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"  Vec\u003cT\u003e vec;\"\n            })\n          }), \"\\n\", _jsx(_components.span, {\n            \"data-line\": \"\",\n            children: _jsx(_components.span, {\n              children: \"};\"\n            })\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"能做到类似别名功能的，还有宏#define。但#define运行在编译前的宏处理阶段，对代码进行字符串替换。没有类型检查或其他编译、链接阶段才能进行的检查，不具备安全性。在C++11中不提倡使用#define。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"content":"\n## using的用法\n#### using与命名空间\n\n1. 引入整个命名空间中的成员\n   \n   不引入命名空间时，使用其中变量需要使用`\u003c命名空间名\u003e::\u003c变量名\u003e`的方式使用。\n   ```C++\n   using namespace foo;\n   ```\n   如此会将命名空间foo下所有的成员名称引入，可在直接以 `\u003c变量名\u003e` 的形式使用。但如此做有可能会使得命名空间foo中部分变量与当前定义的变量名冲突，违反命名空间隔离编译时名称冲突的初衷，因此不建议如此使用。\n\n2. 引入命名空间中的部分成员\n   \n   可通过仅引入命名空间中部分的成员，避免命名冲突。\n   ```C++\n   using foo::bar;\n   ```\n   这种方法仅会引入在语句中明确声明的名称。如using一个枚举类时，不会连其定义的枚举常量也一同引入。\n\n#### using与基类成员\n\n1. 子类中引入基类名称\n   \n   ```C++\n    class Base {\n    public:\n        std::size_t size() const { return n; }\n    protected:\n        std::size_t n;\n    };\n\n    class Derived : private Base {\n    public:\n        using Base::size;\n    protected:\n        using Base::n;\n    // ...\n    };\n    ```\n    例中子类private继承基类，由于private继承使得`Base::size`与`Base::n`可视性变为private。而使用`using Base::size`、`using Base::n`后，可分别使其变为public与protected。\n\n2. 子类成员函数与基类同名时保留基类函数用以重载\n   \n   ```C++\n    class Base\n    {\n    public:\n        int Func(){return 0;}\n    };\n    class Derived : Base\n    {\n    public:\n        using Base::Func;\n        int Func(int);\n    };\n    ```\n    子类中定义的成员函数与基类中重名时，即使函数原型不同，子类函数也会覆盖基类函数。\n    \n    如果基类中定义了一个函数的多个重载，而子类中又重写或重定义了其中某些版本，或是定义了一个新的重载，则基类中该函数的所有重载均被隐藏。\n\n    此时可以在子类中使用`using Base::Func`，令基类中所有重载版本在子类中可见，再重定义需要更改的版本。\n\n又如cppreference中的[例子](https://en.cppreference.com/w/cpp/language/using_declaration#In_class_definition)：\n```C++\n#include \u003ciostream\u003e\nstruct B {\n    virtual void f(int) { std::cout \u003c\u003c \"B::f\\n\"; }\n    void g(char)        { std::cout \u003c\u003c \"B::g\\n\"; }\n    void h(int)         { std::cout \u003c\u003c \"B::h\\n\"; }\nprotected:\n    int m; // B::m is protected\n    typedef int value_type;\n};\n\nstruct D : B {\n    using B::m; // D::m is public\n    using B::value_type; // D::value_type is public\n\n    using B::f;\n    void f(int) { std::cout \u003c\u003c \"D::f\\n\"; } // D::f(int) overrides B::f(int)\n    using B::g;\n    void g(int) { std::cout \u003c\u003c \"D::g\\n\"; } // both g(int) and g(char) are visible\n                                        // as members of D\n    using B::h;\n    void h(int) { std::cout \u003c\u003c \"D::h\\n\"; } // D::h(int) hides B::h(int)\n};\n\nint main()\n{\n    D d;\n    B\u0026 b = d;\n\n//    b.m = 2; // error, B::m is protected\n    d.m = 1; // protected B::m is accessible as public D::m\n    b.f(1); // calls derived f()\n    d.f(1); // calls derived f()\n    d.g(1); // calls derived g(int)\n    d.g('a'); // calls base g(char)\n    b.h(1); // calls base h()\n    d.h(1); // calls derived h()\n}\n```\n`using`语句可以改变基类成员的可访问性，也能在子类中重载(Overload)、重写(Override)基类的函数，或是通过重定义隐藏(Hide)对应的基类函数。\n\n\n#### using与别名\n\nusing在C++11开始，可用于别名的声明。用法如下：\n```C++\nusing UPtrMapSS = std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e;//普通别名\nusing FP = void (*) (int, const std::string\u0026);//函数指针别名\n\ntemplate \u003ctypename T\u003e\nusing Vec = MyVector\u003cT, MyAlloc\u003cT\u003e\u003e;//模板别名\nVec\u003cint\u003e vec;//模板别名的使用\n```\n\n## using关键字与typedef关键字定义别名的不同\n\n在STL容器或是其他泛型中若是再接受一个容器类型，类型名称就会写得很长。使用typedef或using定义别名会变得比较方便：\n```C++\ntypedef std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e UPtrMapSS;\n\nusing UPtrMapSS = std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e;\n```\n\n对于函数指针，使用using语句可以把函数原型与别名强制分到左右两边，比使用typedef易读得多：\n```C++\ntypedef void (*FP) (int, const std::string\u0026);\n\nusing FP = void (*) (int, const std::string\u0026);\n```\n\n---\n\n在C++中，若试图使用typedef定义一个模板：\n```C++\ntemplate \u003ctypename T\u003e\ntypedef MyVector\u003cT, MyAlloc\u003cT\u003e\u003e Vec;\n\n// usage\nVec\u003cint\u003e vec;\n```\n编译就会报错，提示：\n\u003e error: a typedef cannot be a template\n\n在一些STL中，通过如下方式包装一层来使用：\n```C++\ntemplate \u003ctypename T\u003e\nstruct Vec\n{\n  typedef MyVector\u003cT, MyAlloc\u003cT\u003e\u003e type;\n};\n\n// usage\nVec\u003cint\u003e::type vec;\n```\n\n如此显得十分不美观，且要是在模板类中或参数传递时使用typename强制这为类型，而不是其他如静态成员等语法：\n```C++\ntemplate \u003ctypename T\u003e\nclass Widget\n{\n  typename Vec\u003cT\u003e::type vec;\n};\n```\n\n而using关键字可定义模板别名，则一切都会显得十分自然：\n```C++\ntemplate \u003ctypename T\u003e\nusing Vec = MyVector\u003cT, MyAlloc\u003cT\u003e\u003e;\n\n// usage\nVec\u003cint\u003e vec;\n\n// in a class template\ntemplate \u003ctypename T\u003e\nclass Widget\n{\n  Vec\u003cT\u003e vec;\n};\n```\n\n---\n\n能做到类似别名功能的，还有宏#define。但#define运行在编译前的宏处理阶段，对代码进行字符串替换。没有类型检查或其他编译、链接阶段才能进行的检查，不具备安全性。在C++11中不提倡使用#define。\n\n\n\n   \n   ","title":"C++中using关键字的使用","abstract":"1. 引入整个命名空间中的成员\n   不引入命名空间时，使用其中变量需要使用`\u003c命名空间名\u003e::\u003c变量名\u003e`的方式使用。\n   ```C++","length":192,"created_at":"2020-01-28T18:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["C++","杂技"],"license":false},"prevNextInfo":{"prevInfo":{"pathMapping":{"filePath":"public/content/articles/2020-08-02-python-dict.md","pagePath":"/articles/python-dict","slug":"python-dict"},"meta":{"content":"\n\u003e CPython从3.6开始，字典（dict）不再是无序的了——字典的修改了原先的底层实现，变得能按字典插入的顺序进行遍历。而Python从3.7开始将字典的有序性写入语言特性，不管是Jython、IronPython还是其他Python实现，从3.7开始大家的字典都是有序的了。\n\n# 前言\n\n以前参加Python相关的面试时，面试官经常都会问一个问题：Python里的字典（dict）是有序的吗？\n\n这自然难不倒我，我也照本宣科地讲：Python的字典底层是用哈希表实现的，在不发生冲突时读写的时间复杂度是O（1），比读写时间复杂度为O（logn）的红黑树要更快。但红黑树可以按下标的大小顺序进行遍历，而Dict遍历时是无序的。\n\n我讲的时候没感觉到任何的违和感，估计面试官们也没觉得任何的不对。直到有一天，我查Python各个版本的新特性时，发现Python 3.6的What's New里有[这么一条](https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation)：\n\n\u003e New dict implementation\n\u003e \n\u003e The dict type now uses a “compact” representation based on a proposal by Raymond Hettinger which was first implemented by PyPy. The memory usage of the new dict() is between 20% and 25% smaller compared to Python 3.5.\n\u003e \n\u003e The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5).\n\n啥情况？CPython的dict竟然优化了内存，还变有序了！？\n\n# Python 3.5 以前dict的实现\n\n先不着急看Python 3.6 里的dict，我们先来看看Python 3.5之前的dict是怎么实现的，再拿3.6来做对比。\n\n在Python 3.5以前，dict是用Hash表来实现的，而且Key和Value直接储存在Hash表上。想通过Key获取Value，只需通过Python内部的Hash函数计算出Key对应的Hash值，再映射到Hash表上对应的地址，访问该地址即可获取Key对应的Value。如下图所示：\n\n我们知道，Hash表读写时间复杂度在不发生冲突的情况下都是O（1）。\n\n为什么呢？我们可以把Hash表读写的步骤分开来看：\n\n1. 首先用Hash函数计算key的Hash值，Hash函数一般来说时间复杂度都是O（1）的。\n2. 计算出Hash值后，映射到Hash表内的数组下标，一般用取余数或是取二进制后几位的方式实现，时间复杂度也是O（1）。\n3. 然后用数组下标读取数组中实际储存的键值，数组的下标读取时间复杂度也是O（1）。\n\n这三个步骤串起来后复杂度并没有提升，总的时间复杂度自然也是O（1）的。\n\n而内部储存空间，Python字典中称为entries。entries相当于一个数组，是一段连续的内存空间，每个位置储存一个（Hash值，指向Key的指针，指向Value的指针）三元组。\n\n当然，由于抽屉原理，我们知道Hash表不可避免的会出现Hash冲突，Python的dict也不例外。\n\n而解决Hash冲突的方法有很多，比如C++的unordered_map和Go的map就用链地址法来解决冲突，用链表储存发生冲突的值。而Java更进一步，当链表长度超过8时就转换成红黑树，将链表O（n）的查找复杂度降为O（logn）。C#的HashTable则是用再散列法，内部有多个Hash函数，一次冲突了就换一个函数再算，直到不冲突为止。\n\n而Python的dict则是利用开放寻址法。当插入数据发生冲突时，就会从那个位置往后找，直到找到有空位的地址为止。要查的时候，也是把下标值映射到到地址后，先对比一下下标值相不相等，若不相等则往后继续对比。\n\n这也造成个问题，dict中的元素不能直接从entries中清理掉，不然往后寻找的查找链就会断掉了。只能是先标记住删除，等到一定时机再一并清理。\n\n此外我们也知道，当冲突过发生得过多，dict读写所需的时间也会变多，时间复杂度不再是O(1)，这也是Hash表的通病了。\n\nPython中dict初始化时，内部储存空间entries容量为8。当内部储存空间占用到一定程度（entries容量×装填因子，Python的dict中装填因子是2/3）后，就会进行倍增扩容。每次扩容都要遍历原先的元素，时间复杂度为O(n)，但基本上插入O(n)次之后才会进行一次扩容，所以扩容的均摊时间复杂度为O(1)。而扩容时会重新进行Hash值到entries位置的映射，此时就是把标记删除但仍留在entries中的元素清理掉的最佳时机。\n\nPython3.5之前这种dict的实现就有两个毛病：\n\n1. 元素的顺序不被记录。两个Key值通过Hash函数的出来的Hash值不一定能保证原来的大小关系，由于Hash冲突、扩容等影响元素的顺序也会变化。当然这种无序性也是Hash表通用的特点了。\n2. 占用了太多了无用空间。上面说到entries中每个位置储存一个（Hash值，指向Key的指针，指向Value的指针）三元组，没用到或是标记删除的位置占用了大量的空间。\n\n于是，Raymond Hettinger就提出了一种新的dict实现方式。在CPython3.6中就使用了这种新的实现方式。\n\n# CPython3.6中dict的实现\n\n当要实现一个如下的dict时：\n\n```python\nd = {\n    'timmy': 'red', \n    'barry': 'green', \n    'guido': 'blue'\n}\n```\n\n如在上一节中所讲，在Python3.5以前，在内存储存的形式可以表示成这样子：\n\n```python\nentries = [['--', '--', '--'],\n           [-8522787127447073495, 'barry', 'green'],\n           ['--', '--', '--'],\n           ['--', '--', '--'],\n           ['--', '--', '--'],\n           [-9092791511155847987, 'timmy', 'red'],\n           ['--', '--', '--'],\n           [-6480567542315338377, 'guido', 'blue']]\n```\n\n而CPython3.6以后，是以这种形式储存在内存中的：\n\n```python\nindices =  [None, 1, None, None, None, 0, None, 2]\nentries =  [[-9092791511155847987, 'timmy', 'red'],\n            [-8522787127447073495, 'barry', 'green'],\n            [-6480567542315338377, 'guido', 'blue']]\n```\n\n改变了什么？\n\n1. dict内部的entries改为按插入顺序存储，新增了一个indices用于储存元素在entries中的下标。dict整体仍是Hash表结构，但Hash值映射到indices中，而不是直接映射到entries中。\n2. 由于entries改为了按插入顺序存储，使得申请entries容量时只要申请Hash表长度的2/3即可，省去了Hash表中的无用空间，储存更紧凑。\n3. dict读写步骤从原先的3步变为4步：计算key的Hash值，映射到indices内存空间，从indices读取entries的下标值，用下标从entries中读写数据。读写时间复杂度仍保持为O(1)，冲突、删除标记等Hash表的特性也仍然存在。indices的扩容策略也仍然是倍增扩容，但因为填充因子仍然为2/3，entries每次扩容时只需申请indices长度的2/3即可。\n\n有什么好处？\n\n1. 压缩空间：原先Hash映射是直接映射到entries上，会有大量的空隙。现在Hash映射到indices上，而entries中可更紧凑地存储元素。而indices中储存的entries下标占用内存可以比entries元素要小得多——当entries长度足够短时每个下标只需占一个字节。indices中确实也还仍有空隙，但占用空间总要比旧的dict实现要小得多了。\n2. 更快的遍历：以前的实现遍历dict要遍历整个Hash表，需要挨个位置读取一下，判断它是空闲位置还是实际存在的元素。而现在只需要对变得更紧凑的entries遍历就行了。这也带来一个新的特性：entries是按照元素插入的顺序存储的，遍历entries自然也会按元素插入的顺序输出。这就给dict带来了有序性。\n3. 扩容时关注的内存块更少。原先的entries扩容时所有数据都要重新映射到内存上，cache利用率不好。现在扩容时基本可以整个entries直接复制（当然，有删除标记的数据这时要忽略）。\n\n综上，CPython3.6以后通过增加了一个indices增加了空间利用率，在维持读写时间复杂度不变的情况下增加了遍历与扩容效率。至于dict遍历变得有序，倒是有点次要的特性了。\n\n# 我们是否应利用新dict的有序性？\n\n既然Python中dict变得有序了，那我们是否应该主动去利用它呢？我是这么认为的：\n\n1. 在Python3.6中，我们不推荐利用dict的有序性。3.6时dict的有序性还只是CPython的一个实现细节，并不是Python的语言特性。当我们的代码不是在CPython环境下运行，dict的有序性就不起作用，就容易出莫名其妙的BUG了。\n2. 在Python3.7后，dict按插入顺序进行遍历的性质被写入Python语言特性中。这时确实在代码中利用dict有序性也没什么大问题。但dict这种数据结构，最主要的特性还是表现在Key映射到Value的这种关系，以及O(1)的读写时间复杂度。当我们的代码中需要关注到dict的遍历顺序时，我们就要先质问一下自己：是否应该改为用队列或是其他数据结构来实现？\n\n\n# 参考文献\n\n- [Are dictionaries ordered in Python 3.6+?](https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6)\n- [[Python-Dev] Python 3.6 dict becomes compact and gets a private version; and keywords become ordered](https://mail.python.org/pipermail/python-dev/2016-September/146327.html)\n- [[Python-Dev] More compact dictionaries with faster iteration](https://mail.python.org/pipermail/python-dev/2012-December/123028.html)\n- [关于python3.6中dict如何保证有序](https://zhuanlan.zhihu.com/p/36167600)\n- [python3.7源码分析－字典_小屋子大侠的博客-CSDN博客_python 字典源码](https://blog.csdn.net/qq_33339479/article/details/90446988)\n- [《深度剖析CPython解释器》9. 解密Python中字典和集合的底层实现，深度分析哈希表](https://www.cnblogs.com/traditional/p/13503114.html)\n- [CPython 源码阅读 - dict](http://blog.dreamfever.me/2018/03/12/cpython-yuan-ma-yue-du-dict/)","title":"Python字典的实现原理","abstract":"\u003e CPython从3.6开始，字典（dict）不再是无序的了——字典的修改了原先的底层实现，变得能按字典插入的顺序进行遍历。而Python从3.7开始将字典的有序性写入语言特性，不管是Jython、IronPython还是其他Python实现，从3.7开始大家的字典都是有序的了。\n以前参加Python相关的面试时，面试官经常都会问一个问题：Python里的字典（dict）是有序的吗？\n这自然难不倒我，我也照本宣科地讲：Python的字典底层是用哈希表实现的，在不发生冲突时读写的时间复杂度是O（1），比读写时间复杂度为O（logn）的红黑树要更快。但红黑树可以按下标的大小顺序进行遍历，而Dict遍历时是无序的。","length":121,"created_at":"2020-08-02T00:10:10.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["Python","数据结构"],"license":false}},"nextInfo":{"pathMapping":{"filePath":"public/content/articles/2020-01-27-Building-this-blog.md","pagePath":"/articles/Building-this-blog","slug":"Building-this-blog"},"meta":{"content":"\n\u003e “Stop Trying to Reinvent the Wheel.”\n\n## 博客构建\n\n\n#### 把仓库clone到本地\n\n参考[BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]，先将[Huxpro][Huxpro]提供的[博客模板仓库][origin_repo]fork出来，`git clone`到本地。\n\n整个网站文件夹大致结构如下：\n\n```\n├── _config.yml\n|\n├── _posts/\n|   ├── 2007-10-29-awsome-file-name.md\n|   └── 2009-04-26-stupid-file-name.md\n├── img/\n|   ├── in-post/\n|   ├── awsome-bg.jpg\n|   ├── avatar-ryo.png\n|   ├── favicon.ico\n|   └── icon_wechat.jpg\n├── other_awsome_directory/\n|   └── awsomefiles\n|\n|\n├── 404.html\n├── about.html\n├── index.html\n└── other_awsome_files\n```\n\n博客的文章上传到`_posts`文件夹中，网站中用到的图片上传到`img`文件夹中，网站的全局设置在`_config.yml`中进行。\n\n\n\n#### 修改**_config.yml**文件\n\n修改根目录下的`_config.yml`文件，将其中的内容更改为自己的信息。\n\n```yml\n# Site settings\ntitle: Ryo's Blog\nSEOTitle: 阿亮仔的博客 | 亮のブログ | Ryo's Blog\nheader-img: img/home-bg.jpg\nemail: qq250707340@163.com\ndescription: \"君の夢が　叶うのは　誰かのおかげじゃないぜ。\"\nkeyword: \"Ryo, Blog, 阿亮仔, りょう, 博客, ブログ, Algorithm, Unity, Python, C-Sharp\"\nurl: \"http://RyoJerryYu.github.io\"              # your host, for absolute URL\nbaseurl: \"\"         # for example, '/blog' if your blog hosted on 'host/blog'\ngithub_repo: \"https://github.com/RyoJerryYu/RyoJerryYu.github.io.git\" # you code repository\n```\n- `SEOTitle`: `\u003ctitle\u003e`标签，即显示在浏览器标题中的文字。\n- `header-img`: 首页显示的图像，可以把路径更改为自己的图片。\n- `description`: `\u003cmeta name=\"description\"\u003e`中的内容。\n- `keyword`: `\u003cmeta name=\"keyword\"\u003e`中的内容。\n- `url`, `baseurl`: 分别为博客域名地址与其下路径。如不想将博客直接架在根路径下，需要对`baseurl`进行设置。\n- `github_repo`: 博客所在的GitHub仓库。\n\n---\n\n\n```yml\n# SNS settings\nRSS: false\n# weibo_username:     huxpro\n# zhihu_username:     huxpro\ngithub_username:    RyoJerryYu\ntwitter_username:  ryo_okami\n# facebook_username:  huxpro\n```\n分别为各个社交网站上的账号信息，以供在侧边栏中直接跳转到对应的页面。可通过在行首添加或删除`#`进行注释或取消注释。\n\n从[原仓库][origin_repo]中直接fork出来时，社交网站的图标可能会有[无法显示的问题](https://github.com/Huxpro/huxblog-boilerplate/issues/17)，其解决方法在[后面](#FixSNS)介绍。\n\n---\n\n\n```yml\n# Disqus settings\n#disqus_username: _your_disqus_short_name_\n\n# Duoshuo settings\n# duoshuo_username: huxblog\n# Share component is depend on Comment so we can NOT use share only.\n# duoshuo_share: true                     # set to false if you want to use Comment without Sharing\n\n# Gitalk\ngitalk:\n    enable: false    #是否开启Gitalk评论\n    clientID: f2c84e7629bb1446c1a4                            #生成的clientID\n    clientSecret: ca6d6139d1e1b8c43f8b2e19492ddcac8b322d0d    #生成的clientSecret\n    repo: qiubaiying.github.io    #仓库名称\n    owner: qiubaiying    #github用户名\n    admin: qiubaiying\n    distractionFreeMode: true #是否启用类似FB的阴影遮罩  \n```\n分别为各种评论系统。均未开启。\n\n---\n\n\n```yml\n# Analytics settings\n# Baidu Analytics\n# ba_track_id: 4cc1f2d8f3067386cc5cdb626a202900\n# Google Analytics\nga_track_id: 'UA-156933256-1'            # Format: UA-xxxxxx-xx\nga_domain: auto\n```\n分别为百度与谷歌的网站统计。我只启用了Google Analytics。可先到[Google Marketing Platform](https://marketingplatform.google.com/about/)注册，开启Google Analytics。在`设置`-\u003e`媒体资源设置`中获得Track ID，并填入`ga_track_id`中。\n\n---\n\n\n```yml\n# Sidebar settings\nsidebar: true                           # whether or not using Sidebar.\nsidebar-about-description: \"记录平时遇到的问题，以及对应的解决方法。偶尔上传些许宅活或是娱乐方面的记录。\"\nsidebar-avatar: /img/avatar-ryo.png      # use absolute URL, seeing it's used in both `/` and `/about/`\n```\n`sidebar`: 是否开启侧边栏，为`true`或`false`。\n`sidebar-about-description`: 显示在侧边栏中的个人简介。\n`sidebar-avatar`: 显示在侧边栏中的头像。\n\n---\n\n\n```yml\n# Featured Tags\nfeatured-tags: true                     # whether or not using Feature-Tags\nfeatured-condition-size: 2              # A tag will be featured if the size of it is more than this condition value\n```\n是否开启tag功能，以及最少要达到多少篇文章才能使tag显示在首页上。\n\n\n\n#### 修改主页等信息\n\n修改`index.html`、`404.html`、`about.html`、`tags.html`等文件，将其中的内容更改为自己的信息。\n\n- 在`index`中，修改`description`对应的内容，亦即主页中标题下方的描述。\n- 在`404`、`tags`、`about`中，修改`description`的内容，亦即404页面中的描述信息。如有需要，也可以修改`header-img`，即404页面的图片地址。\n- 在`about`中，还有修改自我介绍对应的内容。\n\n\n\n#### 修改图片信息\n\n修改`img/`下的图片，替换为自己的图片。要记得替换以下图片：\n- `avatar-ryo.png`\n- `favicon.ico`\n- `icon_wechat.png`\n\n\n\n#### 修改README.md\n\nREADME.md为Github仓库的介绍，可以在README.md中写上这个博客主要的内容，让别人了解这个博客。\n\n\n\n#### 完成\n\n将`_posts`中的博文全部删除后，将本地文件全部push到GitHub仓库中。稍等后用浏览器浏览`\u003c用户名\u003e.github.io`（或是你在`_config.yml`中设定的路径）。若发现网页已更新，即博客搭建成功，可以开始写博文了。\n\n*然而，并没有成功。*\n\n\n\n## Fix Bug\n\n\u003cp id = \"FixReadmeCh\"\u003e\u003c/p\u003e\n\n#### 修复README.zh.md引发的错误\n\n按上述步骤搭建完毕后，网页并没有正常显示。此时GitHub账号所关联的邮箱中收到标题为**Page build failure**的邮件，内容如下：\n\u003e The page build failed for the `master` branch with the following error:\n\u003e The tag `if` on line 235 in `README.zh.md` was not properly closed.\n\n如[原仓库][origin_repo]中的[issue#11](https://github.com/Huxpro/huxblog-boilerplate/issues/11)所示，在`README.zh.md`中存在`if`语句，会触发错误。\n\n因并无其他特别的需求，此处采用暴力删除`README.zh.md`的方法解决。\n\n对应commit：[删除README.zh.md，尝试修复因...](https://github.com/RyoJerryYu/RyoJerryYu.GitHub.io/commit/098d710160775df9b6d2cf04d7d4eec526a67bf4)\n\n\n\u003cp id = \"FixSNS\"\u003e\u003c/p\u003e\n\n#### 修复SNS链接不正常显示\n\n修复上述错误后，稍等即可正常打开网页。但是，我们在`_config.yml`中设置好的SNS链接并没有在侧边栏以及网页底部正常显示。如原仓库中的[issue#17](https://github.com/Huxpro/huxblog-boilerplate/issues/17)所示，原因是gitpage必须通过https访问bootcss.com等的cdn。\n\n此处采用原仓库[pull request#21](https://github.com/Huxpro/huxblog-boilerplate/pull/21)的方法，修改`_includes/head.html`, `_includes/footer.html`, `_layouts/keynote.html`, `_layouts/post.html`文件，将其中`http`修改为`https`。\n\n对应commit：[fix: change http into https](https://github.com/RyoJerryYu/RyoJerryYu.GitHub.io/commit/ec954c380472f30f09efdfadd074cb7967c2fa11)\n\n\n\n## 上传文章\n\n文章主要放在_posts文件夹中，用`git push`的方式推送到GitHub仓库，即可完成文章上传。\n\n文章正文以**markdown**语法书写，在文本头部增加如下格式的信息：\n\n```yaml\n---\nlayout:     post\ntitle:      \"Welcome to Ryo's Blog!\"\nsubtitle:   \" \\\"Hello World, Hello Blog\\\"\"\ndate:       2020-01-27 12:00:00\nauthor:     \"Ryo\"\nheader-img: \"img/post-bg-default.jpg\"\ntags:\n    - 杂技\n    - 杂谈\n---\n```\n\n其中：\n- `layout`为文章所用的模板，可选`post`或`keynote`，也可自己写一个模板html放在`_layouts`文件夹下。\n- `title`为文章标题，`subtitle`为文章副标题。\n- `date`为博客中显示的文章发表时间。\n- `author`为博客中显示的作者。\n- `header-img`为文章顶部显示的封面。\n- `tags`为文章的标签，我们的博客网站可以通过标签来快速寻找文章。\n\n把文章的文件名命名为时间+标题的形式，后缀名使用markdown文本的通用后缀名`md`，如`2020-01-27-hello-world.md`。完成后将此文本文件放到`_posts/`文件夹下。文章中使用到的图片建议放到`img/in-post/`文件夹下。\n\n完成后，使用`git push`推送到GitHub仓库，稍等后刷新博客网页即可看见刚才上传的文章。文章的url一般为：`\u003c博客地址\u003e/\u003c文章文件名中的年\u003e/\u003c月\u003e/\u003c日\u003e/\u003c文件名中剩余部分\u003e`。\n\n\n\n\n## 祝你开始愉快的博客生活。\n\n\n#### 感谢\n\n- [Huxpro][Huxpro]提供的博客模板：[huxblog-boilerplate][origin_repo]\n- [BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]\n- [Luo Yifan（罗一凡）](https://github.com/iVanlIsh)提供的Bug解决方案。\n\n\n\n\n[Huxpro]: https://github.com/huxpro\n[BruceZhao]: https://github.com/BruceZhaoR\n[origin_repo]: https://github.com/Huxpro/huxblog-boilerplate\n[READMEzh]: https://github.com/Huxpro/huxpro.github.io/blob/master/README.zh.md","title":"搭建博客的过程","abstract":"\u003e “Stop Trying to Reinvent the Wheel.”\n参考[BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]，先将[Huxpro][Huxpro]提供的[博客模板仓库][origin_repo]fork出来，`git clone`到本地。\n整个网站文件夹大致结构如下：","length":252,"created_at":"2020-01-27T14:00:00.000Z","updated_at":"2024-04-16T13:30:33.000Z","tags":["杂技","Blog"],"license":false}}}},"__N_SSG":true},"page":"/articles/[slug]","query":{"slug":"the-using-in-cpp"},"buildId":"cMm9PNrybYEKe5evC86tr","assetPrefix":"/blog-next","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>