<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta property="og:image" content="https://ryojerryyu.github.io/blog-next/img/home-bg-kasumi-hanabi.jpg"/><meta name="twitter:image" content="https://ryojerryyu.github.io/blog-next/img/home-bg-kasumi-hanabi.jpg"/><meta property="og:type" content="website"/><meta property="og:url" content="https://ryojerryyu.github.io/blog-next/articles/The-beauty-of-design-parten"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@ryo_okami"/><meta name="twitter:creator" content="@ryo_okami"/><link rel="icon" href="/blog-next/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"/><title>设计模式之美读书笔记 | Ryo&#x27;s Blog</title><meta property="og:title" content="设计模式之美读书笔记"/><meta property="og:site_name" content="Ryo&#x27;s Blog"/><meta name="twitter:title" content="设计模式之美读书笔记 | Ryo&#x27;s Blog"/><meta name="description" content="从7个方面评价代码的好坏：
1. 易维护性：根本
2. 可读性：最重要"/><meta property="og:description" content="从7个方面评价代码的好坏：
1. 易维护性：根本
2. 可读性：最重要"/><meta name="twitter:description" content="从7个方面评价代码的好坏：
1. 易维护性：根本
2. 可读性：最重要"/><meta name="next-head-count" content="18"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog-next/_next/static/css/96f136a961b61ffd.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/96f136a961b61ffd.css" data-n-g=""/><link rel="preload" href="/blog-next/_next/static/css/893da10930f390cb.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/893da10930f390cb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog-next/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog-next/_next/static/chunks/webpack-60a2ec5432ad43a2.js" defer=""></script><script src="/blog-next/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/blog-next/_next/static/chunks/main-5a633d052902c7b6.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/_app-461e07b5fa8ad4a5.js" defer=""></script><script src="/blog-next/_next/static/chunks/780-59b28454be6ff9a9.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/articles/%5Bslug%5D-1095b66ac1814e36.js" defer=""></script><script src="/blog-next/_next/static/H3oMjkRa-Nc_Ut5b3P8Ah/_buildManifest.js" defer=""></script><script src="/blog-next/_next/static/H3oMjkRa-Nc_Ut5b3P8Ah/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="DefaultLayout_header__XE11y"><div class="DefaultLayout_icon__nrf7l"><div class="DefaultLayout_textbox__7Wb4y"><a class="DefaultLayout_textlink__6A_gH" href="/blog-next">Ryo&#x27;s Blog</a></div></div><div class="DefaultLayout_navBar___k_JM"><div class="DefaultLayout_navBarItem__YPtK6"><a class="DefaultLayout_textlink__6A_gH" href="/blog-next/articles">Articles</a></div><div class="DefaultLayout_navBarItem__YPtK6"><a class="DefaultLayout_textlink__6A_gH" href="/blog-next/ideas">Ideas</a></div><div class="DefaultLayout_navBarItem__YPtK6"><a class="DefaultLayout_textlink__6A_gH" href="/blog-next/tags">Tags</a></div></div><div class="DefaultLayout_headerRight__DHBsQ"><div class="DefaultLayout_textbox__7Wb4y"><a class="DefaultLayout_textlink__6A_gH" href="/blog-next/about">About Me</a></div></div></header><div class="DefaultLayout_headerBg__ADsuB"></div><div class="DefaultLayout_contentHeight__WU8Ci"><article class="Post_post__2Nkl_"><h1 class="Post_postTitle__obESR">设计模式之美读书笔记</h1><time class="Post_postDate__g2i8j" dateTime="2021-08-21T08:53:27.000Z">2021-08-21</time><div class="TagsBox_tagsBox__Z0lIP mt-2"><a href="/blog-next/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><div class="TagsBox_tag__PAgNP">设计模式</div></a><a href="/blog-next/tags/%E7%AC%94%E8%AE%B0"><div class="TagsBox_tag__PAgNP">笔记</div></a></div><div class="post-body"><h1 id="导读"><a href="#导读">导读</a></h1>
<h2 id="02如何评价代码好坏"><a href="#02如何评价代码好坏">02：如何评价代码好坏？</a></h2>
<p>从7个方面评价代码的好坏：</p>
<ol>
<li>易维护性：根本</li>
<li>可读性：最重要</li>
<li>易扩展性：对修改关闭，对扩展开放</li>
<li>灵活性</li>
<li>简洁性：KISS</li>
<li>可复用性：DRY</li>
<li>可测试性：TDD，单元测试，控制反转与依赖注入</li>
</ol>
<h2 id="03编程方法论"><a href="#03编程方法论">03：编程方法论</a></h2>
<p>设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：</p>
<ol>
<li>面向对象：封装，抽象，继承，多态</li>
<li>设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD</li>
<li>设计模式</li>
<li>编程规范：可读性，命名规范</li>
<li>重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模</li>
</ol>
<p>整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。</p>
<h1 id="面向对象"><a href="#面向对象">面向对象</a></h1>
<p>使用封装，抽象，继承，多态，作为代码设计和实现的基石。</p>
<ol>
<li>面向对象分析（做什么），设计（怎么做），编程</li>
</ol>
<h2 id="05封装抽象继承多态"><a href="#05封装抽象继承多态">05：封装，抽象，继承，多态</a></h2>
<table><thead><tr><th></th><th>是什么</th><th>怎么做</th><th>为什么</th></tr></thead><tbody><tr><td>封装</td><td>信息隐藏、数据访问保护</td><td>访问控制关键字</td><td>减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性</td></tr><tr><td>抽象</td><td>隐藏实现方法</td><td>函数、接口类、抽象类</td><td>提高可扩展性与维护性、过滤非必要信息</td></tr><tr><td>继承</td><td>is-a关系</td><td>继承机制</td><td>代码复用、反映真实世界关系</td></tr><tr><td>多态</td><td>子类替代父类</td><td>继承、接口类、鸭子类型</td><td>提高扩展性与复用性</td></tr></tbody></table>
<ul>
<li>继承不应过度使用，会导致层次过深，导致低可读性与低可维护性</li>
<li>在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。</li>
<li>有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。</li>
</ul>
<h2 id="0607面向过程与面向对象"><a href="#0607面向过程与面向对象">06，07：面向过程与面向对象</a></h2>
<ol>
<li>面向过程是：数据与方法分离</li>
<li>面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；</li>
<li>看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；</li>
<li>为什么容易面向过程：略</li>
<li>面向过程的用处：略</li>
</ol>
<h2 id="08接口与抽象类"><a href="#08接口与抽象类">08：接口与抽象类</a></h2>
<ol>
<li>接口类与抽象类语法特性：略</li>
<li>抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。</li>
<li>应用场景区别：<!-- -->
<ul>
<li>抽象类：代表is-a关系，解决代码复用问题</li>
<li>接口类：解决抽象、解耦问题</li>
</ul>
</li>
</ol></div><div class="TagsBox_tagsBox__Z0lIP mt-4"><a href="/blog-next/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><div class="TagsBox_tag__PAgNP">设计模式</div></a><a href="/blog-next/tags/%E7%AC%94%E8%AE%B0"><div class="TagsBox_tag__PAgNP">笔记</div></a></div></article></div><footer class="DefaultLayout_footer__otgnc"><div class="max-w-2xl mx-auto p-2 w-full"><div class="flex flex-row justify-center items-center"><div class="DefaultLayout_footerLeft__pCizs">© 2023 Ryo Jerry Yu. All rights reserved.</div><div class="DefaultLayout_footerRight__VOEtk"><a title="Twitter" href="https://twitter.com/ryo_okami"><svg class="h-8 w-8 fill-slate-100" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a title="GitHub" href="https://github.com/RyoJerryYu"><svg class="h-8 w-8 fill-slate-100" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"The-beauty-of-design-parten","tags":[{"tag":"设计模式","slug":"设计模式","path":"/tags/设计模式","postSlugs":[{"postSlug":"The-beauty-of-design-parten","postType":"article"}]},{"tag":"笔记","slug":"笔记","path":"/tags/笔记","postSlugs":[{"postSlug":"The-beauty-of-design-parten","postType":"article"}]}],"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    a: \"a\",\n    h2: \"h2\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      id: \"导读\",\n      children: _jsx(_components.a, {\n        href: \"#导读\",\n        children: \"导读\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"02如何评价代码好坏\",\n      children: _jsx(_components.a, {\n        href: \"#02如何评价代码好坏\",\n        children: \"02：如何评价代码好坏？\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从7个方面评价代码的好坏：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"易维护性：根本\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可读性：最重要\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"易扩展性：对修改关闭，对扩展开放\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"灵活性\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"简洁性：KISS\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可复用性：DRY\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可测试性：TDD，单元测试，控制反转与依赖注入\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"03编程方法论\",\n      children: _jsx(_components.a, {\n        href: \"#03编程方法论\",\n        children: \"03：编程方法论\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向对象：封装，抽象，继承，多态\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"设计模式\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"编程规范：可读性，命名规范\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。\"\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"面向对象\",\n      children: _jsx(_components.a, {\n        href: \"#面向对象\",\n        children: \"面向对象\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用封装，抽象，继承，多态，作为代码设计和实现的基石。\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向对象分析（做什么），设计（怎么做），编程\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"05封装抽象继承多态\",\n      children: _jsx(_components.a, {\n        href: \"#05封装抽象继承多态\",\n        children: \"05：封装，抽象，继承，多态\"\n      })\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {}), _jsx(_components.th, {\n            children: \"是什么\"\n          }), _jsx(_components.th, {\n            children: \"怎么做\"\n          }), _jsx(_components.th, {\n            children: \"为什么\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"封装\"\n          }), _jsx(_components.td, {\n            children: \"信息隐藏、数据访问保护\"\n          }), _jsx(_components.td, {\n            children: \"访问控制关键字\"\n          }), _jsx(_components.td, {\n            children: \"减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"抽象\"\n          }), _jsx(_components.td, {\n            children: \"隐藏实现方法\"\n          }), _jsx(_components.td, {\n            children: \"函数、接口类、抽象类\"\n          }), _jsx(_components.td, {\n            children: \"提高可扩展性与维护性、过滤非必要信息\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"继承\"\n          }), _jsx(_components.td, {\n            children: \"is-a关系\"\n          }), _jsx(_components.td, {\n            children: \"继承机制\"\n          }), _jsx(_components.td, {\n            children: \"代码复用、反映真实世界关系\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"多态\"\n          }), _jsx(_components.td, {\n            children: \"子类替代父类\"\n          }), _jsx(_components.td, {\n            children: \"继承、接口类、鸭子类型\"\n          }), _jsx(_components.td, {\n            children: \"提高扩展性与复用性\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"继承不应过度使用，会导致层次过深，导致低可读性与低可维护性\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"0607面向过程与面向对象\",\n      children: _jsx(_components.a, {\n        href: \"#0607面向过程与面向对象\",\n        children: \"06，07：面向过程与面向对象\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向过程是：数据与方法分离\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"为什么容易面向过程：略\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"面向过程的用处：略\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"08接口与抽象类\",\n      children: _jsx(_components.a, {\n        href: \"#08接口与抽象类\",\n        children: \"08：接口与抽象类\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"接口类与抽象类语法特性：略\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"应用场景区别：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"抽象类：代表is-a关系，解决代码复用问题\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"接口类：解决抽象、解耦问题\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"content":"\n# 导读\n\n## 02：如何评价代码好坏？\n\n从7个方面评价代码的好坏：\n\n1. 易维护性：根本\n2. 可读性：最重要\n3. 易扩展性：对修改关闭，对扩展开放\n4. 灵活性\n5. 简洁性：KISS\n6. 可复用性：DRY\n7. 可测试性：TDD，单元测试，控制反转与依赖注入\n\n## 03：编程方法论\n\n设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：\n\n1. 面向对象：封装，抽象，继承，多态\n2. 设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD\n3. 设计模式\n4. 编程规范：可读性，命名规范\n5. 重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模\n\n整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。\n\n\n# 面向对象\n\n使用封装，抽象，继承，多态，作为代码设计和实现的基石。\n\n1. 面向对象分析（做什么），设计（怎么做），编程\n\n## 05：封装，抽象，继承，多态\n\n|      | 是什么                 | 怎么做                 | 为什么                                                         |\n| ---- | ---------------------- | ---------------------- | -------------------------------------------------------------- |\n| 封装 | 信息隐藏、数据访问保护 | 访问控制关键字         | 减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性 |\n| 抽象 | 隐藏实现方法           | 函数、接口类、抽象类   | 提高可扩展性与维护性、过滤非必要信息                           |\n| 继承 | is-a关系               | 继承机制               | 代码复用、反映真实世界关系                                     |\n| 多态 | 子类替代父类           | 继承、接口类、鸭子类型 | 提高扩展性与复用性                                             |\n\n- 继承不应过度使用，会导致层次过深，导致低可读性与低可维护性\n- 在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。\n- 有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。\n\n## 06，07：面向过程与面向对象\n\n1. 面向过程是：数据与方法分离\n2. 面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；\n3. 看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；\n4. 为什么容易面向过程：略\n5. 面向过程的用处：略\n\n## 08：接口与抽象类\n\n1. 接口类与抽象类语法特性：略\n2. 抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。\n3. 应用场景区别：\n    - 抽象类：代表is-a关系，解决代码复用问题\n    - 接口类：解决抽象、解耦问题","title":"设计模式之美读书笔记","abstract":"从7个方面评价代码的好坏：\n1. 易维护性：根本\n2. 可读性：最重要","length":62,"created_at":"2021-08-21T08:53:27.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["设计模式","笔记"],"license":false}},"__N_SSG":true},"page":"/articles/[slug]","query":{"slug":"The-beauty-of-design-parten"},"buildId":"H3oMjkRa-Nc_Ut5b3P8Ah","assetPrefix":"/blog-next","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>