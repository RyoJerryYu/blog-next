<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Ryo Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Ryo&#x27;s blog, build with next.js"/><link rel="icon" href="/img/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog-next/_next/static/css/4f63dc54d238fe21.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/4f63dc54d238fe21.css" data-n-g=""/><link rel="preload" href="/blog-next/_next/static/css/3fc7adbdd33c0c60.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/3fc7adbdd33c0c60.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog-next/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog-next/_next/static/chunks/webpack-60a2ec5432ad43a2.js" defer=""></script><script src="/blog-next/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/blog-next/_next/static/chunks/main-5a633d052902c7b6.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/_app-ebfbab9e37daa1a2.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/posts/%5Bslug%5D-585c5863d2707379.js" defer=""></script><script src="/blog-next/_next/static/bHGAjcc8nV7lZR9cO6BC0/_buildManifest.js" defer=""></script><script src="/blog-next/_next/static/bHGAjcc8nV7lZR9cO6BC0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="style_header__sRoTf"><div class="style_icon__jxr5_"><div class="style_textbox__uLqJ9"><a class="style_textlink__526pR" href="/blog-next">Ryo&#x27;s Blog</a></div></div><div class="style_navBar__9GT_e"><div class="style_navBarItem__2VL_G"><a class="style_textlink__526pR" href="/blog-next/posts">Posts</a></div><div class="style_navBarItem__2VL_G"><a class="style_textlink__526pR" href="/blog-next/tags/1">Tags</a></div></div><div class="style_headerRight__G5ePS"><div class="style_textbox__uLqJ9"><a class="style_textlink__526pR" href="/blog-next/about">About Me</a></div></div></div><div class="style_headerBg__yAoHx"></div><article class="Post_post__2Nkl_"><h1 class="Post_postTitle__obESR">设计模式之美读书笔记</h1><time class="Post_postDate__g2i8j" dateTime="2021-08-21T08:53:27.000Z">2021-08-21</time><div class="TagsBox_tagsBox__Z0lIP mt-2"><a href="/blog-next/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="TagsBox_tag__PAgNP">设计模式</span></a><a href="/blog-next/tag/%E7%AC%94%E8%AE%B0"><span class="TagsBox_tag__PAgNP">笔记</span></a></div><div class="post-body"><h1 id="导读"><a href="#导读">导读</a></h1>
<h2 id="02如何评价代码好坏"><a href="#02如何评价代码好坏">02：如何评价代码好坏？</a></h2>
<p>从7个方面评价代码的好坏：</p>
<ol>
<li>易维护性：根本</li>
<li>可读性：最重要</li>
<li>易扩展性：对修改关闭，对扩展开放</li>
<li>灵活性</li>
<li>简洁性：KISS</li>
<li>可复用性：DRY</li>
<li>可测试性：TDD，单元测试，控制反转与依赖注入</li>
</ol>
<h2 id="03编程方法论"><a href="#03编程方法论">03：编程方法论</a></h2>
<p>设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：</p>
<ol>
<li>面向对象：封装，抽象，继承，多态</li>
<li>设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD</li>
<li>设计模式</li>
<li>编程规范：可读性，命名规范</li>
<li>重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模</li>
</ol>
<p>整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。</p>
<h1 id="面向对象"><a href="#面向对象">面向对象</a></h1>
<p>使用封装，抽象，继承，多态，作为代码设计和实现的基石。</p>
<ol>
<li>面向对象分析（做什么），设计（怎么做），编程</li>
</ol>
<h2 id="05封装抽象继承多态"><a href="#05封装抽象继承多态">05：封装，抽象，继承，多态</a></h2>
<table><thead><tr><th></th><th>是什么</th><th>怎么做</th><th>为什么</th></tr></thead><tbody><tr><td>封装</td><td>信息隐藏、数据访问保护</td><td>访问控制关键字</td><td>减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性</td></tr><tr><td>抽象</td><td>隐藏实现方法</td><td>函数、接口类、抽象类</td><td>提高可扩展性与维护性、过滤非必要信息</td></tr><tr><td>继承</td><td>is-a关系</td><td>继承机制</td><td>代码复用、反映真实世界关系</td></tr><tr><td>多态</td><td>子类替代父类</td><td>继承、接口类、鸭子类型</td><td>提高扩展性与复用性</td></tr></tbody></table>
<ul>
<li>继承不应过度使用，会导致层次过深，导致低可读性与低可维护性</li>
<li>在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。</li>
<li>有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。</li>
</ul>
<h2 id="0607面向过程与面向对象"><a href="#0607面向过程与面向对象">06，07：面向过程与面向对象</a></h2>
<ol>
<li>面向过程是：数据与方法分离</li>
<li>面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；</li>
<li>看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；</li>
<li>为什么容易面向过程：略</li>
<li>面向过程的用处：略</li>
</ol>
<h2 id="08接口与抽象类"><a href="#08接口与抽象类">08：接口与抽象类</a></h2>
<ol>
<li>接口类与抽象类语法特性：略</li>
<li>抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。</li>
<li>应用场景区别：<!-- -->
<ul>
<li>抽象类：代表is-a关系，解决代码复用问题</li>
<li>接口类：解决抽象、解耦问题</li>
</ul>
</li>
</ol></div><div class="TagsBox_tagsBox__Z0lIP mt-4"><a href="/blog-next/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="TagsBox_tag__PAgNP">设计模式</span></a><a href="/blog-next/tag/%E7%AC%94%E8%AE%B0"><span class="TagsBox_tag__PAgNP">笔记</span></a></div></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"The-beauty-of-design-parten","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    a: \"a\",\n    h2: \"h2\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      id: \"导读\",\n      children: _jsx(_components.a, {\n        href: \"#导读\",\n        children: \"导读\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"02如何评价代码好坏\",\n      children: _jsx(_components.a, {\n        href: \"#02如何评价代码好坏\",\n        children: \"02：如何评价代码好坏？\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从7个方面评价代码的好坏：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"易维护性：根本\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可读性：最重要\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"易扩展性：对修改关闭，对扩展开放\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"灵活性\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"简洁性：KISS\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可复用性：DRY\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可测试性：TDD，单元测试，控制反转与依赖注入\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"03编程方法论\",\n      children: _jsx(_components.a, {\n        href: \"#03编程方法论\",\n        children: \"03：编程方法论\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向对象：封装，抽象，继承，多态\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"设计模式\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"编程规范：可读性，命名规范\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。\"\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"面向对象\",\n      children: _jsx(_components.a, {\n        href: \"#面向对象\",\n        children: \"面向对象\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用封装，抽象，继承，多态，作为代码设计和实现的基石。\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向对象分析（做什么），设计（怎么做），编程\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"05封装抽象继承多态\",\n      children: _jsx(_components.a, {\n        href: \"#05封装抽象继承多态\",\n        children: \"05：封装，抽象，继承，多态\"\n      })\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {}), _jsx(_components.th, {\n            children: \"是什么\"\n          }), _jsx(_components.th, {\n            children: \"怎么做\"\n          }), _jsx(_components.th, {\n            children: \"为什么\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"封装\"\n          }), _jsx(_components.td, {\n            children: \"信息隐藏、数据访问保护\"\n          }), _jsx(_components.td, {\n            children: \"访问控制关键字\"\n          }), _jsx(_components.td, {\n            children: \"减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"抽象\"\n          }), _jsx(_components.td, {\n            children: \"隐藏实现方法\"\n          }), _jsx(_components.td, {\n            children: \"函数、接口类、抽象类\"\n          }), _jsx(_components.td, {\n            children: \"提高可扩展性与维护性、过滤非必要信息\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"继承\"\n          }), _jsx(_components.td, {\n            children: \"is-a关系\"\n          }), _jsx(_components.td, {\n            children: \"继承机制\"\n          }), _jsx(_components.td, {\n            children: \"代码复用、反映真实世界关系\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"多态\"\n          }), _jsx(_components.td, {\n            children: \"子类替代父类\"\n          }), _jsx(_components.td, {\n            children: \"继承、接口类、鸭子类型\"\n          }), _jsx(_components.td, {\n            children: \"提高扩展性与复用性\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"继承不应过度使用，会导致层次过深，导致低可读性与低可维护性\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"0607面向过程与面向对象\",\n      children: _jsx(_components.a, {\n        href: \"#0607面向过程与面向对象\",\n        children: \"06，07：面向过程与面向对象\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向过程是：数据与方法分离\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"为什么容易面向过程：略\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"面向过程的用处：略\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"08接口与抽象类\",\n      children: _jsx(_components.a, {\n        href: \"#08接口与抽象类\",\n        children: \"08：接口与抽象类\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"接口类与抽象类语法特性：略\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"应用场景区别：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"抽象类：代表is-a关系，解决代码复用问题\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"接口类：解决抽象、解耦问题\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"content":"\n# 导读\n\n## 02：如何评价代码好坏？\n\n从7个方面评价代码的好坏：\n\n1. 易维护性：根本\n2. 可读性：最重要\n3. 易扩展性：对修改关闭，对扩展开放\n4. 灵活性\n5. 简洁性：KISS\n6. 可复用性：DRY\n7. 可测试性：TDD，单元测试，控制反转与依赖注入\n\n## 03：编程方法论\n\n设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：\n\n1. 面向对象：封装，抽象，继承，多态\n2. 设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD\n3. 设计模式\n4. 编程规范：可读性，命名规范\n5. 重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模\n\n整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。\n\n\n# 面向对象\n\n使用封装，抽象，继承，多态，作为代码设计和实现的基石。\n\n1. 面向对象分析（做什么），设计（怎么做），编程\n\n## 05：封装，抽象，继承，多态\n\n|      | 是什么                 | 怎么做                 | 为什么                                                         |\n| ---- | ---------------------- | ---------------------- | -------------------------------------------------------------- |\n| 封装 | 信息隐藏、数据访问保护 | 访问控制关键字         | 减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性 |\n| 抽象 | 隐藏实现方法           | 函数、接口类、抽象类   | 提高可扩展性与维护性、过滤非必要信息                           |\n| 继承 | is-a关系               | 继承机制               | 代码复用、反映真实世界关系                                     |\n| 多态 | 子类替代父类           | 继承、接口类、鸭子类型 | 提高扩展性与复用性                                             |\n\n- 继承不应过度使用，会导致层次过深，导致低可读性与低可维护性\n- 在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。\n- 有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。\n\n## 06，07：面向过程与面向对象\n\n1. 面向过程是：数据与方法分离\n2. 面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；\n3. 看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；\n4. 为什么容易面向过程：略\n5. 面向过程的用处：略\n\n## 08：接口与抽象类\n\n1. 接口类与抽象类语法特性：略\n2. 抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。\n3. 应用场景区别：\n    - 抽象类：代表is-a关系，解决代码复用问题\n    - 接口类：解决抽象、解耦问题","title":"设计模式之美读书笔记","abstract":"从7个方面评价代码的好坏：\n1. 易维护性：根本\n2. 可读性：最重要","length":62,"created_at":"2021-08-21T08:53:27.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["设计模式","笔记"],"license":false}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"The-beauty-of-design-parten"},"buildId":"bHGAjcc8nV7lZR9cO6BC0","assetPrefix":"/blog-next","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>