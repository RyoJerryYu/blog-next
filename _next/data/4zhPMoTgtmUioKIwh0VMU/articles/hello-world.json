{"pageProps":{"slug":"hello-world","tags":[{"tag":"杂技","slug":"杂技","path":"/tags/杂技","postSlugs":[{"postType":"article","postSlug":"Building-this-blog","postPagePath":"/articles/Building-this-blog"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"},{"postType":"article","postSlug":"Building-this-blog","postPagePath":"/articles/Building-this-blog"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"},{"postType":"article","postSlug":"Building-this-blog","postPagePath":"/articles/Building-this-blog"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"},{"postType":"article","postSlug":"Building-this-blog","postPagePath":"/articles/Building-this-blog"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"},{"postType":"article","postSlug":"Building-this-blog","postPagePath":"/articles/Building-this-blog"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"},{"postType":"article","postSlug":"Building-this-blog","postPagePath":"/articles/Building-this-blog"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"the-using-in-cpp","postPagePath":"/articles/the-using-in-cpp"}]},{"tag":"杂谈","slug":"杂谈","path":"/tags/杂谈","postSlugs":[{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"},{"postType":"article","postSlug":"hello-world","postPagePath":"/articles/hello-world"}]}],"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    h2: \"h2\",\n    h4: \"h4\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"“Hello World!”\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"这是我的第一篇博文\",\n      children: _jsx(_components.a, {\n        href: \"#这是我的第一篇博文\",\n        children: \"这是我的第一篇博文\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"感谢\", _jsx(_components.a, {\n        href: \"https://github.com/huxpro\",\n        children: \"Huxpro\"\n      }), \"提供的博客模板，以及\", _jsx(_components.a, {\n        href: \"https://github.com/BruceZhaoR\",\n        children: \"BruceZhao\"\n      }), \"编写的中文ReadMe。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个博客的使用流程：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"写作时利用\", _jsx(_components.strong, {\n          children: \"Markdown\"\n        }), \"语法书写，与日常编写GitHub上的文档相同。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"使用\", _jsx(_components.strong, {\n          children: \"Git Workflow\"\n        }), \"进行博客的更新。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"利用\", _jsx(_components.strong, {\n          children: \"GitHub Pages\"\n        }), \"提供的域名与免费空间，以及其支持的\", _jsx(_components.strong, {\n          children: \"Jekyll\"\n        }), \"进行网站搭建。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我以后会利用这个博客，记录些许编程中遇到的问题。同时还有记录一下生活娱乐上的琐事。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这第一篇博文主要用于测试一下博客是否运行成功，不打算写太多东西。今后有时间的话会记录一下搭建博客的过程。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"感谢\",\n      children: _jsx(_components.a, {\n        href: \"#感谢\",\n        children: \"感谢\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/huxpro\",\n          children: \"Huxpro\"\n        }), \"提供的博客模板：\", _jsx(_components.a, {\n          href: \"https://github.com/Huxpro/huxblog-boilerplate\",\n          children: \"huxblog-boilerplate\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/BruceZhaoR\",\n          children: \"BruceZhao\"\n        }), \"提供的中文翻译：\", _jsx(_components.a, {\n          href: \"https://github.com/Huxpro/huxpro.github.io/blob/master/README.zh.md\",\n          children: \"README.zh.md\"\n        })]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"content":"\n> “Hello World!”\n\n## 这是我的第一篇博文\n\n自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。\n\n感谢[Huxpro][Huxpro]提供的博客模板，以及[BruceZhao][BruceZhao]编写的中文ReadMe。\n\n这个博客的使用流程：\n- 写作时利用**Markdown**语法书写，与日常编写GitHub上的文档相同。\n- 使用**Git Workflow**进行博客的更新。\n- 利用**GitHub Pages**提供的域名与免费空间，以及其支持的**Jekyll**进行网站搭建。\n\n我以后会利用这个博客，记录些许编程中遇到的问题。同时还有记录一下生活娱乐上的琐事。\n\n这第一篇博文主要用于测试一下博客是否运行成功，不打算写太多东西。今后有时间的话会记录一下搭建博客的过程。\n\n\n#### 感谢\n\n- [Huxpro][Huxpro]提供的博客模板：[huxblog-boilerplate](https://github.com/Huxpro/huxblog-boilerplate)\n- [BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md](https://github.com/Huxpro/huxpro.github.io/blob/master/README.zh.md)\n\n\n\n\n[Huxpro]: https://github.com/huxpro\n[BruceZhao]: https://github.com/BruceZhaoR","title":"Welcome to Ryo's Blog!","abstract":"> “Hello World!”\n自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。\n感谢[Huxpro][Huxpro]提供的博客模板，以及[BruceZhao][BruceZhao]编写的中文ReadMe。","length":29,"created_at":"2020-01-27T12:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["杂技","杂谈"],"license":false},"prevNextInfo":{"prevInfo":{"pathMapping":{"filePath":"public/content/articles/2020-01-28-the-using-in-cpp.md","pagePath":"/articles/the-using-in-cpp","slug":"the-using-in-cpp"},"meta":{"content":"\n## using的用法\n#### using与命名空间\n\n1. 引入整个命名空间中的成员\n   \n   不引入命名空间时，使用其中变量需要使用`<命名空间名>::<变量名>`的方式使用。\n   ```C++\n   using namespace foo;\n   ```\n   如此会将命名空间foo下所有的成员名称引入，可在直接以 `<变量名>` 的形式使用。但如此做有可能会使得命名空间foo中部分变量与当前定义的变量名冲突，违反命名空间隔离编译时名称冲突的初衷，因此不建议如此使用。\n\n2. 引入命名空间中的部分成员\n   \n   可通过仅引入命名空间中部分的成员，避免命名冲突。\n   ```C++\n   using foo::bar;\n   ```\n   这种方法仅会引入在语句中明确声明的名称。如using一个枚举类时，不会连其定义的枚举常量也一同引入。\n\n#### using与基类成员\n\n1. 子类中引入基类名称\n   \n   ```C++\n    class Base {\n    public:\n        std::size_t size() const { return n; }\n    protected:\n        std::size_t n;\n    };\n\n    class Derived : private Base {\n    public:\n        using Base::size;\n    protected:\n        using Base::n;\n    // ...\n    };\n    ```\n    例中子类private继承基类，由于private继承使得`Base::size`与`Base::n`可视性变为private。而使用`using Base::size`、`using Base::n`后，可分别使其变为public与protected。\n\n2. 子类成员函数与基类同名时保留基类函数用以重载\n   \n   ```C++\n    class Base\n    {\n    public:\n        int Func(){return 0;}\n    };\n    class Derived : Base\n    {\n    public:\n        using Base::Func;\n        int Func(int);\n    };\n    ```\n    子类中定义的成员函数与基类中重名时，即使函数原型不同，子类函数也会覆盖基类函数。\n    \n    如果基类中定义了一个函数的多个重载，而子类中又重写或重定义了其中某些版本，或是定义了一个新的重载，则基类中该函数的所有重载均被隐藏。\n\n    此时可以在子类中使用`using Base::Func`，令基类中所有重载版本在子类中可见，再重定义需要更改的版本。\n\n又如cppreference中的[例子](https://en.cppreference.com/w/cpp/language/using_declaration#In_class_definition)：\n```C++\n#include <iostream>\nstruct B {\n    virtual void f(int) { std::cout << \"B::f\\n\"; }\n    void g(char)        { std::cout << \"B::g\\n\"; }\n    void h(int)         { std::cout << \"B::h\\n\"; }\nprotected:\n    int m; // B::m is protected\n    typedef int value_type;\n};\n\nstruct D : B {\n    using B::m; // D::m is public\n    using B::value_type; // D::value_type is public\n\n    using B::f;\n    void f(int) { std::cout << \"D::f\\n\"; } // D::f(int) overrides B::f(int)\n    using B::g;\n    void g(int) { std::cout << \"D::g\\n\"; } // both g(int) and g(char) are visible\n                                        // as members of D\n    using B::h;\n    void h(int) { std::cout << \"D::h\\n\"; } // D::h(int) hides B::h(int)\n};\n\nint main()\n{\n    D d;\n    B& b = d;\n\n//    b.m = 2; // error, B::m is protected\n    d.m = 1; // protected B::m is accessible as public D::m\n    b.f(1); // calls derived f()\n    d.f(1); // calls derived f()\n    d.g(1); // calls derived g(int)\n    d.g('a'); // calls base g(char)\n    b.h(1); // calls base h()\n    d.h(1); // calls derived h()\n}\n```\n`using`语句可以改变基类成员的可访问性，也能在子类中重载(Overload)、重写(Override)基类的函数，或是通过重定义隐藏(Hide)对应的基类函数。\n\n\n#### using与别名\n\nusing在C++11开始，可用于别名的声明。用法如下：\n```C++\nusing UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>;//普通别名\nusing FP = void (*) (int, const std::string&);//函数指针别名\n\ntemplate <typename T>\nusing Vec = MyVector<T, MyAlloc<T>>;//模板别名\nVec<int> vec;//模板别名的使用\n```\n\n## using关键字与typedef关键字定义别名的不同\n\n在STL容器或是其他泛型中若是再接受一个容器类型，类型名称就会写得很长。使用typedef或using定义别名会变得比较方便：\n```C++\ntypedef std::unique_ptr<std::unordered_map<std::string, std::string>> UPtrMapSS;\n\nusing UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>;\n```\n\n对于函数指针，使用using语句可以把函数原型与别名强制分到左右两边，比使用typedef易读得多：\n```C++\ntypedef void (*FP) (int, const std::string&);\n\nusing FP = void (*) (int, const std::string&);\n```\n\n---\n\n在C++中，若试图使用typedef定义一个模板：\n```C++\ntemplate <typename T>\ntypedef MyVector<T, MyAlloc<T>> Vec;\n\n// usage\nVec<int> vec;\n```\n编译就会报错，提示：\n> error: a typedef cannot be a template\n\n在一些STL中，通过如下方式包装一层来使用：\n```C++\ntemplate <typename T>\nstruct Vec\n{\n  typedef MyVector<T, MyAlloc<T>> type;\n};\n\n// usage\nVec<int>::type vec;\n```\n\n如此显得十分不美观，且要是在模板类中或参数传递时使用typename强制这为类型，而不是其他如静态成员等语法：\n```C++\ntemplate <typename T>\nclass Widget\n{\n  typename Vec<T>::type vec;\n};\n```\n\n而using关键字可定义模板别名，则一切都会显得十分自然：\n```C++\ntemplate <typename T>\nusing Vec = MyVector<T, MyAlloc<T>>;\n\n// usage\nVec<int> vec;\n\n// in a class template\ntemplate <typename T>\nclass Widget\n{\n  Vec<T> vec;\n};\n```\n\n---\n\n能做到类似别名功能的，还有宏#define。但#define运行在编译前的宏处理阶段，对代码进行字符串替换。没有类型检查或其他编译、链接阶段才能进行的检查，不具备安全性。在C++11中不提倡使用#define。\n\n\n\n   \n   ","title":"C++中using关键字的使用","abstract":"1. 引入整个命名空间中的成员\n   不引入命名空间时，使用其中变量需要使用`<命名空间名>::<变量名>`的方式使用。\n   ```C++","length":192,"created_at":"2020-01-28T18:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["C++","杂技"],"license":false}},"nextInfo":{"pathMapping":{"filePath":"public/content/articles/2020-01-28-the-using-in-cpp.md","pagePath":"/articles/the-using-in-cpp","slug":"the-using-in-cpp"},"meta":{"content":"\n## using的用法\n#### using与命名空间\n\n1. 引入整个命名空间中的成员\n   \n   不引入命名空间时，使用其中变量需要使用`<命名空间名>::<变量名>`的方式使用。\n   ```C++\n   using namespace foo;\n   ```\n   如此会将命名空间foo下所有的成员名称引入，可在直接以 `<变量名>` 的形式使用。但如此做有可能会使得命名空间foo中部分变量与当前定义的变量名冲突，违反命名空间隔离编译时名称冲突的初衷，因此不建议如此使用。\n\n2. 引入命名空间中的部分成员\n   \n   可通过仅引入命名空间中部分的成员，避免命名冲突。\n   ```C++\n   using foo::bar;\n   ```\n   这种方法仅会引入在语句中明确声明的名称。如using一个枚举类时，不会连其定义的枚举常量也一同引入。\n\n#### using与基类成员\n\n1. 子类中引入基类名称\n   \n   ```C++\n    class Base {\n    public:\n        std::size_t size() const { return n; }\n    protected:\n        std::size_t n;\n    };\n\n    class Derived : private Base {\n    public:\n        using Base::size;\n    protected:\n        using Base::n;\n    // ...\n    };\n    ```\n    例中子类private继承基类，由于private继承使得`Base::size`与`Base::n`可视性变为private。而使用`using Base::size`、`using Base::n`后，可分别使其变为public与protected。\n\n2. 子类成员函数与基类同名时保留基类函数用以重载\n   \n   ```C++\n    class Base\n    {\n    public:\n        int Func(){return 0;}\n    };\n    class Derived : Base\n    {\n    public:\n        using Base::Func;\n        int Func(int);\n    };\n    ```\n    子类中定义的成员函数与基类中重名时，即使函数原型不同，子类函数也会覆盖基类函数。\n    \n    如果基类中定义了一个函数的多个重载，而子类中又重写或重定义了其中某些版本，或是定义了一个新的重载，则基类中该函数的所有重载均被隐藏。\n\n    此时可以在子类中使用`using Base::Func`，令基类中所有重载版本在子类中可见，再重定义需要更改的版本。\n\n又如cppreference中的[例子](https://en.cppreference.com/w/cpp/language/using_declaration#In_class_definition)：\n```C++\n#include <iostream>\nstruct B {\n    virtual void f(int) { std::cout << \"B::f\\n\"; }\n    void g(char)        { std::cout << \"B::g\\n\"; }\n    void h(int)         { std::cout << \"B::h\\n\"; }\nprotected:\n    int m; // B::m is protected\n    typedef int value_type;\n};\n\nstruct D : B {\n    using B::m; // D::m is public\n    using B::value_type; // D::value_type is public\n\n    using B::f;\n    void f(int) { std::cout << \"D::f\\n\"; } // D::f(int) overrides B::f(int)\n    using B::g;\n    void g(int) { std::cout << \"D::g\\n\"; } // both g(int) and g(char) are visible\n                                        // as members of D\n    using B::h;\n    void h(int) { std::cout << \"D::h\\n\"; } // D::h(int) hides B::h(int)\n};\n\nint main()\n{\n    D d;\n    B& b = d;\n\n//    b.m = 2; // error, B::m is protected\n    d.m = 1; // protected B::m is accessible as public D::m\n    b.f(1); // calls derived f()\n    d.f(1); // calls derived f()\n    d.g(1); // calls derived g(int)\n    d.g('a'); // calls base g(char)\n    b.h(1); // calls base h()\n    d.h(1); // calls derived h()\n}\n```\n`using`语句可以改变基类成员的可访问性，也能在子类中重载(Overload)、重写(Override)基类的函数，或是通过重定义隐藏(Hide)对应的基类函数。\n\n\n#### using与别名\n\nusing在C++11开始，可用于别名的声明。用法如下：\n```C++\nusing UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>;//普通别名\nusing FP = void (*) (int, const std::string&);//函数指针别名\n\ntemplate <typename T>\nusing Vec = MyVector<T, MyAlloc<T>>;//模板别名\nVec<int> vec;//模板别名的使用\n```\n\n## using关键字与typedef关键字定义别名的不同\n\n在STL容器或是其他泛型中若是再接受一个容器类型，类型名称就会写得很长。使用typedef或using定义别名会变得比较方便：\n```C++\ntypedef std::unique_ptr<std::unordered_map<std::string, std::string>> UPtrMapSS;\n\nusing UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>;\n```\n\n对于函数指针，使用using语句可以把函数原型与别名强制分到左右两边，比使用typedef易读得多：\n```C++\ntypedef void (*FP) (int, const std::string&);\n\nusing FP = void (*) (int, const std::string&);\n```\n\n---\n\n在C++中，若试图使用typedef定义一个模板：\n```C++\ntemplate <typename T>\ntypedef MyVector<T, MyAlloc<T>> Vec;\n\n// usage\nVec<int> vec;\n```\n编译就会报错，提示：\n> error: a typedef cannot be a template\n\n在一些STL中，通过如下方式包装一层来使用：\n```C++\ntemplate <typename T>\nstruct Vec\n{\n  typedef MyVector<T, MyAlloc<T>> type;\n};\n\n// usage\nVec<int>::type vec;\n```\n\n如此显得十分不美观，且要是在模板类中或参数传递时使用typename强制这为类型，而不是其他如静态成员等语法：\n```C++\ntemplate <typename T>\nclass Widget\n{\n  typename Vec<T>::type vec;\n};\n```\n\n而using关键字可定义模板别名，则一切都会显得十分自然：\n```C++\ntemplate <typename T>\nusing Vec = MyVector<T, MyAlloc<T>>;\n\n// usage\nVec<int> vec;\n\n// in a class template\ntemplate <typename T>\nclass Widget\n{\n  Vec<T> vec;\n};\n```\n\n---\n\n能做到类似别名功能的，还有宏#define。但#define运行在编译前的宏处理阶段，对代码进行字符串替换。没有类型检查或其他编译、链接阶段才能进行的检查，不具备安全性。在C++11中不提倡使用#define。\n\n\n\n   \n   ","title":"C++中using关键字的使用","abstract":"1. 引入整个命名空间中的成员\n   不引入命名空间时，使用其中变量需要使用`<命名空间名>::<变量名>`的方式使用。\n   ```C++","length":192,"created_at":"2020-01-28T18:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["C++","杂技"],"license":false}}}},"__N_SSG":true}