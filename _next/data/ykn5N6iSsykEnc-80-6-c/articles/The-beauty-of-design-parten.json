{"pageProps":{"slug":"The-beauty-of-design-parten","tags":[{"tag":"设计模式","slug":"设计模式","path":"/tags/设计模式","postSlugs":[{"postType":"articles","postPagePath":"/articles/The-beauty-of-design-parten"}]},{"tag":"笔记","slug":"笔记","path":"/tags/笔记","postSlugs":[{"postType":"articles","postPagePath":"/articles/The-beauty-of-design-parten"}]}],"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    h2: \"h2\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    span: \"span\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h1, {\n      id: \"导读\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#导读\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"导读\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"02如何评价代码好坏\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#02如何评价代码好坏\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"02：如何评价代码好坏？\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从7个方面评价代码的好坏：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"易维护性：根本\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可读性：最重要\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"易扩展性：对修改关闭，对扩展开放\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"灵活性\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"简洁性：KISS\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可复用性：DRY\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"可测试性：TDD，单元测试，控制反转与依赖注入\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"03编程方法论\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#03编程方法论\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"03：编程方法论\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向对象：封装，抽象，继承，多态\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"设计模式\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"编程规范：可读性，命名规范\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。\"\n    }), \"\\n\", _jsxs(_components.h1, {\n      id: \"面向对象\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#面向对象\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"面向对象\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用封装，抽象，继承，多态，作为代码设计和实现的基石。\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向对象分析（做什么），设计（怎么做），编程\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"05封装抽象继承多态\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#05封装抽象继承多态\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"05：封装，抽象，继承，多态\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {}), _jsx(_components.th, {\n            children: \"是什么\"\n          }), _jsx(_components.th, {\n            children: \"怎么做\"\n          }), _jsx(_components.th, {\n            children: \"为什么\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"封装\"\n          }), _jsx(_components.td, {\n            children: \"信息隐藏、数据访问保护\"\n          }), _jsx(_components.td, {\n            children: \"访问控制关键字\"\n          }), _jsx(_components.td, {\n            children: \"减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"抽象\"\n          }), _jsx(_components.td, {\n            children: \"隐藏实现方法\"\n          }), _jsx(_components.td, {\n            children: \"函数、接口类、抽象类\"\n          }), _jsx(_components.td, {\n            children: \"提高可扩展性与维护性、过滤非必要信息\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"继承\"\n          }), _jsx(_components.td, {\n            children: \"is-a关系\"\n          }), _jsx(_components.td, {\n            children: \"继承机制\"\n          }), _jsx(_components.td, {\n            children: \"代码复用、反映真实世界关系\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"多态\"\n          }), _jsx(_components.td, {\n            children: \"子类替代父类\"\n          }), _jsx(_components.td, {\n            children: \"继承、接口类、鸭子类型\"\n          }), _jsx(_components.td, {\n            children: \"提高扩展性与复用性\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"继承不应过度使用，会导致层次过深，导致低可读性与低可维护性\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"0607面向过程与面向对象\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#0607面向过程与面向对象\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"06，07：面向过程与面向对象\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"面向过程是：数据与方法分离\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"为什么容易面向过程：略\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"面向过程的用处：略\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"08接口与抽象类\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#08接口与抽象类\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"08：接口与抽象类\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"接口类与抽象类语法特性：略\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"应用场景区别：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"抽象类：代表is-a关系，解决代码复用问题\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"接口类：解决抽象、解耦问题\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"content":"\n# 导读\n\n## 02：如何评价代码好坏？\n\n从7个方面评价代码的好坏：\n\n1. 易维护性：根本\n2. 可读性：最重要\n3. 易扩展性：对修改关闭，对扩展开放\n4. 灵活性\n5. 简洁性：KISS\n6. 可复用性：DRY\n7. 可测试性：TDD，单元测试，控制反转与依赖注入\n\n## 03：编程方法论\n\n设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：\n\n1. 面向对象：封装，抽象，继承，多态\n2. 设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD\n3. 设计模式\n4. 编程规范：可读性，命名规范\n5. 重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模\n\n整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。\n\n\n# 面向对象\n\n使用封装，抽象，继承，多态，作为代码设计和实现的基石。\n\n1. 面向对象分析（做什么），设计（怎么做），编程\n\n## 05：封装，抽象，继承，多态\n\n|      | 是什么                 | 怎么做                 | 为什么                                                         |\n| ---- | ---------------------- | ---------------------- | -------------------------------------------------------------- |\n| 封装 | 信息隐藏、数据访问保护 | 访问控制关键字         | 减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性 |\n| 抽象 | 隐藏实现方法           | 函数、接口类、抽象类   | 提高可扩展性与维护性、过滤非必要信息                           |\n| 继承 | is-a关系               | 继承机制               | 代码复用、反映真实世界关系                                     |\n| 多态 | 子类替代父类           | 继承、接口类、鸭子类型 | 提高扩展性与复用性                                             |\n\n- 继承不应过度使用，会导致层次过深，导致低可读性与低可维护性\n- 在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。\n- 有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。\n\n## 06，07：面向过程与面向对象\n\n1. 面向过程是：数据与方法分离\n2. 面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；\n3. 看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；\n4. 为什么容易面向过程：略\n5. 面向过程的用处：略\n\n## 08：接口与抽象类\n\n1. 接口类与抽象类语法特性：略\n2. 抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。\n3. 应用场景区别：\n    - 抽象类：代表is-a关系，解决代码复用问题\n    - 接口类：解决抽象、解耦问题","title":"设计模式之美读书笔记","abstract":"从7个方面评价代码的好坏：\n1. 易维护性：根本\n2. 可读性：最重要","length":62,"created_at":"2021-08-21T08:53:27.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["设计模式","笔记"],"license":false,"headingTrees":[{"key":"导读","href":"#导读","heading":1,"title":"导读","children":[{"key":"02如何评价代码好坏","href":"#02如何评价代码好坏","heading":2,"title":"02：如何评价代码好坏？","children":[],"id":"02如何评价代码好坏"},{"key":"03编程方法论","href":"#03编程方法论","heading":2,"title":"03：编程方法论","children":[],"id":"03编程方法论"}],"id":"导读"},{"key":"面向对象","href":"#面向对象","heading":1,"title":"面向对象","children":[{"key":"05封装抽象继承多态","href":"#05封装抽象继承多态","heading":2,"title":"05：封装，抽象，继承，多态","children":[],"id":"05封装抽象继承多态"},{"key":"0607面向过程与面向对象","href":"#0607面向过程与面向对象","heading":2,"title":"06，07：面向过程与面向对象","children":[],"id":"0607面向过程与面向对象"},{"key":"08接口与抽象类","href":"#08接口与抽象类","heading":2,"title":"08：接口与抽象类","children":[],"id":"08接口与抽象类"}],"id":"面向对象"}],"wikiRefAliases":[],"richRefAliases":[]},"prevNextInfo":{"prevInfo":{"pathMapping":{"pagePath":"/articles/Handy-heap-cheat-sheet","filePath":"public/content/articles/2021-03-21-Handy-heap-cheat-sheet.md"},"meta":{"title":"如何手撕一个堆","created_at":"2021-08-28T23:09:14.000Z","updated_at":"2024-04-14T13:30:33.000Z"}},"nextInfo":{"pathMapping":{"pagePath":"/articles/Sort-algorithm","filePath":"public/content/articles/2021-01-11-Sort-algorithm.md"},"meta":{"title":"排序算法","created_at":"2021-01-11T22:57:10.000Z","updated_at":"2024-04-14T13:30:33.000Z"}}},"backRefResources":[],"hyperProps":{"withSEO":true,"withComments":true}},"__N_SSG":true}