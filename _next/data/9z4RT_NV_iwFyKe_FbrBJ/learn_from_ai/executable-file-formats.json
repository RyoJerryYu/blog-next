{"pageProps":{"slug":"executable-file-formats","tags":[{"tag":"Linux","slug":"linux","path":"/tags/linux","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux Systemd"},{"postType":"ideas","postPagePath":"/ideas/Linux 信号处理 —— Signal"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 内存分页、分段"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 堆和栈"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 虚拟内存"},{"postType":"ideas","postPagePath":"/ideas/Linux 调度 —— 进程与线程"},{"postType":"ideas","postPagePath":"/ideas/blog-syntax"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"Windows","slug":"windows","path":"/tags/windows","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"macOS","slug":"macos","path":"/tags/macos","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"可执行文件","slug":"可执行文件","path":"/tags/可执行文件","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"学习笔记","slug":"学习笔记","path":"/tags/学习笔记","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/deep-learning-model-formats"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/opencv-coordinate-system-conventions"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/lora-matrix-initialization-strategy"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-backpropagation-mechanism"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/mqtt-protocol-principles-applications"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-unet-structure"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-lora-training-methods"}]}],"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    h2: \"h2\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    span: \"span\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"本文介绍了几种主要的可执行文件格式，包括Linux系统使用的ELF格式、Windows系统使用的PE格式、以及macOS系统使用的Mach-O格式等。文章详细讨论了每种格式的特点、使用平台和历史演变，帮助读者理解不同操作系统中二进制文件格式的差异。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"q-解释-elf-执行文件\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#q-解释-elf-执行文件\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Q: 解释: ELF 执行文件\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ELF（Executable and Linkable Format）执行文件是一种用于Linux和类Unix操作系统的标准二进制文件格式。它包含了可执行程序、共享库、目标文件和核心转储文件。ELF文件格式设计灵活、可扩展，并且可移植，它定义了程序代码的加载和执行方式，包括代码段、数据段、符号表和重定位信息等。操作系统根据ELF文件中的这些信息来和执行程序。ELF格式也允许程序共享库，即多个程序可以共享同一段代码，从而减少内存占用并提高效率。在软件开发过程中，ELF文件作为目标文件格式在编译时生成，并最终由链接器组合形成可执行文件或共享库。\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"q-有与-elf-相并列的另外的一些二进制文件格式吗\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#q-有与-elf-相并列的另外的一些二进制文件格式吗\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Q: 有与 ELF 相并列的另外的一些二进制文件格式吗？\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"是的，除了ELF（Executable and Linking Format）之外，还有其他几种常见的二进制文件格式，它们在不同的操作系统和平台上被广泛使用。以下是一些主要的二进制文件格式：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"PE（Portable Executable）\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"使用平台\"\n            }), \"：主要在Windows操作系统上使用。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"特点\"\n            }), \"：PE格式是COFF（Common Object File Format）的扩展，用于可执行文件、目标文件、动态链接库DLLs）和驱动程序等。PE文件包含一个头部（PE header）、节表（section table）和各个节（sections），如代码节、数据节等。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Mach-O（Mach Object）\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"使用平台\"\n            }), \"：主要在Apple的macOS和iOS操作系统上使用。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"特点\"\n            }), \"：Mach-O格式用于存储可执行文件、目标文件和动态库。它包含多个段（segments和节（sections），支持多种架构，并且可以包含多个架构的代码（称为\\\"fat binary\\\"）。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"COFF（Common Object File Format）\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"使用平台\"\n            }), \"：早期在Unix System V和Windows NT上使用。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"特点\"\n            }), \"：COFF格式是一种通用的目标文件格式，包含代码、数据和重定位信息。虽然现在较少直接使用，但它的许多概念和结构被PE和ELF继承。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"a.out（Assembler Output）\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"使用平台\"\n            }), \"：早期Unix系统上使用。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"特点\"\n            }), \"：a.out是一种较简单的二进制文件格式，包含可执行代码、数据和符号表。随着ELF格式的出现，a.out逐渐被淘汰。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"DOS MZ（Mark Zbikowski）\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"使用平台\"\n            }), \"：早期DOS和Windows系统上使用。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"特点\"\n            }), \"：DOSZ格式是DOS可执行文件的格式，以\\\"MZ\\\"（开发者Mark Zbikowski的首字母）作为文件头部的标识。它被后来的PE格式所取代。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"COM文件\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"使用平台\"\n            }), \"：早期DOS系统上使用。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"特点\"\n            }), \"：COM文件是一种非常简单的可执行文件格式，仅包含代码和数据，没有头部信息，大小限制为64KB。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这些二进制文件格式各有特点，适用于不同的和场景。它们在文件结构、加载机制和功能支持上有所不同，但都旨在实现程序代码的有效存储和执行。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"content":"\n> 本文介绍了几种主要的可执行文件格式，包括Linux系统使用的ELF格式、Windows系统使用的PE格式、以及macOS系统使用的Mach-O格式等。文章详细讨论了每种格式的特点、使用平台和历史演变，帮助读者理解不同操作系统中二进制文件格式的差异。\n\n## Q: 解释: ELF 执行文件\n\nELF（Executable and Linkable Format）执行文件是一种用于Linux和类Unix操作系统的标准二进制文件格式。它包含了可执行程序、共享库、目标文件和核心转储文件。ELF文件格式设计灵活、可扩展，并且可移植，它定义了程序代码的加载和执行方式，包括代码段、数据段、符号表和重定位信息等。操作系统根据ELF文件中的这些信息来和执行程序。ELF格式也允许程序共享库，即多个程序可以共享同一段代码，从而减少内存占用并提高效率。在软件开发过程中，ELF文件作为目标文件格式在编译时生成，并最终由链接器组合形成可执行文件或共享库。\n\n## Q: 有与 ELF 相并列的另外的一些二进制文件格式吗？\n\n是的，除了ELF（Executable and Linking Format）之外，还有其他几种常见的二进制文件格式，它们在不同的操作系统和平台上被广泛使用。以下是一些主要的二进制文件格式：\n\n1. **PE（Portable Executable）**：\n   - **使用平台**：主要在Windows操作系统上使用。\n   - **特点**：PE格式是COFF（Common Object File Format）的扩展，用于可执行文件、目标文件、动态链接库DLLs）和驱动程序等。PE文件包含一个头部（PE header）、节表（section table）和各个节（sections），如代码节、数据节等。\n\n2. **Mach-O（Mach Object）**：\n   - **使用平台**：主要在Apple的macOS和iOS操作系统上使用。\n   - **特点**：Mach-O格式用于存储可执行文件、目标文件和动态库。它包含多个段（segments和节（sections），支持多种架构，并且可以包含多个架构的代码（称为\"fat binary\"）。\n\n3. **COFF（Common Object File Format）**：\n   - **使用平台**：早期在Unix System V和Windows NT上使用。\n   - **特点**：COFF格式是一种通用的目标文件格式，包含代码、数据和重定位信息。虽然现在较少直接使用，但它的许多概念和结构被PE和ELF继承。\n\n4. **a.out（Assembler Output）**：\n   - **使用平台**：早期Unix系统上使用。\n   - **特点**：a.out是一种较简单的二进制文件格式，包含可执行代码、数据和符号表。随着ELF格式的出现，a.out逐渐被淘汰。\n\n5. **DOS MZ（Mark Zbikowski）**：\n   - **使用平台**：早期DOS和Windows系统上使用。\n   - **特点**：DOSZ格式是DOS可执行文件的格式，以\"MZ\"（开发者Mark Zbikowski的首字母）作为文件头部的标识。它被后来的PE格式所取代。\n\n6. **COM文件**：\n   - **使用平台**：早期DOS系统上使用。\n   - **特点**：COM文件是一种非常简单的可执行文件格式，仅包含代码和数据，没有头部信息，大小限制为64KB。\n\n这些二进制文件格式各有特点，适用于不同的和场景。它们在文件结构、加载机制和功能支持上有所不同，但都旨在实现程序代码的有效存储和执行。\n\n","title":"可执行文件格式对比：ELF、PE、Mach-O等","abstract":"> 本文介绍了几种主要的可执行文件格式，包括Linux系统使用的ELF格式、Windows系统使用的PE格式、以及macOS系统使用的Mach-O格式等。文章详细讨论了每种格式的特点、使用平台和历史演变，帮助读者理解不同操作系统中二进制文件格式的差异。\nELF（Executable and Linkable Format）执行文件是一种用于Linux和类Unix操作系统的标准二进制文件格式。它包含了可执行程序、共享库、目标文件和核心转储文件。ELF文件格式设计灵活、可扩展，并且可移植，它定义了程序代码的加载和执行方式，包括代码段、数据段、符号表和重定位信息等。操作系统根据ELF文件中的这些信息来和执行程序。ELF格式也允许程序共享库，即多个程序可以共享同一段代码，从而减少内存占用并提高效率。在软件开发过程中，ELF文件作为目标文件格式在编译时生成，并最终由链接器组合形成可执行文件或共享库。\n是的，除了ELF（Executable and Linking Format）之外，还有其他几种常见的二进制文件格式，它们在不同的操作系统和平台上被广泛使用。以下是一些主要的二进制文件格式：","length":38,"created_at":"2024-12-08T02:00:00.000Z","updated_at":"2024-12-08T02:00:00.000Z","tags":["Linux","Windows","macOS","可执行文件","学习笔记"],"license":true,"headingTrees":[{"key":"q-解释-elf-执行文件","href":"#q-解释-elf-执行文件","heading":2,"title":"Q: 解释: ELF 执行文件","children":[],"id":"q-解释-elf-执行文件"},{"key":"q-有与-elf-相并列的另外的一些二进制文件格式吗","href":"#q-有与-elf-相并列的另外的一些二进制文件格式吗","heading":2,"title":"Q: 有与 ELF 相并列的另外的一些二进制文件格式吗？","children":[],"id":"q-有与-elf-相并列的另外的一些二进制文件格式吗"}],"wikiRefAliases":[],"richRefAliases":[]},"prevNextInfo":{"prevInfo":{"pathMapping":{"pagePath":"/learn_from_ai/cpp-rvo-and-rust-move-semantics","filePath":"public/content/learn_from_ai/2024-12-08-cpp-rvo-and-rust-move-semantics.md"},"meta":{"title":"C++右值引用与Rust移动语义","created_at":"2024-12-08T12:00:00.000Z","updated_at":"2024-12-08T12:00:00.000Z"}},"nextInfo":{"pathMapping":{"pagePath":"/learn_from_ai/opencv-coordinate-system-conventions","filePath":"public/content/learn_from_ai/2024-11-29-opencv-coordinate-system-conventions.md"},"meta":{"title":"OpenCV 坐标表示：理解 (y, x) 与 (x, y) 的区别","created_at":"2024-11-29T03:00:00.000Z","updated_at":"2024-11-29T03:00:00.000Z"}}},"backRefResources":[],"hyperProps":{"withSEO":true,"withComments":false}},"__N_SSG":true}