{"pageProps":{"slug":"try-cursor-and-thinking","tags":[{"tag":"Cursor","slug":"cursor","path":"/tags/cursor","postSlugs":[{"postType":"articles","postPagePath":"/articles/try-cursor-and-thinking"}]},{"tag":"杂谈","slug":"杂谈","path":"/tags/杂谈","postSlugs":[{"postType":"articles","postPagePath":"/articles/hello-world"},{"postType":"articles","postPagePath":"/articles/try-cursor-and-thinking"}]}],"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    h2: \"h2\",\n    h3: \"h3\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"试着用了一下 cursor ，感觉还不错。非技术也能半小时能做一款 App 可能是真的。但替代不了技术岗也是真的。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"先说问题\",\n      children: _jsx(_components.a, {\n        href: \"#先说问题\",\n        children: \"先说问题\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"虽然 Cursor 基于 VSCode 二次开发，但可能为了做 AI 功能把 Editor Pooling 或者 File Watching 能力搞坏了，经常 Apply 了修改后 Explorer 和 Editor 里没有及时反馈。然后自动补全功能因为可以删内容导致手感跟 VSCode 里的 Copilot 比较不同，用起来比较 annoying 。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"文件系统监控问题\",\n      children: _jsx(_components.a, {\n        href: \"#文件系统监控问题\",\n        children: \"文件系统监控问题\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"作为一个基于 VSCode 二次开发的编辑器，Cursor 在文件系统监控方面存在一些问题。当对文件进行修改后，Explorer 和 Editor 经常无法及时反映这些变化，这可能是因为为了实现 AI 功能而对原有的 Editor Pooling 或 File Watching 机制进行了修改导致的。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"这简直太让人抓狂了！😫 你改了代码，编辑器却在那装傻充愣。就好像你发了消息，对方已读不回 💬。程序员最讨厌等待了，对吧？⏳\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"自动补全体验差异\",\n      children: _jsx(_components.a, {\n        href: \"#自动补全体验差异\",\n        children: \"自动补全体验差异\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cursor 的自动补全功能与 VSCode 中的 GitHub Copilot 有明显的使用体验差异。由于 Cursor 的补全可以删除已有内容，这种行为方式与程序员习惯的编辑模式不太相符，使用起来感觉比较突兀和烦人。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"这个功能真的让人又爱又恨 💔！AI 小助手太热情了，动不动就想帮你重写代码。冷静点，老铁！我只是想要一点提示而已！🤪\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"性能影响\",\n      children: _jsx(_components.a, {\n        href: \"#性能影响\",\n        children: \"性能影响\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这些技术问题不仅影响了开发体验，还可能会降低编码效率。实时的文件系统反馈对于开发工作流程来说是非常重要的，而自动补全功能的差异也会影响到日常编码的流畅度。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"性能问题真是让人头大 🤯！写代码就应该是行云流水的感觉，现在却经常要等等等...等到我都能喝完一杯咖啡了 ☕️！\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"chat-anywhere\",\n      children: _jsx(_components.a, {\n        href: \"#chat-anywhere\",\n        children: \"Chat Anywhere\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不过 Chat Anywhere 这个做法应该是做对了。需要用 AI 代写的场景，很多时候并不是不会写而是懒得写，以前在 VSCode 里需要切到 Coplilot 的 Tab ，写 prompt 等回复，然后再将答案复制粘贴回去，多数情况下有这闲工夫还不如直接自己写🤣，在 Cursor 里可以直接原地调 AI 改写，真的巨舒服。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"这功能简直就是懒人福音啊！🎯 再也不用在各种窗口之间跳来跳去了！爽歪歪！🎊\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"智能代码分析\",\n      children: _jsx(_components.a, {\n        href: \"#智能代码分析\",\n        children: \"智能代码分析\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"还有 Cursor 可以直接将整个项目 Indexing 掉，还能理解代码间的调用关系，一个 prompt 直接出调用关系图，再也不用挠爆头想怎么做 RAG 怎么给文章分块了，爽到。\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog-next/content/articles/2024-11-16-try-cursor-and-thinking/Pasted%20image%2020241116200220.png\",\n      alt: \"Pasted image 20241116200220.png\",\n      title: \"Pasted image 20241116200220.png\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog-next/content/articles/2024-11-16-try-cursor-and-thinking/Pasted%20image%2020241116200148.png\",\n      alt: \"Pasted image 20241116200148.png\",\n      title: \"Pasted image 20241116200148.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"cursor-可能会比较有用的场景\",\n      children: _jsx(_components.a, {\n        href: \"#cursor-可能会比较有用的场景\",\n        children: \"Cursor 可能会比较有用的场景\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"智能注释生成\",\n      children: _jsx(_components.a, {\n        href: \"#智能注释生成\",\n        children: \"智能注释生成\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cursor 在生成代码注释方面表现出色。它不仅能分析当前文件的代码，还能理解整个项目的上下文。通过分析 import 关系、函数调用链、接口实现和类型定义等多个维度，它能生成更加准确和有意义的注释。这对于维护大型项目或者需要快速理解他人代码的场景特别有帮助。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"终于不用为写注释抓耳挠腮了！🎉 AI 帮你分析完所有代码关系，三下五除二就能生成一份漂亮的注释！💡\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"文档和文章创作\",\n      children: _jsx(_components.a, {\n        href: \"#文档和文章创作\",\n        children: \"文档和文章创作\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在文档和文章创作方面，Cursor 的原地 AI 改写功能特别实用。当你需要写一篇长文，需要参考多个文档源，但又不需要特别严格的逻辑推导时，这个功能简直是神器。你可以：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"让 AI 帮你规划文章结构，生成合适的目录\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"根据已有内容快速扩充段落\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"实时调整文章语气和风格\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"参考相关文档自动补充内容\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"写文档再也不用对着空白发呆了！✍️ AI 小助手随时待命，帮你把想法变成优美的文字！📝\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"项目结构优化\",\n      children: _jsx(_components.a, {\n        href: \"#项目结构优化\",\n        children: \"项目结构优化\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在项目结构维护方面，Cursor 提供了一系列强大的功能：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"可视化项目结构\"\n          }), \"：一键生成项目依赖关系图，让项目结构一目了然。再也不用在复杂的目录结构中迷失方向。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"智能重构建议\"\n          }), \"：基于项目分析，AI 可以提供项目结构优化建议，帮助你建立更清晰的代码组织方式。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"自动化工具生成\"\n          }), \"：需要批量处理文件？Cursor 可以直接生成 Shell 命令或 Python 脚本，帮你完成繁琐的目录操作。\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"项目管理变得如此轻松！🚀 让 AI 帮你梳理项目结构，生成工具脚本，程序员的生产力简直起飞！✨\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"总结\",\n      children: _jsx(_components.a, {\n        href: \"#总结\",\n        children: \"总结\"\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"总的来说，Cursor 作为一款基于 AI 的代码编辑器有其独特的优势，尤其是 Chat Anywhere 和智能代码分析这样的创新功能确实提升了开发效率。但同时也存在一些技术问题，比如文件系统监控和自动补全体验等需要改进的地方。尽管如此，它展示了 AI 辅助编程的潜力，为未来编程工具的发展提供了新的思路。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"顺便一提，在引用块里的内容都是由 AI 生成的。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"content":"\n试着用了一下 cursor ，感觉还不错。非技术也能半小时能做一款 App 可能是真的。但替代不了技术岗也是真的。\n\n## 先说问题\n\n虽然 Cursor 基于 VSCode 二次开发，但可能为了做 AI 功能把 Editor Pooling 或者 File Watching 能力搞坏了，经常 Apply 了修改后 Explorer 和 Editor 里没有及时反馈。然后自动补全功能因为可以删内容导致手感跟 VSCode 里的 Copilot 比较不同，用起来比较 annoying 。\n\n### 文件系统监控问题\n\n作为一个基于 VSCode 二次开发的编辑器，Cursor 在文件系统监控方面存在一些问题。当对文件进行修改后，Explorer 和 Editor 经常无法及时反映这些变化，这可能是因为为了实现 AI 功能而对原有的 Editor Pooling 或 File Watching 机制进行了修改导致的。\n\n> 这简直太让人抓狂了！😫 你改了代码，编辑器却在那装傻充愣。就好像你发了消息，对方已读不回 💬。程序员最讨厌等待了，对吧？⏳\n\n### 自动补全体验差异\n\nCursor 的自动补全功能与 VSCode 中的 GitHub Copilot 有明显的使用体验差异。由于 Cursor 的补全可以删除已有内容，这种行为方式与程序员习惯的编辑模式不太相符，使用起来感觉比较突兀和烦人。\n\n> 这个功能真的让人又爱又恨 💔！AI 小助手太热情了，动不动就想帮你重写代码。冷静点，老铁！我只是想要一点提示而已！🤪\n\n### 性能影响\n\n这些技术问题不仅影响了开发体验，还可能会降低编码效率。实时的文件系统反馈对于开发工作流程来说是非常重要的，而自动补全功能的差异也会影响到日常编码的流畅度。\n\n> 性能问题真是让人头大 🤯！写代码就应该是行云流水的感觉，现在却经常要等等等...等到我都能喝完一杯咖啡了 ☕️！\n\n\n## Chat Anywhere\n\n不过 Chat Anywhere 这个做法应该是做对了。需要用 AI 代写的场景，很多时候并不是不会写而是懒得写，以前在 VSCode 里需要切到 Coplilot 的 Tab ，写 prompt 等回复，然后再将答案复制粘贴回去，多数情况下有这闲工夫还不如直接自己写🤣，在 Cursor 里可以直接原地调 AI 改写，真的巨舒服。\n\n> 这功能简直就是懒人福音啊！🎯 再也不用在各种窗口之间跳来跳去了！爽歪歪！🎊\n\n## 智能代码分析\n\n还有 Cursor 可以直接将整个项目 Indexing 掉，还能理解代码间的调用关系，一个 prompt 直接出调用关系图，再也不用挠爆头想怎么做 RAG 怎么给文章分块了，爽到。\n\n![[Pasted image 20241116200220.png]]\n\n![[Pasted image 20241116200148.png]]\n\n## Cursor 可能会比较有用的场景\n\n### 智能注释生成\n\nCursor 在生成代码注释方面表现出色。它不仅能分析当前文件的代码，还能理解整个项目的上下文。通过分析 import 关系、函数调用链、接口实现和类型定义等多个维度，它能生成更加准确和有意义的注释。这对于维护大型项目或者需要快速理解他人代码的场景特别有帮助。\n\n> 终于不用为写注释抓耳挠腮了！🎉 AI 帮你分析完所有代码关系，三下五除二就能生成一份漂亮的注释！💡\n\n### 文档和文章创作\n\n在文档和文章创作方面，Cursor 的原地 AI 改写功能特别实用。当你需要写一篇长文，需要参考多个文档源，但又不需要特别严格的逻辑推导时，这个功能简直是神器。你可以：\n\n- 让 AI 帮你规划文章结构，生成合适的目录\n- 根据已有内容快速扩充段落\n- 实时调整文章语气和风格\n- 参考相关文档自动补充内容\n\n> 写文档再也不用对着空白发呆了！✍️ AI 小助手随时待命，帮你把想法变成优美的文字！📝\n\n### 项目结构优化\n\n在项目结构维护方面，Cursor 提供了一系列强大的功能：\n\n1. **可视化项目结构**：一键生成项目依赖关系图，让项目结构一目了然。再也不用在复杂的目录结构中迷失方向。\n\n2. **智能重构建议**：基于项目分析，AI 可以提供项目结构优化建议，帮助你建立更清晰的代码组织方式。\n\n3. **自动化工具生成**：需要批量处理文件？Cursor 可以直接生成 Shell 命令或 Python 脚本，帮你完成繁琐的目录操作。\n\n> 项目管理变得如此轻松！🚀 让 AI 帮你梳理项目结构，生成工具脚本，程序员的生产力简直起飞！✨\n\n\n## 总结\n\n> 总的来说，Cursor 作为一款基于 AI 的代码编辑器有其独特的优势，尤其是 Chat Anywhere 和智能代码分析这样的创新功能确实提升了开发效率。但同时也存在一些技术问题，比如文件系统监控和自动补全体验等需要改进的地方。尽管如此，它展示了 AI 辅助编程的潜力，为未来编程工具的发展提供了新的思路。\n\n顺便一提，在引用块里的内容都是由 AI 生成的。\n","title":"尝试 Cursor 的感想和一些思考","abstract":"试着用了一下 cursor ，感觉还不错。非技术也能半小时能做一款 App 可能是真的。但替代不了技术岗也是真的。\n虽然 Cursor 基于 VSCode 二次开发，但可能为了做 AI 功能把 Editor Pooling 或者 File Watching 能力搞坏了，经常 Apply 了修改后 Explorer 和 Editor 里没有及时反馈。然后自动补全功能因为可以删内容导致手感跟 VSCode 里的 Copilot 比较不同，用起来比较 annoying 。\n作为一个基于 VSCode 二次开发的编辑器，Cursor 在文件系统监控方面存在一些问题。当对文件进行修改后，Explorer 和 Editor 经常无法及时反映这些变化，这可能是因为为了实现 AI 功能而对原有的 Editor Pooling 或 File Watching 机制进行了修改导致的。","length":78,"created_at":"2024-11-16T15:42:00.000Z","updated_at":"2024-11-16T15:42:00.000Z","tags":["Cursor","杂谈"],"license":true,"headingTrees":[{"key":"先说问题","href":"#先说问题","heading":2,"title":"先说问题","children":[{"key":"文件系统监控问题","href":"#文件系统监控问题","heading":3,"title":"文件系统监控问题","children":[],"id":"文件系统监控问题"},{"key":"自动补全体验差异","href":"#自动补全体验差异","heading":3,"title":"自动补全体验差异","children":[],"id":"自动补全体验差异"},{"key":"性能影响","href":"#性能影响","heading":3,"title":"性能影响","children":[],"id":"性能影响"}],"id":"先说问题"},{"key":"chat-anywhere","href":"#chat-anywhere","heading":2,"title":"Chat Anywhere","children":[],"id":"chat-anywhere"},{"key":"智能代码分析","href":"#智能代码分析","heading":2,"title":"智能代码分析","children":[],"id":"智能代码分析"},{"key":"cursor-可能会比较有用的场景","href":"#cursor-可能会比较有用的场景","heading":2,"title":"Cursor 可能会比较有用的场景","children":[{"key":"智能注释生成","href":"#智能注释生成","heading":3,"title":"智能注释生成","children":[],"id":"智能注释生成"},{"key":"文档和文章创作","href":"#文档和文章创作","heading":3,"title":"文档和文章创作","children":[],"id":"文档和文章创作"},{"key":"项目结构优化","href":"#项目结构优化","heading":3,"title":"项目结构优化","children":[],"id":"项目结构优化"}],"id":"cursor-可能会比较有用的场景"},{"key":"总结","href":"#总结","heading":2,"title":"总结","children":[],"id":"总结"}],"wikiRefAliases":[],"richRefAliases":["Pasted image 20241116200220.png","Pasted image 20241116200148.png"]},"prevNextInfo":{"prevInfo":null,"nextInfo":{"pathMapping":{"pagePath":"/articles/introduction-for-k8s-2","filePath":"public/content/articles/2022-08-20-introduction-for-k8s-2.md"},"meta":{"title":"Kubernetes 入门 （2）","created_at":"2022-08-20T21:56:52.000Z","updated_at":"2022-08-20T14:02:18.000Z"}}},"backRefResources":[],"hyperProps":{"withSEO":true,"withComments":true}},"__N_SSG":true}