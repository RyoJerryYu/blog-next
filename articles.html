<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><meta name="description" content="The blog owned by Ryo, about Programing, Painting, and Gaming." data-next-head=""/><meta property="og:description" content="The blog owned by Ryo, about Programing, Painting, and Gaming." data-next-head=""/><meta name="twitter:description" content="The blog owned by Ryo, about Programing, Painting, and Gaming." data-next-head=""/><meta property="og:image" content="https://ryojerryyu.github.io/blog-next/img/home-bg-kasumi-hanabi.jpg" data-next-head=""/><meta name="twitter:image" content="https://ryojerryyu.github.io/blog-next/img/home-bg-kasumi-hanabi.jpg" data-next-head=""/><meta property="og:type" content="website" data-next-head=""/><meta property="og:url" content="https://blog.ryo-okami.xyz/articles" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:site" content="@ryo_okami" data-next-head=""/><meta name="twitter:creator" content="@ryo_okami" data-next-head=""/><link rel="icon" href="/blog-next/favicon.ico" data-next-head=""/><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" data-next-head=""/><title data-next-head="">Articles | Ryo&#x27;s Blog</title><meta property="og:title" content="Articles" data-next-head=""/><meta property="og:site_name" content="Ryo&#x27;s Blog" data-next-head=""/><meta name="twitter:title" content="Articles | Ryo&#x27;s Blog" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog-next/_next/static/css/7cdbda104a0532c1.css" as="style"/><link rel="preload" href="/blog-next/_next/static/css/6fa7810a66b4dbc0.css" as="style"/><link rel="stylesheet" href="/blog-next/_next/static/css/7cdbda104a0532c1.css" data-n-g=""/><link rel="stylesheet" href="/blog-next/_next/static/css/6fa7810a66b4dbc0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/blog-next/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog-next/_next/static/chunks/webpack-c432b1ec7364dcfe.js" defer=""></script><script src="/blog-next/_next/static/chunks/framework-bd61ec64032c2de7.js" defer=""></script><script src="/blog-next/_next/static/chunks/main-0d790d35cd43e765.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/_app-46f15a352f2e34a5.js" defer=""></script><script src="/blog-next/_next/static/chunks/6d2b60a9-beef439121ada977.js" defer=""></script><script src="/blog-next/_next/static/chunks/52d06cd5-18d657cfd06e973c.js" defer=""></script><script src="/blog-next/_next/static/chunks/4130-4f55663d0ffc3327.js" defer=""></script><script src="/blog-next/_next/static/chunks/4587-ad3e00575945688a.js" defer=""></script><script src="/blog-next/_next/static/chunks/366-e7aa9bf3cae7308c.js" defer=""></script><script src="/blog-next/_next/static/chunks/7564-2d1adbbf02956a78.js" defer=""></script><script src="/blog-next/_next/static/chunks/8494-2925249a12348ea9.js" defer=""></script><script src="/blog-next/_next/static/chunks/pages/articles-3521bea00d203bd6.js" defer=""></script><script src="/blog-next/_next/static/_266gU8SGVnSWMafFo461/_buildManifest.js" defer=""></script><script src="/blog-next/_next/static/_266gU8SGVnSWMafFo461/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css czlpqi">.css-czlpqi{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:fixed;z-index:1100;top:0;left:auto;right:0;--AppBar-background:#1976d2;--AppBar-color:#fff;background-color:var(--AppBar-background);color:var(--AppBar-color);background-color:rgba(15, 23, 42, 0.75);}@media print{.css-czlpqi{position:absolute;}}</style><style data-emotion="css 1cmpeoq">.css-1cmpeoq{background-color:#fff;color:rgba(0, 0, 0, 0.87);-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;box-shadow:var(--Paper-shadow);background-image:var(--Paper-overlay);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:fixed;z-index:1100;top:0;left:auto;right:0;--AppBar-background:#1976d2;--AppBar-color:#fff;background-color:var(--AppBar-background);color:var(--AppBar-color);background-color:rgba(15, 23, 42, 0.75);}@media print{.css-1cmpeoq{position:absolute;}}</style><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionFixed mui-fixed css-1cmpeoq" style="--Paper-shadow:0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12)"><style data-emotion="css awgou1">.css-awgou1{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:16px;padding-right:16px;min-height:56px;}@media (min-width:600px){.css-awgou1{padding-left:24px;padding-right:24px;}}@media (min-width:0px){@media (orientation: landscape){.css-awgou1{min-height:48px;}}}@media (min-width:600px){.css-awgou1{min-height:64px;}}</style><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-awgou1"><style data-emotion="css 1guk29">@media (min-width:0px){.css-1guk29{display:none;}}@media (min-width:900px){.css-1guk29{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}</style><div class="ml-2 w-24 mr-4 MuiBox-root css-1guk29"><a class="DefaultLayout_textlink__W55gl" href="/blog-next">Ryo&#x27;s Blog</a></div><style data-emotion="css 1m04nb5">@media (min-width:0px){.css-1m04nb5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}@media (min-width:900px){.css-1m04nb5{display:none;}}</style><div class="ml-2 mr-4 MuiBox-root css-1m04nb5"><a title="Ryo&#x27;s Blog" href="/blog-next"><style data-emotion="css q7mezt">.css-q7mezt{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;fill:currentColor;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium h-6 w-6 text-gray-300 hover:text-white css-q7mezt" focusable="false" aria-hidden="true" viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path></svg></a></div><style data-emotion="css nznm6s">.css-nznm6s{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:1;-ms-flex:1;flex:1;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="MuiBox-root css-nznm6s"><div class="DefaultLayoutMenu bg-transparent min-w-full"><ul class="rc-menu-overflow rc-menu rc-menu-root rc-menu-horizontal" role="menu" tabindex="0" data-menu-list="true"><li class="rc-menu-overflow-item rc-menu-item" style="opacity:1;order:0" role="menuitem" tabindex="-1"><a class="DefaultLayout_textlink__W55gl" href="/blog-next/articles">Articles</a></li><li class="rc-menu-overflow-item rc-menu-item" style="opacity:1;order:1" role="menuitem" tabindex="-1"><a class="DefaultLayout_textlink__W55gl" href="/blog-next/learn_from_ai">Learn from AI</a></li><li class="rc-menu-overflow-item rc-menu-item" style="opacity:1;order:2" role="menuitem" tabindex="-1"><a class="DefaultLayout_textlink__W55gl" href="/blog-next/tags">Tags</a></li><li class="rc-menu-overflow-item rc-menu-submenu rc-menu-submenu-horizontal" style="opacity:1;order:3" role="none"><div role="menuitem" class="rc-menu-submenu-title" tabindex="-1" aria-expanded="false" aria-haspopup="true"><span class="DefaultLayout_textlink__W55gl">More</span><i class="rc-menu-submenu-arrow"></i></div></li><li class="rc-menu-overflow-item rc-menu-overflow-item-rest rc-menu-submenu rc-menu-submenu-horizontal" style="opacity:0;height:0;overflow-y:hidden;order:9007199254740991;pointer-events:none;position:absolute" aria-hidden="true" role="none"><div role="menuitem" class="rc-menu-submenu-title" tabindex="-1" title="..." aria-expanded="false" aria-haspopup="true">...<i class="rc-menu-submenu-arrow"></i></div></li></ul><div style="display:none" aria-hidden="true"></div></div></div><style data-emotion="css k008qs">.css-k008qs{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}</style><div class="MuiBox-root css-k008qs"><a title="Twitter" href="https://twitter.com/ryo_okami"><svg class="h-6 w-6 fill-gray-300 hover:fill-white mx-1 sm:mx-2" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a title="GitHub" href="https://github.com/RyoJerryYu"><svg class="h-6 w-6 fill-gray-300 hover:fill-white mx-1 sm:mx-2" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a title="Pixiv" href="https://www.pixiv.net/users/9159893"><svg class="h-6 w-6 fill-gray-300 hover:fill-white mx-1 sm:mx-2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.935 0A4.924 4.924 0 0 0 0 4.935v14.13A4.924 4.924 0 0 0 4.935 24h14.13A4.924 4.924 0 0 0 24 19.065V4.935A4.924 4.924 0 0 0 19.065 0zm7.81 4.547c2.181 0 4.058.676 5.399 1.847a6.118 6.118 0 0 1 2.116 4.66c.005 1.854-.88 3.476-2.257 4.563-1.375 1.092-3.225 1.697-5.258 1.697-2.314 0-4.46-.842-4.46-.842v2.718c.397.116 1.048.365.635.779H5.79c-.41-.41.19-.65.644-.779V7.666c-1.053.81-1.593 1.51-1.868 2.031.32 1.02-.284.969-.284.969l-1.09-1.73s3.868-4.39 9.553-4.39zm-.19.971c-1.423-.003-3.184.473-4.27 1.244v8.646c.988.487 2.484.832 4.26.832h.01c1.596 0 2.98-.593 3.93-1.533.952-.948 1.486-2.183 1.492-3.683-.005-1.54-.504-2.864-1.42-3.86-.918-.992-2.274-1.645-4.002-1.646Z"></path></svg></a></div></div></header><style data-emotion="css awgou1">.css-awgou1{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:16px;padding-right:16px;min-height:56px;}@media (min-width:600px){.css-awgou1{padding-left:24px;padding-right:24px;}}@media (min-width:0px){@media (orientation: landscape){.css-awgou1{min-height:48px;}}}@media (min-width:600px){.css-awgou1{min-height:64px;}}</style><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-awgou1"></div><style data-emotion="css vktxal">.css-vktxal{--Grid-columns:12;--Grid-columnSpacing:0px;--Grid-rowSpacing:0px;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;min-width:0;box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;gap:var(--Grid-rowSpacing) var(--Grid-columnSpacing);width:100%;max-width:80rem;margin-left:auto;margin-right:auto;padding:0.5rem;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}.css-vktxal >*{--Grid-parent-columns:12;}.css-vktxal >*{--Grid-parent-columnSpacing:0px;}.css-vktxal >*{--Grid-parent-rowSpacing:0px;}</style><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-row css-vktxal"><style data-emotion="css 9gdssj">.css-9gdssj{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 0 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 0) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));min-width:0;box-sizing:border-box;}@media (min-width:900px){.css-9gdssj{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 0 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 0) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}@media (min-width:1200px){.css-9gdssj{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 2 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 2) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}</style><div class="MuiGrid-root MuiGrid-direction-xs-row MuiGrid-grid-xs-0 MuiGrid-grid-md-0 MuiGrid-grid-lg-2 css-9gdssj"></div><style data-emotion="css 9h67uz">.css-9h67uz{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 12 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 12) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));min-width:0;box-sizing:border-box;}@media (min-width:900px){.css-9h67uz{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 9 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 9) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}@media (min-width:1200px){.css-9h67uz{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 8 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 8) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}</style><div class="MuiGrid-root MuiGrid-direction-xs-row MuiGrid-grid-xs-12 MuiGrid-grid-md-9 MuiGrid-grid-lg-8 css-9h67uz"><div class="DefaultLayout_contentHeight__RDRZE"><div class="PostList_postList__Tuobz"><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/from-linear-algebra-to-analytical-machanics-2"><h6 class="PostList_postTitle__vveJr">从线性代数到分析力学（下）</h6><div class="PostList_postDate__z_XQh"><time dateTime="2025-09-30T13:42:54.000Z">2025-09-30</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">&gt; [!info]</p><p class="py-1">&gt; 这是《从线性代数到分析力学》上下两篇中的下篇，上篇为[[2025-09-29-from-linear-algebra-to-analytical-machanics-1|从线性代数到分析力学]]。</p><p class="py-1">最早，欧拉研究总结了短程线问题、等周问题等一大类类似“求取得极值时的曲线”的问题，并提出能使用了后来被称为“欧拉-拉格朗日方程”的通用的方法来求解这类问题。可惜此时欧拉的推导过程使用了大量分析与几何结合的手段，十分复杂也缺乏严谨，欧拉自己也对此并不满意。[^长河劫变分法]</p></div></a></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/from-linear-algebra-to-analytical-machanics-1"><h6 class="PostList_postTitle__vveJr">从线性代数到分析力学（上）</h6><div class="PostList_postDate__z_XQh"><time dateTime="2025-09-29T13:38:46.000Z">2025-09-29</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">讲线性代数，被同济版线性代数毒害过的人可能都会被唤醒藏于心底的恐惧：哇！又要讲行列式、对角化、增广矩阵算来算去了！</p><p class="py-1">其实线性代数没那么可怕。我们可以很直观地、很感性地去理解线性代数。</p><p class="py-1">线性代数，关键当然在于“线性”。（应该没人会觉得线性代数的关键在于“代数”吧？）如果一个函数 $f(x)$ 有以下性质：</p></div></a></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/ygomd-deck-ryzeal-1"><h6 class="PostList_postTitle__vveJr">【游戏王大学习】雷热涡炉 MD 卡组简介</h6><div class="PostList_postDate__z_XQh"><time dateTime="2025-09-04T16:51:28.000Z">2025-09-04</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">外燃内燃剑极节极……</p><p class="py-1">兄弟拿兄弟，不用叫，就能跳。</p><p class="py-1">两个四，绝命导爆，你喊效果我就爆！</p></div></a></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/ygomd-chronicle-cup-six-samurai"><h6 class="PostList_postTitle__vveJr">【游戏王大学习】六武众——游戏王 MD 2025-08编年史杯六武众预组</h6><div class="PostList_postDate__z_XQh"><time dateTime="2025-08-18T17:22:37.000Z">2025-08-18</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">同调杯后紧接着就来了编年史杯。</p><p class="py-1">这次编年史杯环境比较舒适，没有各路神仙横跳。三套预组里六武众在这个环境可以说是风生水起。六武众预组里有新卡三张[[六武众的指南番]]和三张[[六武众的破戒僧]]，额外还放了三张[[真魔六武众-紫炎]]，足够强劲。能出真魔紫炎就赢一半，能出三个终端能赢大部分卡组。</p><p class="py-1">以前算是玩过一点六武众，现在趁杯赛重新学习一下六武众卡组，这篇文章也算是我的学习笔记。可能会有很多很多谬误，如果发现了请评论指正。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%B8%B8%E6%88%8F%E7%8E%8B">#<!-- -->游戏王</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%B8%B8%E6%88%8F%E7%8E%8Bmd">#<!-- -->游戏王MD</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%B8%B8%E6%88%8F%E7%8E%8B%E5%A4%A7%E5%B8%88%E5%86%B3%E6%96%97">#<!-- -->游戏王大师决斗</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%9D%82%E8%B0%88">#<!-- -->杂谈</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/ygomd-synchro-cup-crystron"><h6 class="PostList_postTitle__vveJr">【游戏王大学习】水晶机巧——游戏王 MD 2025-08同调杯水晶机巧预组</h6><div class="PostList_postDate__z_XQh"><time dateTime="2025-08-10T23:48:00.000Z">2025-08-10</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">这次的同调杯三个预组中，唯一算是比较有强度的就是水晶机巧了。</p><p class="py-1">水机卡组刚出来的时候我也算是小小玩过，但现在的水晶机巧已经跟第 9 期那时完全不同打法了。连一刻都没有为继承玻纤的死亡哀悼，立即赶到 MD 的是 12 期的五张新卡！三位玉晶、柠晶救龙、圣天骸晶、绿阵、红阵，5张新时代的补强可以说完全重构了水晶机巧这个卡组。</p><p class="py-1">为了打这次同调杯，我专门重新学习了水机卡组。这篇文章也算是学习过程中的总结笔记。可能会有很多很多谬误，如果发现了请评论指正。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%B8%B8%E6%88%8F%E7%8E%8B">#<!-- -->游戏王</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%9D%82%E8%B0%88">#<!-- -->杂谈</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%B8%B8%E6%88%8F%E7%8E%8Bmd">#<!-- -->游戏王MD</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%B8%B8%E6%88%8F%E7%8E%8B%E5%A4%A7%E5%B8%88%E5%86%B3%E6%96%97">#<!-- -->游戏王大师决斗</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/try-cursor-and-thinking"><h6 class="PostList_postTitle__vveJr">尝试 Cursor 的感想和一些思考</h6><div class="PostList_postDate__z_XQh"><time dateTime="2024-11-16T15:42:00.000Z">2024-11-16</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">试着用了一下 cursor ，感觉还不错。非技术也能半小时能做一款 App 可能是真的。但替代不了技术岗也是真的。</p><p class="py-1">虽然 Cursor 基于 VSCode 二次开发，但可能为了做 AI 功能把 Editor Pooling 或者 File Watching 能力搞坏了，经常 Apply 了修改后 Explorer 和 Editor 里没有及时反馈。然后自动补全功能因为可以删内容导致手感跟 VSCode 里的 Copilot 比较不同，用起来比较 annoying 。</p><p class="py-1">作为一个基于 VSCode 二次开发的编辑器，Cursor 在文件系统监控方面存在一些问题。当对文件进行修改后，Explorer 和 Editor 经常无法及时反映这些变化，这可能是因为为了实现 AI 功能而对原有的 Editor Pooling 或 File Watching 机制进行了修改导致的。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/cursor">#<!-- -->Cursor</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%9D%82%E8%B0%88">#<!-- -->杂谈</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/introduction-for-k8s-2"><h6 class="PostList_postTitle__vveJr">Kubernetes 入门 （2）</h6><div class="PostList_postDate__z_XQh"><time dateTime="2022-08-20T21:56:52.000Z">2022-08-20</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">我们之前说的都是用于部署 Pod 的资源，我们接下来介绍与创建 Pod 不相关的资源：储存与网络。</p><p class="py-1">其实我们之前已经接触过储存相关的内容了：在讲 Stateful Set 时我们提过 Stateful Set 创建出来的 Pod 都会有相互独立的储存；而讲 Daemon Set 时我们提到 K8s 推荐只在 Daemon Set 的 Pod 中访问宿主机磁盘。但独立的储存具体指什么？除了访问宿主机磁盘以外还有什么其他的储存？</p><p class="py-1">在 Docker 中，我们可以把宿主机磁盘上的一个路径作为一个 Volume 来给容器绑定，或者直接使用 Docker Engine 管理的 Volume 来提供持久化存储或是容器间共享文件。在 K8s 里面也沿用了 Volume 这个概念，可以通过 Mount 绑定到容器内的路径，并通过实现 CSI 的各种引擎来提供更多样的存储。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/kubernetes">#<!-- -->Kubernetes</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/devops">#<!-- -->DevOps</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/docker">#<!-- -->Docker</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/cloud-native">#<!-- -->Cloud Native</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/introduction-for-k8s"><h6 class="PostList_postTitle__vveJr">Kubernetes 入门 （1）</h6><div class="PostList_postDate__z_XQh"><time dateTime="2022-08-13T17:45:31.000Z">2022-08-13</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">我们知道 K8s 利用了容器虚拟化技术。而说到容器虚拟化就要说 Docker 。可是，容器到底是什么？ Docker 又为我们做了些什么？我们又为什么要用 K8s ？</p><p class="py-1">&gt; 要把一个不知道打过多少个升级补丁，不知道经历了多少任管理员的系统迁移到其他机器上，毫无疑问会是一场灾难。 —— Chad Fowler 《Trash Your Servers and Burn Your Code》</p><p class="py-1">&quot;Write once, run anywhere&quot; 是 Java 曾经的口号。 Java 企图通过 JVM 虚拟机来实现一个可执行程序在多平台间的移植性。但我们现在知道， Java 语言并没能实现他的目标，会在操作系统调用、第三方依赖丢失、两个程序间依赖的冲突等各方面出现问题。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/kubernetes">#<!-- -->Kubernetes</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/devops">#<!-- -->DevOps</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/docker">#<!-- -->Docker</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/cloud-native">#<!-- -->Cloud Native</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/why-homogeneous"><h6 class="PostList_postTitle__vveJr">为什么使用在齐次坐标下矩阵乘法能表示点平移？</h6><div class="PostList_postDate__z_XQh"><time dateTime="2022-07-31T15:35:17.000Z">2022-07-31</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">简化了一万倍来说，线性变换主要是在描述符合这两种性质的变换：一是要可加，二是要能数乘。</p><p class="py-1">也就是说，对于空间中所有向量 $$\vec{v_1}, \vec{v_2}$$ ，以及任意数量 $$k_1, k_2$$ ，如果有：</p><p class="py-1">$$</p></div></a></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/graph-for-economics-2"><h6 class="PostList_postTitle__vveJr">图解经济学原理(2)</h6><div class="PostList_postDate__z_XQh"><time dateTime="2022-07-19T23:12:48.000Z">2022-07-19</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">&gt; 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。</p><p class="py-1">&gt; 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。</p><p class="py-1">上一篇讲供给，这一篇讲需求。</p></div></a></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/graph-for-economics-1"><h6 class="PostList_postTitle__vveJr">图解经济学原理(1)</h6><div class="PostList_postDate__z_XQh"><time dateTime="2022-06-28T00:59:41.000Z">2022-06-28</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">&gt; 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。</p><p class="py-1">&gt; 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。</p><p class="py-1">我们先不讲课，先来带个货。</p></div></a></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/use-paste-image-and-vscode-memo"><h6 class="PostList_postTitle__vveJr">完善 Hexo 编写环境，改善文章中使用图片的体验</h6><div class="PostList_postDate__z_XQh"><time dateTime="2022-04-03T21:03:03.000Z">2022-04-03</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">我平时使用 [vscode-memo](https://github.com/svsool/vscode-memo) 插件写笔记，其中插入图片使用 `![[]]` 语法，显示简短，也有较好的预览支持，体验极佳。希望这种特性也能在写 hexo 博客的时候使用。</p><p class="py-1">可能有很多人不熟悉 vscode-memo 这个插件，我先来简单介绍一下。</p><p class="py-1">vscode-memo 定位是一个 knowledge base ，对标的是 [Obsidian.md](https://obsidian.md/) 等软件。其功能包括且不限于：</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/blog">#<!-- -->Blog</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/vscode">#<!-- -->VSCode</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/hexo">#<!-- -->Hexo</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/javascript">#<!-- -->JavaScript</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/create-blog-cicd-by-github"><h6 class="PostList_postTitle__vveJr">用 GitHub Action 自动化构建 Hexo 并发布到 S3</h6><div class="PostList_postDate__z_XQh"><time dateTime="2022-03-26T23:55:08.000Z">2022-03-26</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">GitHub Action 自动化构建发布到 GitHub Pages 大家都见得多了，甚至 Hexo 官方自己都有相关的文档。</p><p class="py-1">但我今天要做的不是发布到 GitHub 这么简单，而是要同时发布到 GitHub 和自己的域名下。</p><p class="py-1">我们需要构建一个 CI/CD 过程。这个过程需要做到以下目标：</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/blog">#<!-- -->Blog</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/github">#<!-- -->GitHub</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/aws">#<!-- -->AWS</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/ci-cd">#<!-- -->CI/CD</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/iac">#<!-- -->IaC</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/devops">#<!-- -->DevOps</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/init-a-new-hexo-project"><h6 class="PostList_postTitle__vveJr">init-a-new-hexo-project</h6><div class="PostList_postDate__z_XQh"><time dateTime="2021-12-12T20:09:13.000Z">2021-12-12</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">最近使用 hexo 搭建了一个博客，并打算挂载在 github page 上。</p><p class="py-1">对之前的那个博客进行替代，并将之前的文章逐渐搬移过来。</p><p class="py-1">使用的[这个主题](https://github.com/Yue-plus/hexo-theme-arknights)功能还是比较完善的。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/blog">#<!-- -->Blog</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/Handy-heap-cheat-sheet"><h6 class="PostList_postTitle__vveJr">如何手撕一个堆</h6><div class="PostList_postDate__z_XQh"><time dateTime="2021-08-28T23:09:14.000Z">2021-08-28</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">在参加如AtCoder等算法竞技，或是刷Leetcode等算法题时，我们总是不可避免地遇到堆这种数据结构。</p><p class="py-1">当然，一般来说我们只要理解堆，知道堆的性质，知道怎么样用堆就足够了。在做题时只需要调用系统类库即可——在参加AtCoder时你甚至不会有时间去自己实现一个堆。</p><p class="py-1">但是，如果哪一天你把编程语言的类库全忘光了，又遇到一题需要频繁求最值的题目——你明知这里要用堆，却又忘记该调用的类名了，咋办？我还真遇到过这问题：三年没刷算法，只能对着一道自己明显会的题干着急，愣是想不起PriorityQueue的名字。这时候，只能自己实现一个堆出来了。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#<!-- -->数据结构</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E7%AE%97%E6%B3%95">#<!-- -->算法</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B">#<!-- -->算法竞赛</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/The-beauty-of-design-parten"><h6 class="PostList_postTitle__vveJr">设计模式之美读书笔记</h6><div class="PostList_postDate__z_XQh"><time dateTime="2021-08-21T08:53:27.000Z">2021-08-21</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">从7个方面评价代码的好坏：</p><p class="py-1">1. 易维护性：根本</p><p class="py-1">2. 可读性：最重要</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">#<!-- -->设计模式</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E7%AC%94%E8%AE%B0">#<!-- -->笔记</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/Sort-algorithm"><h6 class="PostList_postTitle__vveJr">排序算法</h6><div class="PostList_postDate__z_XQh"><time dateTime="2021-01-11T22:57:10.000Z">2021-01-11</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">我们知道排序是算法入门基本功，排序算法有多重要想必也不需要我在这里说明了。因此这一篇就按着我的理解，聊一聊排序算法。</p><p class="py-1">当然我不打算随便弄个什么十大排序算法或是经典排序总结之类响当当的名头，各个算法走马看花一样拉出来遛一遍，最后变得跟网上搜索到的其他讲排序的文章一样换汤不换药。你会发现这篇文章的结构跟在网上搜索到的任何讲排序的文章都有所不同：</p><p class="py-1">在这篇文章里，你会发现你找不到冒泡排序——因为我认为冒泡排序只不过是一种低效率的选择排序。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#<!-- -->数据结构</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E7%AE%97%E6%B3%95">#<!-- -->算法</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%8E%92%E5%BA%8F">#<!-- -->排序</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/python-dict"><h6 class="PostList_postTitle__vveJr">Python字典的实现原理</h6><div class="PostList_postDate__z_XQh"><time dateTime="2020-08-02T00:10:10.000Z">2020-08-02</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">&gt; CPython从3.6开始，字典（dict）不再是无序的了——字典的修改了原先的底层实现，变得能按字典插入的顺序进行遍历。而Python从3.7开始将字典的有序性写入语言特性，不管是Jython、IronPython还是其他Python实现，从3.7开始大家的字典都是有序的了。</p><p class="py-1">以前参加Python相关的面试时，面试官经常都会问一个问题：Python里的字典（dict）是有序的吗？</p><p class="py-1">这自然难不倒我，我也照本宣科地讲：Python的字典底层是用哈希表实现的，在不发生冲突时读写的时间复杂度是O（1），比读写时间复杂度为O（logn）的红黑树要更快。但红黑树可以按下标的大小顺序进行遍历，而Dict遍历时是无序的。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/python">#<!-- -->Python</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#<!-- -->数据结构</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/the-using-in-cpp"><h6 class="PostList_postTitle__vveJr">C++中using关键字的使用</h6><div class="PostList_postDate__z_XQh"><time dateTime="2020-01-28T18:00:00.000Z">2020-01-28</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">1. 引入整个命名空间中的成员</p><p class="py-1">   不引入命名空间时，使用其中变量需要使用`&lt;命名空间名&gt;::&lt;变量名&gt;`的方式使用。</p><p class="py-1">   ```C++</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/c++">#<!-- -->C++</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%9D%82%E6%8A%80">#<!-- -->杂技</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/Building-this-blog"><h6 class="PostList_postTitle__vveJr">搭建博客的过程</h6><div class="PostList_postDate__z_XQh"><time dateTime="2020-01-27T14:00:00.000Z">2020-01-27</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">&gt; “Stop Trying to Reinvent the Wheel.”</p><p class="py-1">参考[BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]，先将[Huxpro][Huxpro]提供的[博客模板仓库][origin_repo]fork出来，`git clone`到本地。</p><p class="py-1">整个网站文件夹大致结构如下：</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%9D%82%E6%8A%80">#<!-- -->杂技</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/blog">#<!-- -->Blog</a></div></div><div class="PostList_postListElement__qi6kp"><a href="/blog-next/articles/hello-world"><h6 class="PostList_postTitle__vveJr">Welcome to Ryo&#x27;s Blog!</h6><div class="PostList_postDate__z_XQh"><time dateTime="2020-01-27T12:00:00.000Z">2020-01-27</time></div><div class="PostList_postAbstract__HtPA1"><p class="py-1">&gt; “Hello World!”</p><p class="py-1">自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。</p><p class="py-1">感谢[Huxpro][Huxpro]提供的博客模板，以及[BruceZhao][BruceZhao]编写的中文ReadMe。</p></div></a><div class="TagsBox_tagsBox__WzhAf py-4 md:py-1"><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%9D%82%E6%8A%80">#<!-- -->杂技</a><a class="tag-word TagsBox_tag__Rk32C" href="/blog-next/tags/%E6%9D%82%E8%B0%88">#<!-- -->杂谈</a></div></div></div></div></div><style data-emotion="css vkdybf">.css-vkdybf{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 0 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 0) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));min-width:0;box-sizing:border-box;}@media (min-width:900px){.css-vkdybf{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 3 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 3) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}@media (min-width:1200px){.css-vkdybf{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 2 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 2) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}</style><div class="MuiGrid-root MuiGrid-direction-xs-row MuiGrid-grid-xs-0 MuiGrid-grid-md-3 MuiGrid-grid-lg-2 css-vkdybf"></div></div><footer class="DefaultLayout_footer__aWV4u"><style data-emotion="css vktxal">.css-vktxal{--Grid-columns:12;--Grid-columnSpacing:0px;--Grid-rowSpacing:0px;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;min-width:0;box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;gap:var(--Grid-rowSpacing) var(--Grid-columnSpacing);width:100%;max-width:80rem;margin-left:auto;margin-right:auto;padding:0.5rem;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}.css-vktxal >*{--Grid-parent-columns:12;}.css-vktxal >*{--Grid-parent-columnSpacing:0px;}.css-vktxal >*{--Grid-parent-rowSpacing:0px;}</style><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-row css-vktxal"><style data-emotion="css 9gdssj">.css-9gdssj{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 0 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 0) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));min-width:0;box-sizing:border-box;}@media (min-width:900px){.css-9gdssj{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 0 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 0) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}@media (min-width:1200px){.css-9gdssj{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 2 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 2) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}</style><div class="MuiGrid-root MuiGrid-direction-xs-row MuiGrid-grid-xs-0 MuiGrid-grid-md-0 MuiGrid-grid-lg-2 css-9gdssj"></div><style data-emotion="css 9h67uz">.css-9h67uz{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 12 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 12) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));min-width:0;box-sizing:border-box;}@media (min-width:900px){.css-9h67uz{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 9 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 9) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}@media (min-width:1200px){.css-9h67uz{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 8 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 8) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}</style><div class="MuiGrid-root MuiGrid-direction-xs-row MuiGrid-grid-xs-12 MuiGrid-grid-md-9 MuiGrid-grid-lg-8 css-9h67uz"><div class="flex flex-row justify-center items-center"><div class="DefaultLayout_footerLeft__Qn_VV">© 2023 Ryo Jerry Yu. All rights reserved.</div><div class="DefaultLayout_footerRight__GlReP"><a title="Twitter" href="https://twitter.com/ryo_okami"><svg class="h-6 w-6 fill-gray-300 hover:fill-white transition-all ease-in-out mx-1 md:mx-2" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a title="GitHub" href="https://github.com/RyoJerryYu"><svg class="h-6 w-6 fill-gray-300 hover:fill-white transition-all ease-in-out mx-1 md:mx-2" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a title="Pixiv" href="https://www.pixiv.net/users/9159893"><svg class="h-6 w-6 fill-gray-300 hover:fill-white transition-all ease-in-out mx-1 md:mx-2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.935 0A4.924 4.924 0 0 0 0 4.935v14.13A4.924 4.924 0 0 0 4.935 24h14.13A4.924 4.924 0 0 0 24 19.065V4.935A4.924 4.924 0 0 0 19.065 0zm7.81 4.547c2.181 0 4.058.676 5.399 1.847a6.118 6.118 0 0 1 2.116 4.66c.005 1.854-.88 3.476-2.257 4.563-1.375 1.092-3.225 1.697-5.258 1.697-2.314 0-4.46-.842-4.46-.842v2.718c.397.116 1.048.365.635.779H5.79c-.41-.41.19-.65.644-.779V7.666c-1.053.81-1.593 1.51-1.868 2.031.32 1.02-.284.969-.284.969l-1.09-1.73s3.868-4.39 9.553-4.39zm-.19.971c-1.423-.003-3.184.473-4.27 1.244v8.646c.988.487 2.484.832 4.26.832h.01c1.596 0 2.98-.593 3.93-1.533.952-.948 1.486-2.183 1.492-3.683-.005-1.54-.504-2.864-1.42-3.86-.918-.992-2.274-1.645-4.002-1.646Z"></path></svg></a></div></div></div><style data-emotion="css vkdybf">.css-vkdybf{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 0 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 0) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));min-width:0;box-sizing:border-box;}@media (min-width:900px){.css-vkdybf{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 3 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 3) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}@media (min-width:1200px){.css-vkdybf{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-flex-basis:auto;-ms-flex-preferred-size:auto;flex-basis:auto;width:calc(100% * 2 / var(--Grid-parent-columns) - (var(--Grid-parent-columns) - 2) * (var(--Grid-parent-columnSpacing) / var(--Grid-parent-columns)));}}</style><div class="MuiGrid-root MuiGrid-direction-xs-row MuiGrid-grid-xs-0 MuiGrid-grid-md-3 MuiGrid-grid-lg-2 css-vkdybf"></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"pathMapping":{"filePath":"public/content/articles/2025-09-30-from-linear-algebra-to-analytical-machanics-2.md","pagePath":"/articles/from-linear-algebra-to-analytical-machanics-2","slug":"from-linear-algebra-to-analytical-machanics-2"},"meta":{"content":"\u003e [!info]\n\u003e 这是《从线性代数到分析力学》上下两篇中的下篇，上篇为[[2025-09-29-from-linear-algebra-to-analytical-machanics-1|从线性代数到分析力学]]。\n\n## 极值问题到变分问题\n\n最早，欧拉研究总结了短程线问题、等周问题等一大类类似“求取得极值时的曲线”的问题，并提出能使用了后来被称为“欧拉-拉格朗日方程”的通用的方法来求解这类问题。可惜此时欧拉的推导过程使用了大量分析与几何结合的手段，十分复杂也缺乏严谨，欧拉自己也对此并不满意。[^长河劫变分法]\n\n后来，拉格朗日引入了变分符号 $\\delta$ 来表示函数的“微小变化”，将求极值的问题转化为解微分方程的问题，使推导过程更加严谨。拉格朗日在欧拉-拉格朗日方程的基础上继续完善，发明了**变分法**——处理泛函极值问题的纯分析方法，并利用变分法提出了最小作用量原理的正确形式。[^长河劫变分法][^长河劫分析力学]\n\n[^长河劫变分法]: [【数学史】泛函与变分法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1qx3gzvEGS/?vd_source=ba01a1932b530e32e2576726fdda41d7)\n[^长河劫分析力学]: [【科学史】牛顿的未竟之路——分析力学_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1frbXzKEQj/?vd_source=ba01a1932b530e32e2576726fdda41d7)\n\n可以说，变分法，乃至整个泛函分析学科，最初都是为了研究最小作用量这种泛函取极值的问题而发明出来的。\n\n### 函数的极值问题\n\n在研究泛函的极值问题之前，我们先来看看函数的极值我们是怎么求解的。\n\n\u003e [!info] 什么是极值\n\u003e 以极小值为例，极大值亦然。简单来说，极小值点就是光滑函数在某一局部范围内的最小值点。严格来说：\n\u003e \n\u003e 如果 $\\vec{x_{0}}$ 是光滑函数 $f(\\vec{x})$ 的一个极小值点，那么，对于某一个足够小的范围 $0\u003c||\\mathrm{d}\\vec{x}||\u003c\\epsilon$ ，在这范围内的所有函数值 $f(\\vec{x_{0}}+\\mathrm{d}\\vec{x})$ ，都有 $f(\\vec{x_{0}})\u003cf(\\vec{x_{0}}+\\mathrm{d}\\vec{x})$ 。\n\n对于多元单值函数 $f(\\vec{x})$ ，有 $\\mathrm{d}f(\\vec{x}) = D_{f}\\mathrm{d}\\vec{x}$ 。当 $f(\\vec{x})$ 取得极值时，会有 $D_{f} = \\mathbf{0}$ ，即 $\\frac{ \\partial f }{ \\partial x_{1} }=0$ , $\\frac{ \\partial f }{ \\partial x_{2} }=0$ , ……, $\\frac{ \\partial f }{ \\partial x_{n} }=0$ 。\n\n\u003e [!info] 为什么？\n\u003e 因为如果 $D_{f}$ 不为零，则意味着在某一个方向上，给 $\\vec{x}$ 一个微小的变化 $\\mathrm{d}\\vec{x}$ ，函数值 $f(\\vec{x}+\\mathrm{d}\\vec{x})$ 会比 $f(\\vec{x})$ 要更小（大），即 $f(\\vec{x})$ 不是局部的最小（大）值。\n\n这个结论是一个必要条件，但不是充分条件，因为会出现 $f(x) = x^3$ 中 $x=0$ 时的情况。另外这个结论适用的前提是函数 $f(\\vec{x})$ 足够光滑。\n\n虽然有如此多的适用前提，但正如背景故事中提到，最早欧拉与拉格朗日都是为了研究物理问题而发明了变分法。而物理问题中的函数基本都能保证光滑，因此求极值的这个条件也足够实用。\n\n### 泛函的极值问题\n\n泛函的极值问题——也就是**变分问题**，是指求在泛函 $J[y]$ 在取得极值时，求此时的输入函数 $y^*$ 的问题。\n\n这样说可能比较抽象，我们举一个具体的🌰：过两点 $A(x_{a}, y_{a})$ 与 $B(x_{b}, y_{b})$ 之间，到底走哪一条路能使走的路程最短？\n\n过两点之间的一条路，我们都能理解为符合 $y(x_{a})=y_{a}$ 且 $y(x_{b})=y_{b}$ 的一个函数 $y(x)$ 。而过两点的路程就是这个函数在区间 $(x_{a}, x_{b})$ 内的路径积分：\n\n$$\nL[y] = \\int_{a}^b \\sqrt{ 1+[y'(x)]^2 }\\mathrm{d}x\n$$\n\n那求路径最短的那一条路，就是求当 $L[y]$ 取得极小值 $L[y^*]$ 时对应的那个输入函数 $y^*(x)$ 。\n\n\u003e [!info] 泛函极值的严格定义\n\u003e 以极小值为例。如果 $y^* (x)$ 是泛函 _J[y]_ 的一个极小值点，那么，对于某个足够小的范围 $0\u003c||\\delta y||\u003c\\epsilon$ ，在这范围内所有的泛函值 $J[y^*+\\delta y]$ ，都有 $J[y^*] \u003c J[y^*+\\delta y]$ 。\n\n与函数的极值问题类似，光滑泛函在 $y^*(x)$ 处取得极值时的必要条件，是对于所有方向上的变分 $\\delta y(x)$ 都有：\n\n$$\n\\delta J[y^*;\\delta y] = 0\n$$\n\n\u003e [!info] 简单证明\n\u003e \n\u003e 假设存在某个特定的容许变分 *η(x)*，使得 $δJ [y*; η] ≠ 0$ ，例如 $δJ [y*; η] = c \u003e 0$ 。\n\u003e 根据方向导数的定义，对于足够小的正数 $h$ ，我们有：\n\u003e \n\u003e $$\n\u003e \\frac{J[y^* + h \\eta] - J[y^*]}{h} \\approx c \u003e 0\n\u003e $$\n\u003e \n\u003e 这意味着 $J[y* + h η] \u003e J[y*]$ 。\n\u003e 现在考虑反方向的扰动 $-η(x)$ 。由于定义是线性的，$δJ [y*; -η] = -δJ [y*; η] = -c \u003c 0$ 。\n\u003e 那么，对于足够小的 $h$ ，我们有：\n\u003e \n\u003e $$\n\u003e \\frac{J[y^* - h \\eta] - J[y^*]}{h} \\approx -c \u003c 0\n\u003e $$\n\u003e \n\u003e 这意味着 $J[y* - h η] \u003c J[y*]$ 。\n\u003e \n\u003e 因此，在 $y^* (x)$ 的任意小邻域内（即无论 $||δy||$ 多小），我们总可以找到使 $J$ 值更大（ $y + hη$ ）和更小（$y - hη$）的点。这与 $y^*$ 是局部极值点的假设矛盾。所以最初的假设（存在某个 $η$ 使 $δJ ≠ 0$）是错误的。证毕。\n\n### 变分法\n\n很好，结论很漂亮，可是我们具体要怎么做才能解变分问题呢？\n\n我们以上面已经反复提到的，求两点间最短路径的问题为例。\n\n这个问题很简单，就连小学生都知道最短的路径是走直线。可是这又没那么简单，毕竟这是一个变分问题，我们要从变分法的角度来去解它。\n\n\u003e [!info] 重申一下问题\n\u003e 过两点 $A(a, y_{a})$ 与 $B(b, y_{b})$ 之间的每条路，都是符合 $y(a)=y_{a}$ 且 $y(b)=y_{b}$ 的一个函数 $y(x)$ 。而过两点的路程就是这个函数在区间 $(a, b)$ 内的路径积分：\n\u003e \n\u003e $$\n\u003e L[y] = \\int_{a}^b \\sqrt{ 1+[y'(x)]^2 }\\mathrm{d}x\n\u003e $$\n\u003e \n\u003e 那求路径最短的那一条路，就是求当 $L[y]$ 取得极小值 $L[y^*]$ 时对应的那个输入函数 $y^*(x)$ 。\n\n假设泛函 $L[y]$ 在 $y^*(x)$ 处取得极小值 $L[y^*]$ 。我们对 $y^*(x)$ 施加一个微小扰动： \n\n$$\nY(x) = y^*(x) + \\delta y(x)\n$$\n\n由于 $y^*(x)$ 与 $y^*(x)+\\delta y(x)$ 都符合 $y(a)=y_{a}$ 且 $y(b)=y_{b}$ ，那么我们易知，这个微小扰动 $\\delta y(x)$ 需要符合：\n\n$$\n\\delta y(a)=\\delta y(b) = 0\n$$\n\n我们令 $\\eta(x)$ 为符合 $\\eta(a)=\\eta(b)=0$ 的任意函数，那么在 $\\eta$ 方向上的变分 $\\delta y$ 就可表示为 $h\\eta$ ，其中 $h$ 为一个接近 0 的实数。\n\n\u003e [!note]\n\u003e 函数空间也是向量空间，函数也是无穷维向量，函数的方向可以类比向量的方向。\n\n我们将 $Y(x)$ 对 $x$ 求导，由于求导运算的加减法法则与数乘法则（或者也可以说是求导算子的线性性），可得：\n\n$$\nY'(x) = y^{*\\prime}(x) + \\delta y'(x) = y^{*\\prime}(x) + h\\eta'(x)\n$$\n\n我们把经过微小扰动后的 $y^*(x)+\\delta y(x)= y^*(x)+h\\eta(x)$ 代入泛函 $L[y]$ ：\n\n$$\nL[y^*+h\\eta] =  \\int_{a}^b \\sqrt{ 1+[y^{*\\prime}(x)+h\\eta'(x)]^2 }\\mathrm{d}x\n$$\n\n固定住微小扰动的方向 $\\eta(x)$ ，此时泛函的输出值就成了关于 $h$ 的一元单值函数 $\\Phi(h)$：\n\n$$\n\\Phi(h) = L[y^*+h\\eta] = \\int_{a}^b \\sqrt{ 1+[y^{*\\prime}(x)+h\\eta'(x)]^2 }\\mathrm{d}x\n$$\n\n由于 $L[y]$ 在 $y^*$ 处取得极值，则有对于任意的扰动方向 $\\eta(x)$ ，都有 $\\Phi(h)$ 在 $h=0$ 处取得极值：\n\n$$\n\\delta L[y^*;\\delta y] = \\frac{d}{dh} \\Phi(h) \\Big|_{h=0}  = 0\n$$\n\n我们计算 $\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}h}$ ：\n\n$$\n\\begin{align}\n\\frac{\\mathrm{d}}{\\mathrm{d}h}\\Phi(h)  \u0026 = \\frac{\\mathrm{d}}{\\mathrm{d}h}\\int_{a}^b \\sqrt{ 1+[y^{*\\prime}(x)+h\\eta'(x)]^2 }\\mathrm{d}x \\\\ \\\\\n \u0026 = \\int_{a}^{b} \\frac{ \\partial }{ \\partial h } (\\sqrt{ 1+[y^{*\\prime}(x)+h\\eta'(x)]^2 } ) \\mathrm{d}x  \u0026 （莱布尼茨法则） \\\\\n \u0026 = \\int_{a}^{b} \\left(\\frac{1}{2\\sqrt{ 1+[y^{*\\prime}(x)+h\\eta'(x)]^2 }} \\times 2[y^{*\\prime}(x)+h\\eta'(x)] \\times \\eta'(x) \\right) \\mathrm{d}x  \u0026 （链式法则） \\\\\n \u0026 = \\int_{a}^{b} \\eta'(x) \\left(\\frac{y^{*\\prime}(x)+h\\eta'(x)}{\\sqrt{ 1+[y^{*\\prime}(x)+h\\eta'(x)]^2 }}  \\right) \\mathrm{d}x\n\\end{align}\n$$\n\n由于 $\\Phi(h)$ 在 $h=0$ 处取得极值，代入 $h=0$ 与 $\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}h} = 0$ ：\n\n$$\n\\begin{align}\n\\frac{\\mathrm{d}}{\\mathrm{d}h}\\Phi(h) \\Big|_{h=0}  \u0026 = \\int_{a}^{b} \\eta'(x) \\left(\\frac{y^{*\\prime}(x)+h\\eta'(x)}{\\sqrt{ 1+[y^{*\\prime}(x)+h\\eta'(x)]^2 }}  \\right) \\mathrm{d}x \\Big|_{h=0} \\\\\n \u0026 = \\int_{a}^{b} \\eta'(x) \\left(\\frac{y^{*\\prime}(x)}{\\sqrt{ 1+[y^{*\\prime}(x)]^2 }}  \\right) \\mathrm{d}x  \\\\\n \u0026 = \\left[ \\eta(x) \\left( \\frac{y^{*\\prime}(x)}{\\sqrt{ 1+[y^{*\\prime}(x)]^2 }}\\right)\\right]_{a}^b - \\int_{a}^{b} \\eta(x) \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left(\\frac{y^{*\\prime}(x)}{\\sqrt{ 1+[y^{*\\prime}(x)]^2 }}  \\right) \\mathrm{d}x  \u0026 （分部积分消去 \\eta'） \\\\\n \u0026 = - \\int_{a}^{b} \\eta(x) \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left(\\frac{y^{*\\prime}(x)}{\\sqrt{ 1+[y^{*\\prime}(x)]^2 }}  \\right) \\mathrm{d}x  \u0026 （\\eta(a) = \\eta(b) = 0） \\\\\n \u0026 = 0\n\\end{align}\n$$\n\n\u003e [!info]- 为什么需要消去 $\\eta'(x)$ ？\n\u003e \n\u003e 对于任意扰动的方向 $\\eta(x)$ ，都有一个需要遵守的约束 $\\eta(a) = \\eta(b) = 0$ 。因此，实际上 $\\eta'(x)$ 有一个很强的约束：\n\u003e \n\u003e $$\n\u003e \\int_{a}^{b} \\eta'(x)\\mathrm{d}x = \\eta(a) - \\eta(b) = 0\n\u003e $$\n\u003e \n\u003e 这意味着 $\\eta'(x)$ 只能代表那些“平均值为零”的函数，而不能代表所有可能函数，因此也不能直接用 $\\eta'(x)$ 来适用变分法基本引理。\n\u003e \n\u003e 比如：被积函数中的部分  $f(x) = \\frac{(y^*)'(x)}{\\sqrt{1 + [(y^*)'(x)]^2}}$ 是一个非零常数（实际上就是这次的情况）。那么积分变为：\n\u003e $$\n\u003e \\int_{a}^{b} \\eta'(x) \\cdot C \\, dx = C \\int_{a}^{b} \\eta'(x) \\, dx = C \\cdot [\\eta(x_b) - \\eta(x_a)] = 0.\n\u003e $$\n\u003e \n\u003e 这说明，如果 $f(x)$ 是常数，积分总是为零，无论 $C$ 是否为零。但如果直接套用变分法基本引理，会推出 $f(x) \\equiv 0$ ，与实际结果谬之千里。\n\n在你的证明中，直接得出结论 \\(f(x) \\equiv 0\\) 是错误的，因为它忽略了 \\(\\eta'(x)\\) 的约束。正确的做法是使用分部积分，将问题转化为更标准的形式。\n\n由于当泛函 $L[y]$ 取极值时，这个等式对所有扰动的方向 $\\eta(x)$ 都成立，由变分法基本引理，有以下等式在区间 $(a,b)$ 上恒成立：\n\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x} \\left(\\frac{y^{*\\prime}(x)}{\\sqrt{ 1+[y^{*\\prime}(x)]^2 }}  \\right) \\equiv 0\n$$\n\n也即，以下微分方程在区间 $(a,b)$ 上恒成立：\n\n$$\n\\frac{y^{*\\prime}(x)}{\\sqrt{ 1+[y^{*\\prime}(x)]^2 }} \\equiv C\n$$\n\n这下看懂了， $y^{*\\prime}(x)$ 不就是常数嘛！\n\n$$\ny^{*\\prime}(x) = \\pm \\frac{C}{\\sqrt{ 1-C^2 }}= k\n$$\n\n$y^*(x)$ 的一阶导为常数，那 $y^*(x)$ 就为一次函数。得：\n\n$$\n\\begin{align}\n \u0026 y^*(x) = kx+b\n\\end{align}\n$$\n\n其中， $k$， $b$ 为能使 $y^*(a) = y_{a}$ 且 $y^*(b) = y_{b}$ 的值。\n\n\n### 欧拉-拉格朗日方程\n\n叽里咕噜说了一大堆，结果只证明了连小学生都懂的两点之间直线最短！这欧拉行不行啊。\n\n实际上，欧拉与拉格朗日所做的工作，并不是证明了一个问题，而是总结出了一大堆类似问题的通用解决方法——欧拉-拉格朗日方程。对于如下形式的泛函：\n\n$$\nJ[y] = \\int_{a}^{b} F(x,y(x), y'(x)) \\, \\mathrm{d}x\n$$\n\n可以直接套用欧拉-拉格朗日方程，求得当 $J[y]$ 取得极值时的函数 $y^*(x)$ 。其中 $F$ 为一个已知的，关于三个变量 $x,y,y'$ 的三元函数。\n\n\u003e [!note]\n\u003e 在求路径最短的问题中，对应的 $F$ 为 $F(x,y,y')=\\sqrt{ 1+(y')^2 }$ 。此时的 $F$ 只与 $y'$ 有关，与 $x$ 、 $y$ 都不直接相关。\n\n接下来我们仿照之前推导出过两点间直线最短的方式，推导出欧拉-拉格朗日方程。\n\n假设泛函 $J[y]$ 取得极值时的函数为 $y^*(x)$ 。我们令 $\\eta(x)$ 为符合 $\\eta(a)=\\eta(b)=0$ 的任意函数，那么在 $\\eta$ 方向上的变分 $\\delta y$ 就可表示为 $h\\eta$ ，其中 $h$ 为一个接近 0 的实数。\n\n对 $y^*(x)$ 施加一个微小扰动，然后对 $x$ 求导，分别可得： \n\n$$\n\\begin{align}\ny  \u0026 = y^* + \\delta y = y^* + h\\eta \\\\\ny' \u0026 = y^{*\\prime} + \\delta y' = y^{*\\prime} + h\\eta'\n\\end{align}\n$$\n\n代入泛函 $J[y]$ ，固定住微小扰动的方向 $\\eta(x)$ ，得到一个关于 $h$ 的一元单值函数 $\\Phi(h)$：\n\n$$\n\\Phi(h) = J[y^*+h\\eta] = \\int_{a}^{b} F(x, y^*+h\\eta,y^{*\\prime} + h\\eta') \\, dx \n$$\n\n\u003e [!note]\n\u003e 对应到求路径最短的问题中，就是 $\\Phi(h) = \\int_{a}^b \\sqrt{ 1+(y^{*\\prime}+h\\eta')^2 }\\mathrm{d}x$ 。\n\n由于 $J[y]$ 在 $y^*$ 处取得极值，则有对于任意的扰动方向 $\\eta(x)$ ，都有 $\\Phi(h)$ 在 $h=0$ 处取得极值：\n\n$$\n\\delta J[y^*;\\delta y] = \\frac{d}{dh} \\Phi(h) \\Big|_{h=0}  = 0\n$$\n\n展开计算：\n\n$$\n\\begin{align}\n\\delta J[y^*;\\delta y] \u0026 = \\frac{\\mathrm{d}\\Phi}{\\mathrm{d}h}\\Big|_{h=0} \\\\\n \u0026 = \\frac{\\mathrm{d}}{\\mathrm{d}h} \\int_{a}^{b} F(x, y^*+h\\eta,y^{*\\prime} + h\\eta') \\, \\mathrm{d}x \\Big|_{h=0} \\\\\n \u0026 = \\int_{a}^{b} \\frac{ \\partial }{ \\partial h } F(x, y^*+h\\eta,y^{*\\prime} + h\\eta') \\, \\mathrm{d}x \\Big|_{h=0} \u0026 （莱布尼茨法则） \\\\\n \u0026 = \\int_{a}^{b} \\left( \\frac{ \\partial F }{ \\partial y } \\eta+\\frac{ \\partial F }{ \\partial y' } \\eta' \\right) \\, \\mathrm{d}x \u0026 （链式法则） \\\\\n \u0026 = \\int_{a}^{b} \\frac{ \\partial F }{ \\partial y } \\eta \\, \\mathrm{d}x + \\left[\\frac{ \\partial F }{ \\partial y' } \\eta \\right]_{a}^b - \\int_{a}^{b} \\eta\\frac{\\mathrm{d}}{\\mathrm{d}x}\\frac{ \\partial F }{ \\partial y' }  \\mathrm{d}x \u0026 （将含 \\eta' 项进行分部积分，消除 \\eta' 项） \\\\\n \u0026 = \\int_{a}^{b} \\eta \\left( \\frac{ \\partial F }{ \\partial y } - \\frac{\\mathrm{d}}{\\mathrm{d}x} \\frac{ \\partial F }{ \\partial y' } \\right) \\mathrm{d}x  \u0026 （\\eta(a)=\\eta(b)=0，消去 \\left[\\frac{ \\partial F }{ \\partial y' } \\eta \\right]_{a}^b 项） \\\\\n \u0026 = 0\n\\end{align}\n$$\n\n\u003e [!note]\n\u003e - 对应到求路径最短的问题中，就是 $\\int_{a}^{b} \\eta \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left(\\frac{y^{*\\prime}}{\\sqrt{ 1+(y^{*\\prime})^2 }}  \\right) \\mathrm{d}x = 0$ 。\n\n这对于任意扰动方向 $\\eta(x)$ 都成立，由变分法基本引理，得：\n\n$$\n\\boxed{\\frac{ \\partial F }{ \\partial y } -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\frac{ \\partial F }{ \\partial y' } = 0}\n$$\n\n这就是欧拉-拉格朗日方程。\n\n\u003e [!info] 总结一下，就是：\n\u003e 对于如下形式的泛函：\n\u003e \n\u003e $$\n\u003e J[y] = \\int_{a}^{b} F(x,y(x), y'(x)) \\, \\mathrm{d}x\n\u003e $$\n\u003e \n\u003e 当 $J[y]$ 取得极值时，有：\n\u003e \n\u003e $$\n\u003e \\frac{ \\partial F }{ \\partial y } -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\frac{ \\partial F }{ \\partial y' } = 0\n\u003e $$\n\n我们试着套用欧拉-拉格朗日方程来求解路径最短问题。因为路径最短的问题中 $F=\\sqrt{ 1+(y')^2 }$ 与 $y$ 不直接相关，所以 $\\frac{ \\partial F }{ \\partial y } = 0$ 被直接略去。而 $\\frac{ \\partial F }{ \\partial y' }$ 项为：\n\n$$\n\\frac{ \\partial F }{ \\partial y' } = \\frac{y'}{\\sqrt{ 1+(y')^2 }}\n$$\n\n代入得：\n\n$$\n\\begin{align}\n\\frac{\\mathrm{d}}{\\mathrm{d}x} \\frac{y'}{\\sqrt{ 1+(y')^2 }} \u0026 = 0 \\\\\n\\frac{y'}{\\sqrt{ 1+(y')^2 }} \u0026 = C \\\\\ny' \u0026 = \\pm \\frac{C}{\\sqrt{ 1-C^2 }} \\\\\ny'  \u0026 = k\n\\end{align}\n$$\n\n也可解得  $y^*(x)$ 为一次函数。\n\n## 分析力学\n\n上面几章都是数学，进入到最后一章终于要开始讲物理了，路漫漫其修远兮。\n\n我们在介绍数学的时候，一般会从更基础、更抽象、更本质的东西开始讲，因为这个顺序逻辑层层递进，会比较好理解。然而一般来说，越本质、越基础的东西在时间上就越晚被发明。因为在历史上一般都是先研究明显、表层的东西，然后才慢慢深入、挖掘出表象背后的本质。\n\n\u003e [!note]\n\u003e 牛顿和莱布尼茨在 17 世纪就发明了微积分，拉格朗日在 18 世纪就已经发明了变分法。然而作为微积分基础的线性代数和极限的严格定义直到 19 世纪才被系统地整理成理论。\n\n介绍物理的顺序会与介绍数学的顺序有很大不一样。物理是用来描述现实世界里的规律的，越是本质、抽象的东西平时就越少接触。没有一个现实里的模型来对照，也就越难理解。如果一上来就讲量子力学，然后才是大数定律回归宏观世界，那谁都遭受不住呀。\n\n反而，物理随着历史的脉络发展，是有一定的逻辑顺序关联的，内容也可以由浅至深。顺着物理史来学，虽然会绕一些弯路，但逻辑脉络上反而更清晰。\n\n接下来我们就顺着历史发展的脉络，来一步一步引入分析力学。\n\n### 虚功原理\n\n搞过物理竞赛的同学可能 DNA 要动了，这不就是静力学大题的必杀技——虚位移原理嘛！\n\n虚位移原理最早由约翰·伯努利（Johann Bernoulli）在1717年提出，后来也叫虚功原理，是同一个原理的两种表述。\n\n虚位移原理简单来说就是：如果一个系统处于惯性状态，运动轨迹为 $\\vec{x}$ 是关于时间 $t$ 的函数。给这个系统一个微小的变化“虚位移” $\\delta \\vec{x}$ ，所有力做功的总和为零：\n\n$$\n\\delta W = \\sum_{i}\\vec{F_{i}} \\cdot \\delta \\vec{r} = 0\n$$\n\n由于点乘运算双线性，而又由于 $\\delta\\vec{x}$ 是任意方向的微小位移，实际上上式完全等价于：\n\n$$\n\\sum_{i} \\vec{F_{i}} = 0\n$$\n\n好家伙，这不就是牛顿第一定律嘛，系统处于惯性状态时合力为零。又绕回来了。实际上，虚位移原理与受力平衡时的牛顿力学原理就是完全等价的。\n\n### 惯性力和达朗贝尔原理\n\n可是，虚位移原理只适用于静力学问题。当物体受力不平衡，处于非惯性运动时，又该怎么办呢？\n\n达朗贝尔（Jean le Rond d'Alembert）翻开历史堆（其实也就 50 多年前），发现牛顿提出过一种假象的力——**惯性力**：比如做圆周运动的物体，不就像是受到了惯性力的作用吗。\n\n那感情好呀，通过引入这种假想的惯性力，动力学问题不就相当于一个所有受力加上惯性力受力平衡的静力学问题了吗：\n\n$$\n\\sum_{i}\\vec{F_{i}} - m\\vec{a} = 0\n$$\n\n于是达朗贝尔在1743年提出了达朗贝尔原理：引入假想的惯性力，假设这种惯性力也能做虚功。仿照虚位移原理，给受力不平衡的动力学系统一个虚位移 $\\delta \\vec{x}$ ，所有力加上惯性力所做功的总和为零：\n\n$$\n\\sum_{i} \\vec{F_{i}} \\cdot \\delta \\vec{r} - m\\vec{a}\\cdot\\delta \\vec{r}=0\n$$\n\n实际上，达朗贝尔原理与牛顿第二定律也完全等价。\n\n### 最小作用量原理\n\n最小作用量原理最早是由莫佩尔蒂（Pierre-Louis Maupertuis）在1744年提出的。在当年，人类在物理学方面的成就，主要集中在了几何光学和力学这两大类。\n\n然而当年的力学理论，来来去去也主要就是牛爵爷那一套。而几何光学的理论却有两套：一套是由光的直线传播、反射定律、折射定律为基础的局部描述版本，另一套是费马的“光总是沿总时间最短的路径传播“，也就是整体描述版本。\n\n\u003e [!note]\n\u003e 费马的整体描述版本中，光就像是开了天眼一样，出发前会先用变分法算一通，找到用时最短的路径。哇，比我们大多数本科生牛逼多了。\n\u003e \n\u003e （不过费马那年代还远没有变分法提出的时候呀。）\n\n力学与几何光学差别太大啦，莫佩尔蒂强迫症都要犯啦！于是他在《论此前看似不相容的各种自然规律的统一》中就提出几何光学与力学可以用一个统一的底层原理来解释——最小作用量原理：自然界中的运动规律，都是要把某个叫做“作用量”的东西取到最小。\n\n\u003e [!note]\n\u003e 好了，莫佩尔蒂的故事到这就结束了，后面没他的事了。\n\u003e \n\u003e 为什么？因为他提出的这个“作用量”，是：\n\u003e \n\u003e $$\n\u003e 质量\\times速度\\times路程\n\u003e $$\n\u003e \n\u003e 这瞎乘一通都什么跟什么呀，也没给解释，说服得了谁呀。\n\n莫佩尔蒂是欧拉的师弟，欧拉与拉格朗日当时已经发明欧拉-拉格朗日方程了。当时欧拉就一直鼓励拉格朗日建立一种正确的，最小作用量形式的力学理论。\n\n拉格朗日坚信，正确的最小作用量形式的力学理论，应当是一种与牛顿力学完全等价的，基于极值形式的力学理论。于是他就从历史堆里翻找，看看有没有能用的类似结论。\n\n他首先找到的是自己师祖约翰·伯努利提出的虚位移原理：\n\n$$\n\\delta W = \\sum_{i}\\vec{F_{i}} \\cdot \\delta \\vec{r} = 0\n$$\n\n某个东西的变化量等于零？嗯……此时有一道激光从屏幕左上角往右下角穿过，还要配上经典的柯南 BGM 。这不就像是某种泛函取极值时的结论吗！？作为欧拉-拉格朗日方程的发明者之一，这可太熟悉不过了！\n\n外力对物体做的功，代表了环境与物体间能量的转换，从形式上来看这个能量要只与位移有关。只与位移有关的能量，不就是势能嘛。\n\n所以拉格朗日找到了这样的一个势函数 $-V(\\vec{r})$ ，他的变分就是虚位移下的做功：\n\n$$\n\\sum_{i}\\vec{F_{i}}\\cdot\\delta \\vec{r} = - \\frac{ \\partial V }{ \\partial \\vec{r} } \\cdot \\delta \\vec{r} = -\\delta V\n$$\n\n这个变分等于零，也就意味着势函数 $-V(\\vec{r})$ 取极值。也就是说在受力平衡时，这个取到最小的作用量就是势函数 $-V(\\vec{r})$ 。\n\n可是，如果仅有虚位移原理作基础，这样发展出来的最小作用量原理只能用于处理静力学呀。要是受力不平衡怎么办？于是拉格朗日继续找，又找到他好友达朗贝尔在前不久提出的达朗贝尔原理：\n\n$$\n\\sum_{i} \\vec{F_{i}} \\cdot \\delta \\vec{r} - m\\vec{a}\\cdot\\delta \\vec{r}=0\n$$\n\n我们给这个假想的惯性力项也找一个对应的“势函数”不就好了？可是哪里会有既与位移有关，又与加速度有关的能量呀！\n\n机械运动里除了势能项，自然就剩下动能项了。于是拉格朗日试了试动能函数：\n\n$$\nT(\\dot{\\mathbf{r}}) = \\frac{1}{2}m\\dot{\\mathbf{r}}^2\n$$\n\n\u003e [!note]\n\u003e 这里变量头上的一点代表一阶导数，是当年牛爵爷发明的微分符号。 $\\dot{\\mathbf{r}}$ 表示的就是速度 $\\vec{v}$ 。如果头上有两个点代表二阶导数，即 $\\ddot{\\mathbf{r}} = \\vec{a}$ 。分析力学在力学符号的表示这一方面还是沿用了牛爵爷的符号。\n\u003e \n\u003e 诶不对呀，拉格朗日你不是大陆学派的吗？（莱布尼茨-约翰伯努利-欧拉-拉格朗日四人是一脉相承的师徒关系。）怎么用牛顿版本的微积分符号？你个浓眉大眼的也搞叛变啦？\n\u003e \n\u003e 其实主要还是，莱布尼茨那套微积分符号虽然能表现出微积分更深层的含义，在分析学中也更通用，但写起来却太繁琐啦！如果完全只使用莱布尼茨的积分符号，拉格朗日方程就要写成：\n\u003e \n\u003e $$\n\u003e -\\frac{ \\partial V }{ \\partial \\vec{r} } -\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\frac{\\mathrm{d}}{\\mathrm{d}t}\\vec{r} } = 0\n\u003e $$\n\u003e \n\u003e 看着就能吓死人啦。\n\u003e \n\u003e 拉格朗日在分析力学这一块的物理量沿用牛顿的符号，一来能使公式更简洁清晰，二来物理符号一以贯之，在物理研究中不至于太突兀。\n\n将动能函数稍加变形，就有：\n\n$$\nm\\vec{a}\\cdot\\delta \\vec{r} \n= \\frac{\\mathrm{d}}{\\mathrm{d}t}m \\dot{\\mathbf{r}} \\cdot\\delta \\vec{r} \n= \\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\dot{\\mathbf{r}} } \\cdot\\delta \\vec{r}\n$$\n\n哎呀，这跟动能的变分可有点差别呀。\n\n\u003e [!info]- 惯性力做功并不直接等于动能变分\n\u003e \n\u003e 对于动能 $T = \\frac{1}{2} m \\dot{\\mathbf{r}}^2$ ，动能的变分 $\\delta T$ 是对速度的变分，即：\n\u003e \n\u003e $$\n\u003e \\delta T = \\frac{\\partial T}{\\partial \\dot{\\mathbf{r}}} \\cdot \\delta \\dot{\\mathbf{r}} = m \\dot{\\mathbf{r}} \\cdot \\delta \\dot{\\mathbf{r}}.\n\u003e $$\n\u003e \n\u003e 在变分法中，变分 $\\delta \\dot{\\mathbf{r}}$ 与虚位移 $\\delta \\mathbf{r}$ 相关，即 $\\delta \\dot{\\mathbf{r}} = \\frac{d}{dt} (\\delta \\mathbf{r})$ 。因此：\n\u003e \n\u003e $$\n\u003e \\delta T = m \\dot{\\mathbf{r}} \\cdot \\frac{d}{dt} (\\delta \\mathbf{r}).\n\u003e $$\n\u003e \n\u003e 与惯性力的虚功 $m \\ddot{\\mathbf{r}} \\cdot \\delta \\mathbf{r}$ 并不相同，除非在特殊情况下（如匀速运动或特定边界条件），否则一般不等。\n\u003e \n\u003e 但是，在对时间积分后，两者又有联系：\n\u003e \n\u003e $$\n\u003e \\int \\delta T \\, dt = \\int m \\dot{\\mathbf{r}} \\cdot \\delta \\dot{\\mathbf{r}} \\, dt\n\u003e $$\n\u003e \n\u003e 使用分部积分，并假设端点固定（即 $\\delta \\mathbf{r}$ 在端点为零），可得：\n\u003e \n\u003e $$\n\u003e \\int m \\dot{\\mathbf{r}} \\cdot \\delta \\dot{\\mathbf{r}} \\, dt = - \\int m \\ddot{\\mathbf{r}} \\cdot \\delta \\mathbf{r} \\, dt.\n\u003e $$\n\u003e \n\u003e 因此：\n\u003e \n\u003e $$\n\u003e \\int \\delta T \\, dt = - \\int m \\vec{a} \\cdot \\delta \\vec{r} \\, dt.\n\u003e $$\n\u003e \n\u003e 这意味着在时间积分意义上，动能的变分与惯性力虚功的负值相等。但对于瞬时值，两者并没有直接联系。\n\n不急，我们先将势能项与动能项整理到一起，就有：\n\n$$\n\\sum_{i} \\vec{F_{i}} \\cdot \\delta \\vec{r} - m\\vec{a}\\cdot\\delta \\vec{r}\n= \\left(-\\frac{ \\partial V }{ \\partial \\mathbf{r} } -\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\dot{\\mathbf{r}} } \\right) \\cdot \\delta \\vec{r}\n=0\n$$\n\n整条式子的值对于任意方向上的虚位移 $\\delta \\vec{r}$ 都为零，那就只能是括号里的部分为零：\n\n$$\n-\\frac{ \\partial V }{ \\partial \\mathbf{r} } -\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\dot{\\mathbf{r}} } = 0\n$$\n\n哎呀，这个形式可太眼熟啦！拉格朗日回想起当年跟欧拉一起改进过的欧拉-拉格朗日方程：\n\n$$\n\\boxed{\\frac{ \\partial F }{ \\partial y } -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\frac{ \\partial F }{ \\partial y' } = 0}\n$$\n\n如果我整一个函数 $L(\\mathbf{r}, \\dot{\\mathbf{r}}) = T(\\dot{\\mathbf{r}}) - V(\\mathbf{r})$ ，不就有：\n\n$$\n\\frac{ \\partial L }{ \\partial \\mathbf{r} } -\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial L }{ \\partial \\dot{\\mathbf{r}} } \\\\\n= -\\frac{ \\partial V }{ \\partial \\mathbf{r} } - \\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\dot{\\mathbf{r}} } \n= 0\n$$\n\n而且欧拉-拉格朗日方程是干嘛用的呀？是解决泛函求极值问题用的呀！那我们岂不是可以反推出泛函：\n\n$$\nS[\\mathbf{r}] = \\int_{t_{1}}^{t_{2}} \\left[ T(\\dot{\\mathbf{r}}) - V(\\mathbf{r}) \\right] \\mathrm{d}t\n$$\n\n我们从虚位移原理和达朗贝尔原理中推出来的那个方程，不就是这个泛函 $S[\\mathbf{r}]$ 取极值时的条件？这个泛函 $S[\\mathbf{r}]$ 的值，就是我们要找的最小作用量呀！\n\n让我们重新整理一下表述：\n\n\u003e [!info] 拉格朗日版本的最小作用量原理\n\u003e \n\u003e 自然界中系统的真实运动规律，总是会满足：\n\u003e \n\u003e $$\n\u003e S[\\mathbf{r}] = \\int_{t_{1}}^{t_{2}} \\left[ T(\\dot{\\mathbf{r}}) - V(\\mathbf{r}) \\right] \\mathrm{d}t\n\u003e $$\n\u003e \n\u003e 这个作用量取得极值。\n\u003e \n\u003e 作用量取得极值时，有：\n\u003e \n\u003e $$\n\u003e -\\frac{ \\partial V }{ \\partial \\mathbf{r} } -\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\dot{\\mathbf{r}} } = 0\n\u003e $$\n\u003e \n\u003e 这个取极值的条件被称为拉格朗日方程。\n\n拉格朗日在 1760 年发表的论文《关于确定不定积分公式极大极小的一种新方法》[^关于确定不定积分公式极大极小的一种新方法]，第一次提出了拉格朗日发明的处理泛函极值问题的纯分析方法——**变分法**。随后一年内发表了第二篇论文《将前篇论文阐述的方法应用于解决动力学各类问题》[^将前篇论文阐述的方法应用于解决动力学各类问题]，提出这个版本的最小作用量原理，并使用最小作用量原理来解决各种力学问题。\n\n[^关于确定不定积分公式极大极小的一种新方法]: [Mémoires extraits des recueils de l’Académie de Turin/Essai d’une nouvelle méthode pour déterminer les maxima et les minima des formules intégrales indéfinies - Wikisource](https://fr.wikisource.org/wiki/M%C3%A9moires_extraits_des_recueils_de_l%E2%80%99Acad%C3%A9mie_de_Turin/Essai_d%E2%80%99une_nouvelle_m%C3%A9thode_pour_d%C3%A9terminer_les_maxima_et_les_minima_des_formules_int%C3%A9grales_ind%C3%A9finies)\n[^将前篇论文阐述的方法应用于解决动力学各类问题]: [Mémoires extraits des recueils de l’Académie de Turin/Application de la méthode exposée dans le Mémoire précédent à la solution de différents Problèmes de Dynamique - Wikisource](https://fr.wikisource.org/wiki/M%C3%A9moires_extraits_des_recueils_de_l%E2%80%99Acad%C3%A9mie_de_Turin/Application_de_la_m%C3%A9thode_expos%C3%A9e_dans_le_M%C3%A9moire_pr%C3%A9c%C3%A9dent_%C3%A0_la_solution_de_diff%C3%A9rents_Probl%C3%A8mes_de_Dynamique)\n\n\u003e [!info] 拉格朗日量\n\u003e 拉格朗日凑出来的这个函数 $L(\\mathbf{r}, \\dot{\\mathbf{r}}) = T(\\dot{\\mathbf{r}}) - V(\\mathbf{r})$ ，后来被称为拉格朗日量或拉格朗日函数。\n\u003e \n\u003e 拉格朗日量体现了系统的某种“动态平衡”：动能代表运动倾向，势能代表约束倾向，它们的差决定了系统如何演化。\n\u003e \n\u003e 更深层次的解释来自诺特定理：拉格朗日量的形式保证了守恒律（如能量守恒、动量守恒）与对称性（如时间平移不变性、空间平移不变性）的联系。\n\u003e \n\u003e 如果拉格朗日量不显含时间（ $\\frac{ \\partial L }{ \\partial t } = 0$ ），则能量守恒；如果位移项总是以相对位移形式出现 $L(\\dot{\\vec{r}}_a, (\\vec{r}_a - \\vec{r}_b))$ ，则动量守恒。\n\n我们可以举一个自由落体运动的例子，来直观看到如何使用拉格朗日方程求解物理问题。\n\n在自由落体运动中，动能 $T=\\frac{1}{2}m\\dot{h}^2$ ，势能 $V=mgh$ ，向下为正方向。则有拉格朗日量：\n\n$$\nL = T - V = \\frac{1}{2}m\\dot{h}^2 - mgh\n$$\n\n计算偏导数：\n\n$$\n\\begin{align}\n\\frac{ \\partial L }{ \\partial h }  \u0026 = -mg \\\\\n\\frac{ \\partial L }{ \\partial \\dot{h} }  \u0026 = m\\dot{h} \\\\\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial L }{ \\partial \\dot{h} }  \u0026 = m\\ddot{h}\n\\end{align}\n$$\n\n代入拉格朗日方程：\n\n$$\n-\\frac{ \\partial V }{ \\partial \\mathbf{r} } -\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\dot{\\mathbf{r}} } \n= mg - m\\ddot{h} = 0\n$$\n\n$mg = m\\ddot{h}$ ，这不就是牛顿第二定律嘛！\n\n### 广义坐标与分析力学\n\n拉格朗日并未止步于此。\n\n大家可以发现，无论是虚功原理还是达朗贝尔原理，都是从做功、能量这样的整体维度去描述的。那在这其中，基于笛卡尔坐标系的，牛顿意义上的位移与速度，有那么重要吗？\n\n不重要！\n\n拉格朗日提出，系统中只要势能可以表示为一系列量的函数，而动能可以表示为这一系列量对时间的导数的函数，虚功原理、达朗贝尔原理、乃至最小作用量原理就都能适用！\n\n我们来举个例子来直观理解他提出的这一系列的量——**广义位移**，以及广义位移对时间的导数——**广义速度**。\n\n对于一个单摆，我们可以定义摆角 $\\theta$ 为广义坐标，则广义速度为角速度 $\\dot{\\theta}$ 。则有势能 $V$ 与动能 $T$ ：\n\n$$\n\\begin{align}\nV \u0026  = mgh = -mgl\\cos \\theta \\\\\nT \u0026  = \\frac{1}{2}mv^2=\\frac{1}{2}ml^2\\dot{\\theta}^2\n\\end{align}\n$$\n\n于是有拉格朗日量：\n\n$$\nL = T - V = \\frac{1}{2}ml^2\\dot{\\theta}^2 + mgl\\cos \\theta\n$$\n\n计算偏导数：\n\n$$\n\\begin{align}\n\\frac{ \\partial L }{ \\partial \\theta }  \u0026 = -mgl\\sin \\theta \\\\\n\\frac{ \\partial L }{ \\partial \\dot{\\theta} } \u0026 = ml^2\\dot{\\theta} \\\\\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial L }{ \\partial \\dot{\\theta} } \u0026 = ml^2 \\ddot{\\theta}\n\\end{align}\n$$\n\n代入拉格朗日方程：\n\n$$\n-\\frac{ \\partial V }{ \\partial \\theta } -\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{ \\partial T }{ \\partial \\dot{\\theta} } \n= msgl\\sin \\theta - ml^2  \\ddot{\\theta} = 0\n$$\n\n这正是单摆的运动方程。\n\n\u003e [!info]\n\u003e 回想起我们在牛顿力学的框架下是如何解决单摆问题的？一般来说会通过把约束性条件列为方程组，通过解方程才能得到这个精确的单摆运动方程。\n\u003e \n\u003e 拉格朗日分析力学引入广义坐标，通过将约束性条件隐藏到广义坐标背后，使得解题方法更简洁直观，而不用解复杂的方程组。\n\n从此，拉格朗日的理论终于完全跳脱出牛顿力学中笛卡尔坐标下的位移与速度的局部性束缚，发展为对力学原理进行整体性描述的分析力学理论。因为基于整体性描述，使得分析力学适用范围极广，甚至到量子力学理论里的海森堡矩阵力学、薛定谔波动力学也依然适用。\n\n拉格朗日在 1788 年发表了著作《分析力学》[^分析力学]，最终提出了完整的拉格朗日分析力学。此时，距离 1687 年牛顿在《自然哲学的数学原理》[^自然哲学的数学原理]中提出牛顿力学已经过了将近 100 年。分析力学作为对力学原理的整体性描述，与作为局部性描述的牛顿力学在数学上严格等价，分别被用于处理不同尺度和条件下的力学问题。\n\n[^分析力学]: [Mécanique analytique - Wikipedia](https://en.wikipedia.org/wiki/M%C3%A9canique_analytique)\n[^自然哲学的数学原理]: [Philosophiæ Naturalis Principia Mathematica - Wikipedia](https://en.wikipedia.org/wiki/Philosophi%C3%A6_Naturalis_Principia_Mathematica)\n\n\n## 最后\n\n回顾我们这段从抽象数学到具体物理的旅程，其内在的逻辑链条清晰而有力。\n\n**线性代数**为我们提供了看待“结构”的基本语言。我们理解了**线性**、**线性映射**（及其矩阵表示）和**向量的度量（范数）**。这不仅是处理有限维数据的工具，更是通向无限维空间的基石。\n\n**微积分**将“线性”的思想发挥到极致。**微分，其本质就是局部线性逼近**。通过链式法则等工具，我们获得了分析复杂函数变化率的强大能力。\n\n**泛函分析**是一次关键的观念飞跃。我们将**函数视为无穷维空间中的向量**，将**函数的函数——泛函**作为研究对象。**变分**的概念，即函数本身的微小变化，自然地将微积分中的极值问题推广到了无限维的函数空间。从有限维向量启发而来的**变分法基本引理**则为我们寻找泛函的极值点（平稳点）提供了关键的判别工具。\n\n**变分法**是理论的必然延伸。我们不再满足于寻找一个点使得函数取极值，而是寻找一条路径（一个函数）使得某个累积量（如作用量）取极值。**欧拉-拉格朗日方程**正是这一追求的自然结果，它将泛函极值的复杂条件转化为一个关于路径函数的微分方程。\n\n最终，我们抵达了**分析力学**。通过**虚功原理**和**达朗贝尔原理**，我们将牛顿力学的矢量力学转化为功和能量的标量形式。而**最小作用量原理**则如同皇冠上的明珠，它指出物体的真实运动轨迹是使作用量泛函取平稳值的那条路径。**广义坐标**的引入，最终使得这套理论得以完善，并能够优雅地处理复杂约束系统，其抽象与普适性远超牛顿力学。\n\n但这远非故事的终点。拉格朗日去世后，分析力学这一门学科仍在发展，最小作用量原理的深刻内涵在后来得到了进一步的揭示。\n\n经过哈密顿与雅可比等人的工作，分析力学体系变得更加严密和深刻。他们证明了，自然界之所以总是按作用量最小的方式运动，是因为物理系统在更高维的相空间或时空（配置空间）中，其实做着最简单的“直线”运动（即**测地线**）。我们在三维空间中看到的复杂轨迹，不过是高维时空中这种简单、自然运动在我们维度上的投影。[^长河劫分析力学]这一思想在爱因斯坦的**广义相对论**中达到了顶峰，其中物质和能量的分布决定了时空的弯曲性质，而自由质点的运动轨迹就是弯曲时空中的测地线。\n\n更令人惊叹的是，分析力学与最小作用量原理展现出了惊人的生命力。当物理学进入微观和高速领域，许多牛顿力学的具体结论不再适用，但这套基于变分原理的框架却历久弥新。人们发现，**作用量的量纲（能量×时间）与普朗克常数的量纲相同**，这并非偶然，它暗示了作用量在量子世界中的基本地位。事实上，分析力学的数学结构——尤其是哈密顿体系——直接为**海森堡的矩阵力学**和**薛定谔的波动力学**提供了现成的数学语言。在薛定谔方程中，作用量以相位的角色出现。而后来发展的**量子场论**，其核心依然是作用量原理，只不过泛函的变量从粒子的路径变为了场在时空中的分布。\n\n从线性代数到分析力学，我们看到的是一条数学概念不断抽象化、一般化，从而更深刻地揭示自然本质的道路。分析力学不仅是对牛顿力学的重新表述，更是一种更具前瞻性的世界观。它告诉我们，宇宙的运行或许遵循着某种极简与和谐的经济原理，而数学，正是我们理解这种终极之美的最有力工具。\n\n","title":"从线性代数到分析力学（下）","abstract":"\u003e [!info]\n\u003e 这是《从线性代数到分析力学》上下两篇中的下篇，上篇为[[2025-09-29-from-linear-algebra-to-analytical-machanics-1|从线性代数到分析力学]]。\n最早，欧拉研究总结了短程线问题、等周问题等一大类类似“求取得极值时的曲线”的问题，并提出能使用了后来被称为“欧拉-拉格朗日方程”的通用的方法来求解这类问题。可惜此时欧拉的推导过程使用了大量分析与几何结合的手段，十分复杂也缺乏严谨，欧拉自己也对此并不满意。[^长河劫变分法]","length":660,"created_at":"2025-09-30T13:42:54.000Z","updated_at":"2025-09-30T13:43:10.000Z","tags":[],"license":false,"headingTrees":[{"key":"极值问题到变分问题","href":"#极值问题到变分问题","heading":2,"title":"极值问题到变分问题","children":[{"key":"函数的极值问题","href":"#函数的极值问题","heading":3,"title":"函数的极值问题","children":[],"id":"函数的极值问题"},{"key":"泛函的极值问题","href":"#泛函的极值问题","heading":3,"title":"泛函的极值问题","children":[],"id":"泛函的极值问题"},{"key":"变分法","href":"#变分法","heading":3,"title":"变分法","children":[],"id":"变分法"},{"key":"欧拉-拉格朗日方程","href":"#欧拉-拉格朗日方程","heading":3,"title":"欧拉-拉格朗日方程","children":[],"id":"欧拉-拉格朗日方程"}],"id":"极值问题到变分问题"},{"key":"分析力学","href":"#分析力学","heading":2,"title":"分析力学","children":[{"key":"虚功原理","href":"#虚功原理","heading":3,"title":"虚功原理","children":[],"id":"虚功原理"},{"key":"惯性力和达朗贝尔原理","href":"#惯性力和达朗贝尔原理","heading":3,"title":"惯性力和达朗贝尔原理","children":[],"id":"惯性力和达朗贝尔原理"},{"key":"最小作用量原理","href":"#最小作用量原理","heading":3,"title":"最小作用量原理","children":[],"id":"最小作用量原理"},{"key":"广义坐标与分析力学","href":"#广义坐标与分析力学","heading":3,"title":"广义坐标与分析力学","children":[],"id":"广义坐标与分析力学"}],"id":"分析力学"},{"key":"最后","href":"#最后","heading":2,"title":"最后","children":[],"id":"最后"},{"key":"footnote-label","href":"#footnote-label","heading":2,"title":"Footnotes","children":[],"id":"footnote-label"}],"wikiRefAliases":["2025-09-29-from-linear-algebra-to-analytical-machanics-1"],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2025-09-29-from-linear-algebra-to-analytical-machanics-1.md","pagePath":"/articles/from-linear-algebra-to-analytical-machanics-1","slug":"from-linear-algebra-to-analytical-machanics-1"},"meta":{"content":"\n## 线性代数\n\n讲线性代数，被同济版线性代数毒害过的人可能都会被唤醒藏于心底的恐惧：哇！又要讲行列式、对角化、增广矩阵算来算去了！\n\n其实线性代数没那么可怕。我们可以很直观地、很感性地去理解线性代数。\n\n### 什么是线性\n\n线性代数，关键当然在于“线性”。（应该没人会觉得线性代数的关键在于“代数”吧？）如果一个函数 $f(x)$ 有以下性质：\n\n$$\nf(ax+by) = af(x) + bf(y)\n$$\n\n则我们称这个函数 $f(x)$ **是线性的**，有线性性（Linearity）。其中，$X$ 与 $Y$ 都为 $f(x)$ 定义域上的自变量，可以是一个向量（如果 $f(x)$ 是一个多元函数）。 $a$ 与 $b$ 是一个数，一般理解上可以认为就是实数。（但实际上可以是任何域上的元素，如有理数域、实数域、复数域等。）\n\n\u003e [!info] 线性性严格定义\n\u003e 如果称一个函数 $L(x)$ 是线性的，指 $L(x)$ 同时具有以下两种性质：\n\u003e - 可加性： $L(x+t) = L(x) + L(t)$\n\u003e - 一次齐次性： $L(ax) = aL(x)$\n\n可这个时候就有人要问啦，为什么有这种性质就叫做**线性**？这跟**线**有什么关系？\n\n我们可以从两个方面来理解：\n\n一方面，最简单的直线：截距为零的一次函数（即正比例函数） $f(x) = kx$ ，是线性的。我们可以简单证明这一点：\n\n$$\n\\begin{align}\nf(ax) \u0026= af(x) \u0026 \\impliedby \u0026 \u0026k(ax) \u0026= akx \\\\\nf(x+y) \u0026= f(x) + f(y) \u0026 \\impliedby \u0026 \u0026k(x+y) \u0026= kx + ky\n\\end{align}\n$$\n\n另一方面，在空间中的直线（这里没有限制空间的维度哦），所有点输入这种线性的函数后，输出的所有点依然构成一条直线（输出的空间也没有限制纬度，而且与输入的空间维度不一定相同哦）。我们一步一步来证明。\n\n我们假设直线过点 $\\vec{p}$ ，且方向向量为 $\\vec{v}$ ，则直线上的所有点可以表示为： $\\vec{p} + k\\vec{v}$ ，其中 $k$ 为任意实数，取全体实数可得直线上的所有点。\n\n让我们把直线上的所有点输入函数中，可得：\n\n$$\nf(\\vec{p} + k\\vec{v}) = f(\\vec{p}) + kf(\\vec{v})\n$$\n\n其中 $f(\\vec{p})$ 就是输出空间中的一个点，而 $f(\\vec{v})$ 就是输出空间中直线的方向向量， $f(\\vec{p}) + kf(\\vec{v})$ 依旧是一条直线（不过是输出空间中的一条直线）。\n\n\n有了线性的直观理解，我们可以具体地、准确地说线性代数是什么了。\n\n\u003e [!info]\n\u003e 线性代数（Linear Algebra）是研究**向量空间**和**线性映射**的一个数学分支。\n\n**向量空间**就是指上面函数 $f(x)$ 的输入或输出元素组成的集合。给定一个域，如果一个集合具有向量加法、标量乘法两种运算且符合八条公理，就称这个集合为向量空间。\n\n**线性映射**就是指上面的有线性性的这个函数 $f$ 。如果映射 $f$ 将输入向量空间里的元素映射到输出向量空间里，且能维持向量加法与标量乘法，就成这个映射 $f$ 为线性映射。\n\n定义在向量空间上，可以被线性映射维持的这种形如 $a\\vec{x} + b\\vec{y}$ 的运算组合形式，就叫作**线性组合**。线性映射的定义也可以换个说法：能维持线性组合的映射叫线性映射。\n\n\n\u003e [!info]- 线性空间（ Vector Space ）的严格定义\n设 $F$ 是一个域（例如实数域  $\\mathbb{R}$ 或复数域 $\\mathbb{C}$）。一个 $F$**-向量空间** $V$ 是一个非空集合，其中定义了两种运算：\n\u003e - **向量加法**：$+ : V \\times V \\to V$，记作 $(\\mathbf{u}, \\mathbf{v}) \\mapsto \\mathbf{u} + \\mathbf{v}$ 。\n\u003e - **标量乘法**：$\\cdot : F \\times V \\to V$，记作 $(a, \\mathbf{v}) \\mapsto a \\cdot \\mathbf{v}$ 。\n\u003e \n\u003e 这些运算必须满足以下公理（对任意 $\\mathbf{u}, \\mathbf{v}, \\mathbf{w} \\in V$ 和任意 $a, b \\in F$)：\n\u003e 1. **加法结合律**：$(\\mathbf{u} + \\mathbf{v}) + \\mathbf{w} = \\mathbf{u} + (\\mathbf{v} + \\mathbf{w})$ 。\n\u003e 2. **加法交换律**：$\\mathbf{u} + \\mathbf{v} = \\mathbf{v} + \\mathbf{u}$ 。\n\u003e 3. **加法单位元**：存在零向量 $\\mathbf{0} \\in V$，使得 $\\mathbf{v} + \\mathbf{0} = \\mathbf{v}$ 对所有 $\\mathbf{v} \\in V$ 成立。\n\u003e 4. **加法逆元**：对每个 $\\mathbf{v} \\in V$，存在向量 $-\\mathbf{v} \\in V$，使得 $\\mathbf{v} + (-\\mathbf{v}) = \\mathbf{0}$ 。\n\u003e 5. **标量乘法与域乘法兼容**：$a \\cdot (b \\cdot \\mathbf{v}) = (a b) \\cdot \\mathbf{v}$ 。\n\u003e 6. **标量乘法单位元**：若 $1 \\in F$ 是乘法单位元，则 $1 \\cdot \\mathbf{v} = \\mathbf{v}$ 。\n\u003e 7. **分配律（标量乘法对向量加法）**：$a \\cdot (\\mathbf{u} + \\mathbf{v}) = a \\cdot \\mathbf{u} + a \\cdot \\mathbf{v}$ 。\n\u003e 8. **分配律（向量加法对标量乘法）**：$(a + b) \\cdot \\mathbf{v} = a \\cdot \\mathbf{v} + b \\cdot \\mathbf{v}$ 。\n\u003e \n\n\n\u003e [!info]- 线性映射（ Linear Map ）的严格定义\n\u003e 设 $V$ 和 $W$ 是同一个域 $F$ 上的向量空间。如果一个函数 $T : V \\to W$ 满足以下两个条件：\n\u003e - **可加性**：对任意 $\\mathbf{u}, \\mathbf{v} \\in V$，有 $T(\\mathbf{u} + \\mathbf{v}) = T(\\mathbf{u}) + T(\\mathbf{v})$ 。\n\u003e - **齐次性**：对任意 $a \\in F$ 和 $\\mathbf{u} \\in V$，有 $T(a \\cdot \\mathbf{u}) = a \\cdot T(\\mathbf{u})$ .\n\u003e \n\u003e 等价地，对于任意 $a, b \\in F$ 和任意 $\\mathbf{u}, \\mathbf{v} \\in V$ ，有 $T(a \\mathbf{u} + b \\mathbf{v}) = a T(\\mathbf{u}) + b T(\\mathbf{v})$ .\n\u003e\n\u003e 我们把这样的函数称为**线性映射**（或线性变换），\n\n\n\u003e [!info]- 线性组合（Linear Combination）的严格定义\n设 $V$ 是域 $F$ 上的一个向量空间，并设 $S = \\{\\mathbf{v}_1, \\mathbf{v}_2, \\dots, \\mathbf{v}_n\\}$ 是 $V$ 的一个子集。如果存在有限个标量 $a_1, a_2, \\dots, a_n \\in F$（称为系数），使得：\n\u003e \n\u003e $$\n\u003e \\mathbf{v} = a_1 \\mathbf{v}_1 + a_2 \\mathbf{v}_2 + \\dots + a_n \\mathbf{v}_n = \\sum_{i=1}^n a_i \\mathbf{v}_i.\n\u003e $$\n\u003e \n\u003e 我们把这样的向量 $\\mathbf{v} \\in V$ 称为 $S$ 的**线性组合**，\n\n\n我们可以从上面这些定义中引申出线性映射两个重要的性质：\n\n- 线性映射的复合还是线性映射\n- 线性映射的线性组合还是线性映射\n\n### 线性映射的两个重要性质\n\n首先，**线性映射的复合依然是线性映射**。怎么理解呢？我们可以试着将线性映射出来的结果输入另一个线性映射中：\n\n$$\n\\begin{align}\ng(f(a\\vec{x}+b\\vec{y})) \u0026= g(af(\\vec{x}) + bf(\\vec{y})) \\\\\n\u0026= ag(f(\\vec{x})) + bg(f(\\vec{y}))\n\\end{align}\n$$\n\n其中 $g$ 与 $f$ 都为线性映射。假设 $f$ 将 N 维向量映射到 M 维向量空间中（ $f:\\mathbb{R}^n\\to \\mathbb{R}^m$ ），而 $g$ 将 M 维向量映射到 L 维向量空间中（ $g: \\mathbb{R}^m \\to \\mathbb{R}^l$ ）。\n\n那么如果我们将 $g$ 与 $f$ 这样复合起来（ $g \\circ f$ ）的新的映射称为 $h$ ，则这个新的映射 $h$ 将会是一个能将 N 维向量映射到 L 维向量空间中的映射（ $h: \\mathbb{R}^n \\to \\mathbb{R}^l$ ），而且依然是一个线性映射：\n\n$$\n\\begin{align}\n\u0026\u0026 g(f(a\\vec{x}+b\\vec{y})) \u0026= ag(f(\\vec{x})) + bg(f(\\vec{y})) \\\\\n\\implies\u0026\u0026 h(a\\vec{x}+b\\vec{y}) \u0026= ah(\\vec{x}) + bh(\\vec{y})\n\\end{align}\n$$\n\n\u003e [!note]\n\u003e 虽然上面的描述中线性映射 $f$ 与 $g$ 都是基于有限维空间的向量，但实际上这个性质对于任意线性空间上的映射都适用。包括下文提到的线性映射组成的向量空间。\n\n其次，**线性映射的线性组合还是线性映射**。要聊这条性质之前我们还缺了点定义，我们先补上：\n\n\u003e [!info]\n\u003e 假设有定义在 $V \\to W$ 上的两个线性映射 $f$ 与 $g$ 。我们定义：\n\u003e \n\u003e - $f+g$ 为映射的加法，有 ： $(f+g)(\\vec{x}) = f(\\vec{x}) + g(\\vec{x})$\n\u003e - $kf$ 为映射的数乘，有： $(kf)(\\vec{x}) = kf(\\vec{x})$\n\u003e - $L(V, W)$ 为所有定义在 $V \\to W$ 上的线性映射组成的集合。即 $f \\in L(V, W)$ 且 $g \\in L(V,W)$\n\n脑袋灵活的同学就会发现了：哎哟，这个加法和数乘出来的结果还是一个定义在 $V\\to W$ 上的线性映射哦！换句话说，结果还在 $L(V,W)$ 里！\n\n对于映射的加法 $f + g = h$ ，有：\n\n$$\n\\begin{align}\nh(a\\vec{x}+b\\vec{y}) \u0026= f(a\\vec{x}+b\\vec{y}) + g(a\\vec{x}+b\\vec{y}) \\\\\n\u0026=af(\\vec{x})+bf(\\vec{y})+ag(\\vec{x})+bg(\\vec{y}) \\\\\n\u0026=a(f(\\vec{x})+g(\\vec{x})) + b(f(\\vec{y})+g(\\vec{y})) \\\\\n\u0026=ah(\\vec{x}) + bh(\\vec{y})\n\\end{align}\n$$\n\n对于映射的乘法 $kf = h$ ，有：\n\n$$\n\\begin{align}\nh(a\\vec{x}+b\\vec{y}) \u0026= kf(a\\vec{x}+b\\vec{y}) \\\\\n\u0026= k(af(\\vec{x}) + bf(\\vec{y})) \\\\\n\u0026= akf(\\vec{x}) + bkf(\\vec{y}) \\\\\n\u0026= ah(\\vec{x}) + bh(\\vec{y})\n\\end{align}\n$$\n\n再推广一点，如果我们称形如 $af+bg$ 为线性映射 $f$  、 $g$ 的线性组合，那么其线性组合的结果 $h(x) = (af + bg)(x)$ 依然是一个线性映射。（即得易见平凡。）\n\n换一种说法，映射的加法与数乘就是定义在 $L(V, W)$ 上的向量加法与标量乘法，而且还符合向量空间需要符合的8条公理。（仿照上例显然。）没想到吧，不仅 $V$ 与 $W$ 是向量空间，线性映射的集合 $L(V,W)$ 也是一个向量空间！\n\n### 线性映射与矩阵\n\n实际上，我们可以很直觉地知道，如果我们将列向量左乘一个矩阵视为一个关于该向量的函数，那么这个函数是一种线性映射：\n\n$$\n\\begin{align}\n\n\u0026若 K = \\begin{bmatrix}\nk_{11} \u0026 k_{12} \u0026\\dots \u0026k_{1n} \\\\\nk_{21} \u0026 k_{22} \u0026\\dots \u0026k_{2n} \\\\\n\\vdots \u0026 \\vdots \u0026\\ddots \u0026\\vdots \\\\\nk_{m1} \u0026 k_{m2} \u0026\\dots \u0026k_{mn}\n\\end{bmatrix} 为一个 M \\times N 维矩阵， \\vec{x} = \\begin{bmatrix}\nx_{1} \\\\\nx_{2} \\\\\n\\vdots \\\\\nx_{n}\n\\end{bmatrix} 为 N 维向量自变量。  \\\\\n \\\\\n\u0026令 f(\\vec{x}) = K\\vec{x}，有：\n\\end{align}\n$$\n\n$$\n\\begin{align}\nf(a\\vec{x}) \u0026= af(\\vec{x}) \u0026 \\impliedby \u0026 \u0026K(a\\vec{x}) \u0026= aK\\vec{x} \u0026(矩阵乘法与数乘的交换律) \\\\\nf(\\vec{x}+\\vec{y}) \u0026= f(\\vec{x}) + f(\\vec{y}) \u0026 \\impliedby \u0026 \u0026K(\\vec{x}+\\vec{y}) \u0026= K\\vec{x} + K\\vec{y} \u0026(矩阵乘法的分配律)\n\\end{align}\n$$\n\n\u003e [!info]- 矩阵与正比例函数的关系\n\u003e 我们发现：哎哟，列向量左乘一个矩阵，跟正比例函数 $f(x) = kx$ 的情况真的很像哦！实际上，我们确实可以将向量左乘一个矩阵理解为高维度下的“正比例函数”。考虑一个最简单的例子，对于输入为二维向量，输出为一维向量（标量）的情况：\n\u003e\n\u003e $$\n\u003e f(x,y) = K\\begin{bmatrix} x \\\\ y \\end{bmatrix} = k_{1}x + k_{2}y\n\u003e $$\n\u003e\n\u003e 实际上他就是一个三维空间中过原点的平面。\n\u003e \n\u003e - 对于 $x$ 方向，函数随 $x$ 正比例变化。\n\u003e - 对于 $y$ 方向，函数随 $y$ 以另一比例正比例变化。\n\u003e - 对于其他任意方向，函数以一个混合的比例随这个方向上的距离正比例变化。\n\u003e\n\u003e 而反过来，正比例函数也是左乘一个矩阵：这个矩阵为 $1 \\times 1$ 矩阵，输入向量与输出向量维度都为 1 。\n\n而另一方面，对于有限维的向量空间 $V$ 与 $W$ ，假设 $T: V \\to W$ 是一个线性映射，那么 $T$ 就能表示为一个矩阵。相关证明这里就略去了，大家可以自行查找资料证明。（留作习题答案略，读者自证不难。） [^有限维线性映射一定能表示为一个矩阵]\n\n[^有限维线性映射一定能表示为一个矩阵]: [线性映射 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84#%E7%9F%A9%E9%99%A3)\n\n一旦将线性变换理解为左乘矩阵，那线性映射的两个重要性质就变得很直观自然了！\n\n对于线性映射的复合：\n\n- 线性变换后再套一层线性变换，在矩阵层面就是左乘两个矩阵\n- 由于矩阵乘法的结合律，我们可以先算两个矩阵之间的乘法\n- 两个矩阵相乘依然是一个矩阵，也就是结果依然是一个线性变换\n\n对于线性映射的线性组合：\n\n- $\\mathbb{R}^m\\to \\mathbb{R}^n$ 的线性映射，在矩阵层面就是 $M\\times N$ 维矩阵，映射的加法、数乘就是矩阵的加法、数乘\n- 对于相同维度的矩阵，矩阵加法的结果仍为维矩阵，矩阵数乘的结果仍为矩阵\n- 相同维度矩阵的线性组合依然是矩阵，也就是线性变换的线性组合依然是线性变换\n\n从矩阵乘法的角度来看线性变换，线性映射的复合依然是线性映射，线性映射的线性组合依然是线性映射，这两个结论可太自然了！\n\n### 向量的长度：模，或者 L2 范数\n\n严格来说，讲 $L_{2}$-范数之前应该先讲向量内积 $\u003c\\vec{x}, \\vec{y}\u003e$ 的定义，向量自己与自己内积的开方才是向量的模——或者说 $L_{2}$-范数的定义： $||\\vec{x}|| = \\sqrt{ \u003c\\vec{x}, \\vec{x}\u003e } = \\sqrt{ \\sum x_{i}^2 }$ 。\n\n然而，内积相关的内容展开讲可以讲一大堆，而这些内容与这篇文章的主线偏离太大了。现在网上已经有许多很好的相关讲解，大家可以自行查阅。[^内积相关内容]\n\n[^内积相关内容]: [【无痛线代】向量内积背后，竟然藏着宇宙的对称性？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QawbehELC/?spm_id_from=333.337.search-card.all.click\u0026vd_source=ba01a1932b530e32e2576726fdda41d7)\n\n$L_{2}$ 范数代表了一个向量的长度。如果我们想要测量两个向量 $\\vec{x}$ $\\vec{y}$ 相差的大小，我们可以计算他们之间差的 $L_{2}$ 范数： $||\\vec{x}-\\vec{y}|| = \\sqrt{ \u003c\\vec{x}-\\vec{y}, \\vec{x}-\\vec{y}\u003e } = \\sqrt{ \\sum(x_{i} - y_{i})^2 }$ 。\n\n## 微积分\n\n有了线性代数基础，终于可以开始讲微积分了。大学上过高等数学课的同学要坐不住啦：什么！？微积分的基础不是 $\\epsilon-\\delta$ 语言和极限吗？不急，我们娓娓道来。\n\n### 微分的本质是线性逼近\n\n这时候就要回忆起我们当初是怎么学导数的了：“在函数上一点做一条**切线**，这样那样这样那样……”。其实这就是在函数上的一点做**线性逼近**：\n\n$$\n\\mathrm{d}y = f'(x)\\mathrm{d}x\n$$\n\n看着像正比例函数 $y = kx$ 吧？这里的导数 $f'(x)$ 就是切线的斜率，在函数的某一点附近，因变量微分 $\\mathrm{d}y$ 与自变量微分 $\\mathrm{d}x$ （也就是 $\\Delta x$ ）成正比例关系，也就是线性关系。所以也称 $\\mathrm{d}y$ 为 $\\Delta y = f(x_{0}+\\Delta x) - f(x_{0})$ 的线性主部。\n\n![](https://upload.wikimedia.org/wikipedia/commons/f/f1/Dydx_zh.svg)\n\n所以我们能很直观的感受什么叫微分啦：在离函数上一点足够近的范围内，我们用一个随自变量线性变化的值去近似代替这一点附近的函数值本身，这个线性变化的值就是微分 $\\mathrm{d}y$ 。\n\n可这又有人要说了：你这定义不严谨呀！什么叫做“足够近的范围内”？多近才叫做足够近？怎么样的线性变化的值才能跟函数值本身足够像？从上面的图我们也能很清楚的看出， $\\mathrm{d}y$ 跟 $\\Delta y$ 可不相等呀！\n\n这就要说到“线性逼近”的另一个重点了：**线性逼近**一个重点是**线性**，另一个终点就是**逼近**，也就是极限 $\\lim_{ x \\to x_{0} }$ 这个符号。\n\n\u003e [!info]- 极限的严格定义\n\u003e \n\u003e 对于所有的 $\\epsilon \u003e 0$ ，都存在 $\\delta \u003e 0$ 使得：\n\u003e 对任意的 $x \\in D_{f}$ ，满足 $0 \u003c | x-x_{0}| \u003c \\delta$ 时，都有 $|f(x) - L| \u003c \\epsilon$ 。 则称：\n\u003e $$\n\u003e \\lim_{ x \\to x_{0} } f(x) = L\n\u003e $$\n\n说人话，就是能够找到一个 $L$ ，使得不管给定精度范围要求多精确，都能找到一个 $x_{0}$ 附近足够窄的范围，使得在这范围内的所有函数值都符合精度要求地近似于 $L$ 。\n\n套回微分里，就是能够找到一个比例系数 $f'(x_{0})$ ，使得不管要求有多精确，都能找到一个足够窄的范围，使得在这范围里所有的 $\\mathrm{d}y = f'(x_{0})\\mathrm{d}x$ 都符合精度要求地近似于 $\\Delta y = f(x+\\Delta x) - f(x)$ 。\n\n\u003e [!info] 微分的严格定义\n\u003e\n\u003e 设函数 $y=f(x)$ 在某区间 $\\mathcal {I}$ 内有定义。\n\u003e \n\u003e 对于 $\\mathcal {I}$ 内一点 $x_{0}$ ，当 $x_{0}$ 变动到附近的 $x_{0}+\\Delta x$ （也在此区间内）时，如果函数的增量 $\\Delta y=f(x_{0}+\\Delta x)-f(x_{0})$ 可表示为 $\\Delta y=A\\Delta x+o(\\Delta x)$ （其中 $A$ 是不依赖于 $\\Delta x$ 的常数），而 $o(\\Delta x)$ 是比 $\\Delta x$ 高阶的无穷小，那么称函数 $f(x)$ 在点 $x_{0}$ 是可微的，且 $A\\Delta x$ 称作函数在点 $x_{0}$ 相应于自变量增量 $\\Delta x$ 的微分，记作 $\\textrm{d}y$ ，即 ${\\textrm {d}}y=A\\Delta x$ ， ${\\textrm {d}}y$ 是 $\\Delta y$ 的线性主部。\n\u003e \n\u003e 通常把自变量 $x$ 的增量 $\\Delta x$ 称为自变量的微分，记作 $\\mathrm{d}x$ ，即 $\\mathrm{d}x = \\Delta x$ 。\n\n### 多元函数与多值函数的微分\n\n线性代数部分我们也提到了，对于多元、多值函数，我们可以看成是自变量、因变量为向量的函数。那对于多元多值函数，我们能做微分吗？怎么定义微分呢？\n\n我们还是回到微分的两个重点，也就是线性逼近的两个重点：线性与逼近。\n\n首先是逼近。对于一个 N 维向量 $x_{0}$ ，怎么定义“ $x_{0}$ 附近足够窄的范围”呢？\n\n我们想啊，“ $x_{0}$ 附近足够窄的范围“ 里的元素，不就是距离 $x_{0}$ 足够近的元素吗？那简单呀！用我们在线性代数里提到过的 $L_{2}$ 范数 $||\\vec{x}-\\vec{y}|| = \\sqrt{ \\sum(x_{i} - y_{i})^2 }$ 定义不就好咯！\n\n然后是线性。这也简单呀！一个输入为 N 维向量，输出为 M 维向量的线性变换，不就是向输入变量左乘一个 $M \\times N$ 维的矩阵嘛！\n\n于是我们就能直观定义多元、多值函数上的微分了：\n\n对于一个输入为 N 维向量 $\\vec{x}$ ，输出为 M 维向量 $\\vec{y}$ 的多元多值函数 $\\vec{y} = f(\\vec{x})$ ，我们称在点 $\\vec{x_{0}}$ 处的微分为：\n\n$$\n\\mathrm{d}\\vec{y} = J\\mathrm{d}\\vec{x}\n$$\n\n对于如果我们能找到这样的一个系数矩阵 $J$ ，使得不管要求有多精确，都能找到一个足够窄的范围 $||\\Delta \\vec{x}|| \u003c \\delta$ ，使得这个范围内所有的 $\\mathrm{d}\\vec{y} = J\\mathrm{d}\\vec{x}$ 都符合精度地近似于 $\\Delta \\vec{y} = f(\\vec{x_{0}} + \\Delta \\vec{x}) - f(\\vec{x_{0}})$ ，即对于任何方向 $\\vec{e}$ 的 $\\Delta \\vec{x}=h\\vec{e}$ ，都有 $||\\frac{\\Delta \\vec{y} - \\mathrm{d}\\vec{y}}{h}|| \u003c \\epsilon$ ，其中 $h=||\\Delta \\vec{x}||$ 。\n\n\u003e [!info]\n\u003e 其中系数矩阵 $J$ 为 $M \\times N$ 维矩阵，称为雅可比矩阵：\n\u003e \n\u003e $$\n\u003e J = \\begin{bmatrix}\n\u003e \\frac{ \\partial y_{1} }{ \\partial x_{1} }  \u0026 \\frac{ \\partial y_{1} }{ \\partial x_{2} }  \u0026 \\dots \u0026 \\frac{ \\partial y_{1} }{ \\partial x_{n} }  \\\\\n\u003e \\frac{ \\partial y_{2} }{ \\partial x_{1} }  \u0026 \\frac{ \\partial y_{2} }{ \\partial x_{2} }  \u0026 \\dots \u0026 \\frac{ \\partial y_{2} }{ \\partial x_{n} }  \\\\\n\u003e \\vdots  \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\n\u003e \\frac{ \\partial y_{m} }{ \\partial x_{1} }  \u0026 \\frac{ \\partial y_{m} }{ \\partial x_{2} }  \u0026 \\dots \u0026 \\frac{ \\partial y_{m} }{ \\partial x_{n} } \n\u003e \\end{bmatrix}\n\u003e $$\n\u003e \n\u003e 其中 $y_{m}$ 为因变量 $\\vec{y}$ 的第 m 个分量， $x_{n}$ 为自变量 $\\vec{x}$ 的第 n 个分量。$\\frac{ \\partial y_{m} }{ \\partial x_{n} }$ 为因变量第 m 个分量对自变量第 n 个分量的偏导数。\n\n这样说可能不够直观。让我们举一个例子作图更直观地感受多元函数的微分。\n\n我们令函数 $z = f(x, y) = x^2 + y^2$ ，这是一个抛物面，在点 $(x_{0}, y_{0}) = (-0.5, 0.5)$ 处的线性逼近应为：\n\n$$\ndz = - dx - dy = \\begin{bmatrix}\n-1 \u0026 1\n\\end{bmatrix}\\begin{bmatrix}\ndx \\\\\ndy\n\\end{bmatrix}\n$$\n\n\n```jessiecode\n---\naxis: false\n---\n\nbound = [-1,1];\nzbound = [0, 2];\nplaneStyle = \u003c\u003c\n\tfillOpacity:0.2, \n\tmesh3d:\u003c\u003c\n\t\tstepWidthU:0.2,\n\t\tstepWidthV:0.2,\n\t\tstrokeOpacity:0.2\n\t\u003e\u003e\n\u003e\u003e;\nview = view3d([-7,-7], [14,14], [bound,bound, zbound])\u003c\u003c\n\txPlaneRear: planeStyle,\n\tyPlaneRear: planeStyle,\n\tzPlaneRear: planeStyle,\n\tprojection: \"central\"\n\u003e\u003e;\n\nF = function(x,y){return x**2 + y**2;};\nfg = functiongraph3d(view, F, bound, bound)\u003c\u003cstrokeWidth:0.5,stepsU:70,stepsV:70\u003e\u003e;\n\npx = slider([4,-8], [8,-8], [-1,-0.5,1]);\npy = slider([4,-8], [4,-4], [-1,0.5,1]);\n\nPX = function(){return px.Value();};\nPY = function(){return py.Value();};\nPZ = function(){return F(px.Value(), py.Value());};\nP = point3d(view,PX,PY,PZ);\n\ntanXY = function(x, y) {\n\treturn 2*PX()*x+2*PY()*y-PX()*PX()-PY()*PY();\n};\nfunctiongraph3d(view,tanXY, bound,bound);\n```\n\n\n\n从 desmos 的函数图像里也可以看出，线性逼近组成一个点 $(x_{0},y_{0})$ 处的切平面，这是一个在三维空间中有两个自由度的线性图形。\n\n\u003e [!info]\n\u003e 我们可以直观感受到，多元单值函数的微分就是所谓全微分。\n\n### 加减法法则、数乘法则与链式法则\n\n回顾我们在线性代数中推导过的线性映射的两个重要性质：\n\n- 线性映射的复合还是线性映射\n- 线性映射的线性组合还是线性映射\n\n既然我们已经知道，微分的本质是线性逼近，那这两个重要性质在微分中有没有什么体现呢？\n\n有的兄弟，有的！\n\n其一，从线性映射的复合可以推导出微分的链式法则。给出函数 $\\vec{y}=f(\\vec{u})$ 和 $\\vec{u}=g(\\vec{x})$ （都是多元多值函数哦，不过也对一元单值函数适用），我们要考虑复合函数 $\\vec{y} = h(\\vec{x}) = f(g(\\vec{x}))$ 的微分 $\\mathrm{d}\\vec{y}$ 长什么样。\n\n你们想啊，既然我们的微分是一个对原函数的逼近，也就是跟原函数的局部足够像！那既然原函数复合起来了，那我们微分是不是也要复合起来？那线性映射的复合，不就表现为矩阵乘法嘛。于是我们就有：\n\n$$\n\\begin{align}\n\u0026\\mathrm{d}\\vec{y} = J_{f}\\mathrm{d}\\vec{u} \\\\\n\u0026\\mathrm{d}\\vec{u} = J_{g}\\mathrm{d}\\vec{x} \\\\\n\\implies \u0026\\mathrm{d}\\vec{y} = J_{f}J_{g}\\mathrm{d}\\vec{x} = J_{h}\\mathrm{d}\\vec{x}\\\\ \\\\\n\n即： \u0026J_{h} = J_{f}J_{g}\n\\end{align}\n$$\n\n其二，从线性映射的线性组合还是线性映射，我们可以得到微分的加减法法则与乘法法则。给出函数 $\\vec{y_{1}} = f(\\vec{x})$ 与 $\\vec{y_{2}} = g(\\vec{x})$ （函数值 $\\vec{y_{1}}$ 与 $\\vec{y_{2}}$ 属于同一个向量空间），考虑函数值线性组合得到的新函数 $\\vec{y}=h(\\vec{x}) = af(\\vec{x}) + bg(\\vec{x})$ 的微分长什么样。\n\n你们再想啊，函数的线性组合的结果的变化量，不也是变化量的线性组合嘛 $\\Delta (af(\\vec{x})+bg(\\vec{x}))= a\\Delta f(\\vec{x}) + b\\Delta g(\\vec{x})$ ！（线性组合的差分是差分的线性组合，读者自证不难。）那既然我们的微分 $\\mathrm{d}\\vec{y}$ 近似于函数的变化量 $\\Delta \\vec{y}$ ，那函数线性组合的微分，不也应该是微分的线性组合嘛！\n\n$$\n\\begin{align}\n\\mathrm{d}\\vec{y} \u0026= \\mathrm{d}(a\\vec{y_{1}} + b\\vec{y_{2}}) \\\\\n\u0026= a\\mathrm{d}\\vec{y_{1}} + b\\mathrm{d}\\vec{y_{2}} \\\\\n\\implies \u0026= aJ_{f}\\mathrm{d}\\vec{x} + bJ_{g}\\mathrm{d}\\vec{x} = J_{h}\\mathrm{d}\\vec{x}\\\\\n \\\\\n即： J_{h} \u0026= aJ_{f} + bJ_{g}\n\\end{align}\n$$\n\n其中当 $a = b = 1$ 时即为加法法则， $b = 0$ 时就为数乘法则。\n\n哎哟，这么一看，微分的加减法法则、数乘法则、链式法则，都挺直观的哦！\n\n\u003e [!info]- 这对吗？\n\u003e \n\u003e 对的对的对的……哦！不对不对不对。\n\u003e \n\u003e 这上面的出来的线性组合、复合后的微分，线性是线性了，还没证明他逼近呀！线性逼近，线性和逼近一个都不能少。\n\u003e \n\u003e 回想起 $\\Delta \\vec{y}$ 与 $\\mathrm{d}\\vec{y}$ 的关系：\n\u003e \n\u003e $$\n\u003e \\Delta \\vec{y} = \\mathrm{d}\\vec{y} + o(\\vec{x}) \n\u003e $$\n\u003e \n\u003e 其中 $o(\\vec{x})$ 是关于 $\\vec{x}$ 的高阶无穷小。要证明在上面线性组合、复合后得到的“微分”依然逼近，就是证明在线性组合、复合后剩余项依旧是关于 $\\vec{x}$ 的高阶无穷小。\n\u003e \n\u003e 对于函数的线性组合，可以很容易得出：\n\u003e \n\u003e $$\n\u003e \\begin{align}\n\u003e \\Delta \\vec{y} \u0026= a\\Delta \\vec{y_{1}} + b\\Delta \\vec{y_{2}} \\\\\n\u003e \u0026=(a\\mathrm{d}\\vec{y_{1}}+b\\mathrm{d}\\vec{y_{2}}) + ao_{1}(\\vec{x})+bo_{2}(\\vec{x}) \\\\\n\u003e \u0026= d\\vec{y} + o(\\vec{x}) \u0026 (高阶无穷小的有限线性组合仍是高阶无穷小)\n\u003e \\end{align}\n\u003e $$\n\u003e \n\u003e \n\u003e 而对于函数的复合，也容易得出：\n\u003e \n\u003e $$\n\u003e \\begin{align}\n\u003e \\Delta \\vec{y} \u0026= J_{f}\\mathrm{d}\\vec{u} + o_{f}(\\vec{u}) \\\\\n\u003e \u0026= J_{f}(J_{g}\\mathrm{d}\\vec{x}+o_{g}(\\vec{x})) + o_{f}(\\vec{u}) \\\\\n\u003e \u0026= J_{f}J_{g}\\mathrm{d}\\vec{x}+ J_{f}o_{g}(\\vec{x}) + o_{f}(\\vec{u}) \\\\\n\u003e \u0026= J_{f}J_{g}\\mathrm{d}\\vec{x}+ J_{f}o_{g}(\\vec{x}) + o_{f}(\\vec{x}) \u0026\u0026 (\\vec{u} 可以被 \\vec{x} 一阶近似，因此 o_{f}(\\vec{u}) 也为关于 \\vec{x} 的高阶无穷小) \\\\\n\u003e \u0026= J_{f}J_{g}\\mathrm{d}\\vec{x}+ o_{g}(\\vec{x}) + o_{f}(\\vec{x}) \u0026\u0026 (高阶无穷小的有限线性映射仍为高阶无穷小) \\\\\n\u003e \u0026= J_{f}J_{g}\\mathrm{d}\\vec{x} + o(\\vec{x}) \u0026\u0026 (有限个高阶无穷小的和仍为高阶无穷小)\n\u003e \\end{align}\n\u003e $$\n\u003e \n\u003e 这下我们终于算是严谨而又直观地从线性映射的两个性质证明了微分的加减法、乘法、链式法则了。\n\n\u003e [!info]\n\u003e 其实这两个法则可以换一种说法：\n\u003e \n\u003e - 函数复合的线性逼近是线性逼近的复合\n\u003e - 函数线性组合的线性逼近是线性逼近的线性组合\n\n### 乘法法则\n\n与加减法、数乘法则和链式法则不同，函数值相乘的微分乘法法则似乎不能直接从线性映射的性质推导出来。\n\n这是对的，因为乘法运算本身不是线性的（而是双线性的）。但也无妨，我们可以引入一个双线性函数 $\\phi(u,v) = uv$ ，就可以把乘积函数 $h(\\vec{x}) = f(\\vec{x})g(\\vec{x})$ 看作是 $f(\\vec{x})$ 和 $g(\\vec{x})$ 与双线性函数的复合： $h(\\vec{x}) = \\phi(f(\\vec{x}), g(\\vec{x}))$ 。\n\n复合函数的微分链式法则我们上面已经研究过了，所以我们可以着重于研究双线性函数 $\\phi(u, v)$ 的微分性质。\n\n双线性函数 $\\phi(u, v)$ 是一个二元函数，我们视 $(u, v)$ 为一个向量，自然也可以套入线性代数部分中已经推导得到的多元函数的微分：\n\n$$\n\\begin{align}\n\\mathrm{d}\\phi(u, v) \u0026= \\begin{bmatrix}\n\\frac{ \\partial \\phi }{ \\partial u }  \u0026 \\frac{ \\partial \\phi }{ \\partial v }\n\\end{bmatrix}\\begin{bmatrix}\n\\mathrm{d}u \\\\\n\\mathrm{d}v\n\\end{bmatrix} \\\\\n\u0026= \\frac{ \\partial \\phi }{ \\partial u } \\mathrm{d}u + \\frac{ \\partial \\phi }{ \\partial v } \\mathrm{d}v \\\\\n\u0026= v\\mathrm{d}u + u\\mathrm{d}v\n\\end{align}\n$$\n\n再应用回微分的链式法则，线性映射的复合还是线性映射，即可得：\n\n$$\n\\begin{align}\n\\mathrm{d}h(\\vec{x}) \u0026= \\mathrm{d}\\phi(f(\\vec{x}),g(\\vec{x})) \\\\\n \u0026 = g(\\vec{x})\\mathrm{d}f(\\vec{x})+f(\\vec{x})\\mathrm{d}g(\\vec{x}) \\\\\n \u0026 = g(\\vec{x})f'(\\vec{x})\\mathrm{d}x + f(\\vec{x})g'(\\vec{x})\\mathrm{d}x\n\\end{align}\n$$\n\n即 $h'(\\vec{x}) = f'(\\vec{x})g(\\vec{x}) + f(\\vec{x})g'(\\vec{x})$ 。\n\n\n## 泛函分析\n\n上面推导微分的加减法法则、数乘法则中，我们将函数值进行了线性组合。这是当然可行的，因为函数值是一个向量。\n\n可是另一方面，将函数值进行线性组合后，从自变量映射到因变量依然是一个新的函数呀！那是不是能把这样的组合称为函数间的线性组合？难道……\n\n### 函数是无穷维向量\n\n没错，函数空间也是向量空间，函数也是向量。\n\n要说明函数空间也是向量空间，我们还是回到向量空间的定义：定义两种运算，符合八条公理。\n\n我们可以定义如下两种运算：\n\n- **函数加法**：对于函数空间中的函数 $f$ 与 $g$ ，定义 $(f+g)(\\vec{x}) = f(x) + g(\\vec{x})$ \n- **函数标量乘法**：对于函数空间中的函数 $f$ 与域上的标量 $a$ ，定义 $(af)(\\vec{x}) = af(\\vec{x})$\n\n容易证明得这两种运算符合八条公理。\n\n我们也可以感性地去认知“函数是无穷维向量”这个结论：对于有限维向量如 $\\vec{v} = \\begin{bmatrix}v_{1}\\\\v_{2}\\end{bmatrix}$ ，有两个分量 $v_{1}$ 和 $v_{2}$ ，其下标 1 和 2 映射到对应的分量，本身就可以认为是定义在集合 $\\{1, 2\\}$ 上的函数。向量的加法、数乘就是相同下标对应分量之间的加法、数乘。\n\n而对于一个定义在 $(a,b)$ 上的函数 $f$ ，他的所有自变量的值都是其分量的下标，所有函数值 $f(x_{0})$ 都是其对应于下标 $x_{0}$ 的分量。对于函数的加法、数乘，都是相同下标下对应分量之间的加法、数乘。 $(a,b)$ 中有无穷个自变量，也即函数 $f$ 是无穷维的向量。\n\n### 函数空间里的 L2 范数\n\n要定义两个函数之间的“距离”，我们跟普通向量一样，需要定义函数空间里的 L2 范数。类比于有限维向量空间：\n\n|            | 有限维向量空间 $\\mathbb{R}^n$                                                | 函数空间                                                      |\n| ---------- | :-------------------------------------------------------------------- | --------------------------------------------------------- |\n| 向量         | 一个N维向量 $\\vec{v}=\\begin{bmatrix}v_1\\\\v_2\\\\ \\vdots \\\\v_n \\end{bmatrix}$ | 一个定义在 $(a,b)$ 上的函数 $f(x)$                                 |\n| 内积         | 所有分量相乘之和 $\\vec{u}\\cdot\\vec{v}=\\Sigma u_{i}v_{i}$                      | 所有分量相乘之和 $\u003cf, g\u003e = \\int_a^b f(x)g(x)\\mathrm{d}x$          |\n| $L_{2}$ 范数 | 向量与自己内积的开方 $\\|\\vec{v}\\|=\\sqrt{ (\\Sigma v_{i}^2) }$                    | 向量与自己内积的开方 $\\|f\\|=\\sqrt{ \\int_{a}^b[f(x)]^2\\mathrm{d}x }$ |\n| 微元         | 变化量趋于零（ $\\| \\Delta \\vec{x} \\| \\to 0$ ）时的微小变化 $\\mathrm{d}\\vec{v}$      | 变化量趋于零（ $\\| \\Delta f \\|\\to 0$ ）时的微小变化 $\\delta f$          |\n### 泛函——函数的函数\n\n没想到吧，泛函分析讲这么久，居然还没讲“泛函”。\n\n其实泛函没什么神秘——泛函就是输入为一个函数 $y(x)$ ，输出为一个数 $J[y]$ 的函数。想想编程语言里的高阶函数：既然函数也是一等公民，那函数的参数为一个函数也没什么奇怪的了，对吧。\n\n再回到我们的线性代数与函数空间，我们之前说多元单值函数 $f(x,y)$ 实际上就是输入为一个向量 $\\begin{bmatrix}x\\\\y\\end{bmatrix}$，输出为一个数 $f(x,y)$ 的函数，那泛函不就是输入为一个无穷维向量的函数呗。\n\n这样干说可能比较抽象，我们来举个🌰：\n\n给定两个点 $A(x_{a}, y_{a})$ 与 $B(x_{b}, y_{b})$ 。在 $[x_{a}, x_{b}]$ 区间上有定义，且过 $A$ 、 $B$ 两点的不同函数，就是两点间的不同路径，他们组成一个函数空间。那么我们可以在这个函数空间上定义如下泛函：\n\n$$\nL[y] = \\int_{a}^b \\sqrt{ 1+(y'(x))^2 } \\mathrm{d}x\n$$\n\n很明显，这个泛函的值就是输入函数在 $A$ 、 $B$ 两点之间的长度。\n\n\u003e [!note]\n\u003e 泛函这个概念最早在欧拉与拉格朗日研究变分问题（寻求具有某种极大或极小性质的曲线）的时候开始有研究。当时还没有泛函（functional）这个名词，而是模糊地称为“曲线的某种极小值”、“最优路径”、“最优形状”。正因这个历史背景，泛函说是函数的函数，但一般输出为一个标量值，与软件工程领域里说的高阶函数有些不同。\n\u003e \n\u003e 但也存在“输入为一个函数，输出为一个函数的函数”，我们一般称之为**算子**。比如求导算子 $D$ 就是这样的一个算子，输入输出都为函数空间里的元素，而且还是一个线性算子： $D(af+bg) = aD(f) + bD(g)$ 。\n\n### 变分——函数的微小变化\n\n变分问题最早提出时，是因为欧拉与拉格朗日在研究类似“**寻求具有某种极大或极小性质的曲线**”的问题。后来，拉格朗日引入变分符号 $\\delta$ 来表示函数的微小变化，从而将求极值问题转化为解微分方程的问题，使得推导过程更加系统和严谨。\n\n回想起我们对微分的定义——函数在局部的线性逼近：\n\n$$\n\\mathrm{d}\\vec{y} = J\\mathrm{d}\\vec{x}\n$$\n\n\u003e 如果我们能找到这样的一个系数矩阵 $J$ ，使得不管要求有多精确，都能找到一个足够窄的范围 $||\\Delta \\vec{x}|| \u003c \\delta$ ，使得这个范围内所有的 $\\mathrm{d}\\vec{y} = J\\mathrm{d}\\vec{x}$ 都符合精度地近似于 $\\Delta \\vec{y} = f(\\vec{x_{0}} + \\Delta \\vec{x}) - f(\\vec{x_{0}})$ ，即对于任何方向 $\\vec{e}$ 的 $\\Delta \\vec{x}=h\\vec{e}$ ，都有 $||\\frac{\\Delta \\vec{y} - \\mathrm{d}\\vec{y}}{h}|| \u003c \\epsilon$ ，其中 $h=||\\Delta \\vec{x}||$ 。\n\n既然函数空间也是一个向量空间，那我们也可以仿照向量微分来定义函数的变分 $\\delta y$ 与泛函的变分 $\\delta J[y]$。\n\n假设我们有定义在区间 $[a, b]$ 上的一个光滑函数 $\\hat{y} = \\hat{y}(x)$ ，假如有一个与 $\\hat{y}$ 足够像的光滑函数 $y = \\hat{y} + \\delta y$ ，使得：\n\n$$\n||\\delta y|| = \\sqrt{ \\int_{a}^b [\\delta y(x)]^2  \\mathrm{d}x }\n$$\n\n足够小，则我们称 $\\delta y$ 为函数 $y$ 的变分。\n\n可以知道，变分 $\\delta y$ 也是一个函数，但他的函数值处处都非常接近为 0 。我们也可类似的到 $\\delta y' = y' - \\hat{y}'$ ，也是一个函数值处处都几乎为零的函数。（变分可以理解为一个趋向于零的函数空间里的差分 $\\Delta y$ ，因此对于线性的求导算子 $D$ 有保持性。）\n\n从此我们就可以定义泛函的变分 $\\delta J[y]$ ：\n\n不管要求的精度范围 $\\delta$ 有多么精确，都能找到一个足够窄的范围 $||\\delta y|| \u003c \\epsilon$ ，使得在这个范围内对任何方向 $\\delta y$ 的微小变化 $\\epsilon\\delta y$ ，都能找到一个值 $\\delta J[y]$ ，使得 $|\\frac{J[y+\\epsilon\\delta y] -J[y]}{\\epsilon}-\\delta J[y]|\u003c\\delta$ 。则称这个 $\\delta J[y]$ 为泛函 $J[y]$ 的变分。\n\n即：\n\n$$\n\\begin{align}\n\\delta J[y;\\delta y] \u0026= \\lim_{ \\epsilon \\to 0 } \\frac{J[y+\\epsilon\\delta y]-J[y]}{\\epsilon}  \\\\\n\u0026= \\frac{\\mathrm{d}}{\\mathrm{d}\\epsilon}J[y+\\epsilon\\delta y] \\Big|_{\\epsilon=0}\n\\end{align}\n$$\n\n其实我们对比回函数的微积分可以发现，泛函的变分 $\\delta J[y]$ 与其说像微积分里的微分 $\\mathrm{d}y$ ，不如说更像是导数 $f'(x)$ 。泛函的变分代表了泛函 $J[y]$ 在某一输入函数 $\\hat{y}$ 附近的，在 $\\delta y$ 方向上的变化率，是一个标量值。\n\n\u003e [!note] 说人话：\n\u003e 泛函的变分 $\\delta J[y]$ 描述了：给输入函数 $y$ 一点微小扰动 $\\delta y$ ，泛函 $\\delta J[y]$ 的结果值是增加还是减少，增加得有多快。\n\n### 变分法基本引理\n\n在讲变分法基本原理之前，我们先从有限维的向量引入。我们考虑以下问题：什么样的向量 $\\vec{v}$ ，能对任何方向的向量 $\\vec{u}$ ，都有内积 $\\langle\\vec{u},\\vec{v}\\rangle ={0}$ 成立？\n\n很明显，这个命题成立，当且仅当 $\\vec{v}=\\mathbf{0}$ 。因为如果 $\\vec{v}\\neq \\mathbf{0}$ ，总能找到一个与 $\\vec{v}$ 同方向的非零向量 $\\vec{u}$ ，使得 $\\langle \\vec{u}, \\vec{v}\\rangle \u003e0$ 。（因为内积有正定性，同向向量的内积总是大于等于 0 ）。\n\n那么，既然函数空间也是一个向量空间，函数是不是也有类似的性质？\n\n是的，这个类似的性质就是“变分法基本引理”。\n\n\u003e [!info] 变分法基本引理\n\u003e \n\u003e 对于区间 $[a, b]$ 内无限光滑的所有函数 $f(x)$ 组成的集合 $C^{\\infty}[a,b]$ ，容易证明其组成一个向量空间。而满足 $h(a) = h(b) = 0$ 的任意函数 $h(x)$ 也属于这个函数空间。\n\u003e \n\u003e 若函数 $f(x) \\in C^{\\infty}[a,b]$ 满足对任意 $h(x)$ ，都有：\n\u003e \n\u003e $$\n\u003e \\langle f, h\\rangle = \\int_{a}^{b} f(x)h(x) \\mathrm{d}x = 0\n\u003e $$\n\u003e \n\u003e 那么这个 $f(x)$ 必然为零函数，即 $f(x)\\equiv 0$ 。换句话说，对于 $\\forall x \\in [a, b]$ ，都有 $f(x) = 0$ 。\n\n证明方法与有限维向量的证明类似，使用反证法：证明只要 $f(x)$ 不为零函数，则必然能找到一个 $h(x)$ 使得 $\\langle f,h\\rangle \\neq 0$ 。\n\n假如函数 $f(x)$ 不为零函数，我们可以设计一个函数 $r(x) \\in C^{\\infty}[a, b]$ ，满足：\n\n$$\n\\begin{align}\n \u0026 r(a) = r(b) = 0 \\\\\n \u0026 \\forall x \\in (a, b) , 有： r(x) \u003e 0\n\\end{align}\n$$\n\n则令 $h(x) = r(x)f(x)$ ，易知 $h(a) = h(b) = 0$ 且 $h(x) \\in C^{\\infty}[a, b]$ 。而且：\n\n$$\n\\langle f, h \\rangle = \\int_{a}^{b} r(x)[f(x)]^2 \\, \\mathrm{d}x \u003e 0 \n$$\n\n与前提矛盾。\n\n因此，如果 $\\langle f, h\\rangle = \\int_{a}^{b} f(x)h(x) \\mathrm{d}x = 0$ ，这个 $f(x)$ 必然为零函数。\n\n\n\u003e [!info]\n\u003e 这是《从线性代数到分析力学》上下两篇中的上篇。下篇为 [[2025-09-29-from-linear-algebra-to-analytical-machanics-1|从线性代数到分析力学（下）]]。","title":"从线性代数到分析力学（上）","abstract":"讲线性代数，被同济版线性代数毒害过的人可能都会被唤醒藏于心底的恐惧：哇！又要讲行列式、对角化、增广矩阵算来算去了！\n其实线性代数没那么可怕。我们可以很直观地、很感性地去理解线性代数。\n线性代数，关键当然在于“线性”。（应该没人会觉得线性代数的关键在于“代数”吧？）如果一个函数 $f(x)$ 有以下性质：","length":646,"created_at":"2025-09-29T13:38:46.000Z","updated_at":"2025-09-29T13:38:50.000Z","tags":[],"license":false,"headingTrees":[{"key":"线性代数","href":"#线性代数","heading":2,"title":"线性代数","children":[{"key":"什么是线性","href":"#什么是线性","heading":3,"title":"什么是线性","children":[],"id":"什么是线性"},{"key":"线性映射的两个重要性质","href":"#线性映射的两个重要性质","heading":3,"title":"线性映射的两个重要性质","children":[],"id":"线性映射的两个重要性质"},{"key":"线性映射与矩阵","href":"#线性映射与矩阵","heading":3,"title":"线性映射与矩阵","children":[],"id":"线性映射与矩阵"},{"key":"向量的长度模或者-l2-范数","href":"#向量的长度模或者-l2-范数","heading":3,"title":"向量的长度：模，或者 L2 范数","children":[],"id":"向量的长度模或者-l2-范数"}],"id":"线性代数"},{"key":"微积分","href":"#微积分","heading":2,"title":"微积分","children":[{"key":"微分的本质是线性逼近","href":"#微分的本质是线性逼近","heading":3,"title":"微分的本质是线性逼近","children":[],"id":"微分的本质是线性逼近"},{"key":"多元函数与多值函数的微分","href":"#多元函数与多值函数的微分","heading":3,"title":"多元函数与多值函数的微分","children":[],"id":"多元函数与多值函数的微分"},{"key":"加减法法则数乘法则与链式法则","href":"#加减法法则数乘法则与链式法则","heading":3,"title":"加减法法则、数乘法则与链式法则","children":[],"id":"加减法法则数乘法则与链式法则"},{"key":"乘法法则","href":"#乘法法则","heading":3,"title":"乘法法则","children":[],"id":"乘法法则"}],"id":"微积分"},{"key":"泛函分析","href":"#泛函分析","heading":2,"title":"泛函分析","children":[{"key":"函数是无穷维向量","href":"#函数是无穷维向量","heading":3,"title":"函数是无穷维向量","children":[],"id":"函数是无穷维向量"},{"key":"函数空间里的-l2-范数","href":"#函数空间里的-l2-范数","heading":3,"title":"函数空间里的 L2 范数","children":[],"id":"函数空间里的-l2-范数"},{"key":"泛函函数的函数","href":"#泛函函数的函数","heading":3,"title":"泛函——函数的函数","children":[],"id":"泛函函数的函数"},{"key":"变分函数的微小变化","href":"#变分函数的微小变化","heading":3,"title":"变分——函数的微小变化","children":[],"id":"变分函数的微小变化"},{"key":"变分法基本引理","href":"#变分法基本引理","heading":3,"title":"变分法基本引理","children":[],"id":"变分法基本引理"}],"id":"泛函分析"},{"key":"footnote-label","href":"#footnote-label","heading":2,"title":"Footnotes","children":[],"id":"footnote-label"}],"wikiRefAliases":["2025-09-29-from-linear-algebra-to-analytical-machanics-1"],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2025-09-04-ygomd-deck-ryzeal-1.md","pagePath":"/articles/ygomd-deck-ryzeal-1","slug":"ygomd-deck-ryzeal-1"},"meta":{"content":"外燃内燃剑极节极……\n兄弟拿兄弟，不用叫，就能跳。\n两个四，绝命导爆，你喊效果我就爆！\n\n开场白？没有！立刻进入正题。\n\n## 特点\n\n正如 [DAODADA](https://www.bilibili.com/video/BV1ZYBuYdEAn/?spm_id_from=333.337.search-card.all.click\u0026vd_source=ba01a1932b530e32e2576726fdda41d7) 中唱的一样，全部下级不用叫就能跳，大哥[[雷火沸动死旋爆震机]]有不限一回合一次的炸卡，一次代破和 3000 点的攻击力。配合场地[[雷火沸动交界机]]阴爆的效果处理时的怪效康，速攻的苏生，能用极其轻量的资源、以相对简单的过程来做成别的卡组打破头都过不去的场子。\n\n## 下级\n\n下级分光属性炎族的燃机，和炎属性雷族的电机两类。共同特点是有两个效果：\n\n1. 不入连锁的特召，特召后会进入从额外特召只能特召四阶超量怪兽的自肃。\n2. 在场上发动的效果。\n\n### 光属性炎族燃机\n\n![外燃雷火沸动机](https://cdn.233.momobako.com/ygopro/pics/34022970.jpg!half)\n\n![内燃雷火沸动机](https://cdn.233.momobako.com/ygopro/pics/8633261.jpg!half)\n\n![星式热气雷火沸动机](https://cdn.233.momobako.com/ygopro/pics/84433129.jpg!half)\n\n燃机共三种：\n\n- [[外燃雷火沸动机]]\n- [[内燃雷火沸动机]]\n- [[星式热气雷火沸动机]]\n\n①效果的不入连锁特召均需要完成一些附加动作才能特召。外燃丢分体的无敌 combo 使外燃的自我特召能力锦上添花，但内燃特召会导致亏卡，而星气的特召条件使得初动手时里的星气变得十分的尴尬。\n\n三种燃机有如下差异：\n\n| 卡名        | ①效果特殊召唤方法        | ②效果触发条件                         | ②效果内容                          |\n| --------- | ---------------- | ------------------------------- | ------------------------------ |\n| 外燃雷火沸动机   | 从额外卡组将1只超量怪兽送去墓地 | 召唤或特殊召唤时，且自己场上不存在4星或4阶以外的表侧表示怪兽 | 从卡组将1只雷族·炎属性怪兽加入手卡             |\n| 内燃雷火沸动机   | 从手卡或场上将1张卡送去墓地   | 仅召唤时                            | 从卡组将「内燃雷火沸动机」以外的1只「雷火沸动」怪兽特殊召唤 |\n| 星式热气雷火沸动机 | 从自己场上取除1个超量素材    | 仅特殊召唤时                          | 从卡组将1张「雷火沸动」魔法·陷阱卡在自己场上盖放      |\n\n可以看出①效果分别需要消耗额外、手场、超量素材。②效果分别能从卡组里检索、特召、盖放，都是重要的赚卡效果。\n\n### 炎属性雷族电机\n\n![剑式阴极雷火沸动机](https://cdn.233.momobako.com/ygopro/pics/35844557.jpg!half)\n\n![节式阳极雷火沸动机](https://cdn.233.momobako.com/ygopro/pics/72238166.jpg!half)\n\n电机共两种：\n\n- [[剑式阴极雷火沸动机]]\n- [[节式阳极雷火沸动机]]\n\n①效果都是达成场上或墓地存在某种怪兽就能特召，而不需要作出特定动作，因此至少不会亏卡。剑极需要「雷火沸动」怪兽，节极需要超量怪兽。②效果两者都是通召或特召都能发动。\n\n| 卡名        | ①效果特殊召唤条件           | ②效果触发条件            | ②效果内容                                                        |\n| --------- | ------------------- | ------------------ | ------------------------------------------------------------ |\n| 剑式阴极雷火沸动机 | 自己的场上或墓地有「雷火沸动」怪兽存在 | 召唤或特殊召唤时           | 从卡组把1只炎族·光属性怪兽加入手卡                                           |\n| 节式阳极雷火沸动机 | 自己的场上或墓地有超量怪兽存在     | 召唤或特殊召唤时（发动需送卡去墓地） | 从手卡或场上把1张卡送去墓地，以「节式阳极雷火沸动机」以外的自己墓地1只「雷火沸动」怪兽为对象，效果无效守备表示特殊召唤 |\n\n## 本家额外\n\n### 二哥\n\n![雷火沸动油电双动机](https://cdn.233.momobako.com/ygopro/pics/7511613.jpg!half)\n\n[[雷火沸动油电双动机]]\n\n二哥是本家的展开部件，常用于展开阶段检索本家场地或魔法陷阱卡，增强资源循环。由于大哥攻击力刚好压在 3000 线上，就算只剩1个素材，攻击力增加 100 点也偶尔会有奇效。\n\n### 大哥\n\n![雷火沸动死旋爆震机](https://cdn.233.momobako.com/ygopro/pics/34909328.jpg!half)\n\n[[雷火沸动死旋爆震机]]\n\n大哥是卡组的主要终端，两个四叠导爆，你喊效果我就爆。简单出场但干扰能力极强，三次效果能对对手的前后场造成毁灭性打击。在吃手坑如“增殖的G”时也能作为妥协场提供多炸保护。\n\n## 魔陷\n\n### 场地\n\n![雷火沸动交界机](https://cdn.233.momobako.com/ygopro/pics/6798031.jpg!half)\n\n[[雷火沸动交界机]]\n\n场地的③效果提供一个不入连锁的怪效康，简直是大赖皮。星气、二哥的检索效果一般都优先给到场地。\n\n### 速攻\n\n![雷火沸动机插电](https://cdn.233.momobako.com/ygopro/pics/60394026.jpg!half)\n\n[[雷火沸动机插电]]\n\n在开局展开资源不足的时候，速攻可以作为辅助展开的手段。更多的时候会盖放到对方回合给大哥一个复活的机会，使大哥可以在必要时炸自己复活躲效果。\n\n## 主要打法\n\n本家[[外燃雷火沸动机]]、[[剑式阴极雷火沸动机]]、[[内燃雷火沸动机]]都可以一卡动，而[[篝火]]、[[时空之七皇]]等卡又可以检索这三个，因此这个卡组主打的就是一个单卡动点多。\n\n另外，大哥素材只需要4星x2简单直接，妥协场可以直接做大哥。\n\n以外燃为例的单卡五步防陨 combo 如下：\n\n- 特召外燃丢分体，检索剑极\n- 剑极特召，检索冰燃\n- 冰燃通招，发效果\n- 冰燃效果卡组特召星气，检索场地盖放，发动场地\n- 两只叠放二哥，此时为第五步，但已经有场地可以康陨石，做到五步防陨。\n\n此时场上剩余2只4星，可以叠放别的4阶超量。二哥效果还未发，可以检索节极、陷阱或速攻。\n\n雷热涡炉的 combo 简单明确，主要思考点在于如何使 5 只下级怪兽各发一遍效果使场值拉到最大做到3只4阶超量，以及如何在效果拉满与防对手手坑之间找到一个平衡。\n\n","title":"【游戏王大学习】雷热涡炉 MD 卡组简介","abstract":"外燃内燃剑极节极……\n兄弟拿兄弟，不用叫，就能跳。\n两个四，绝命导爆，你喊效果我就爆！","length":116,"created_at":"2025-09-04T16:51:28.000Z","updated_at":"2025-09-04T16:53:14.000Z","tags":[],"license":false,"headingTrees":[{"key":"特点","href":"#特点","heading":2,"title":"特点","children":[],"id":"特点"},{"key":"下级","href":"#下级","heading":2,"title":"下级","children":[{"key":"光属性炎族燃机","href":"#光属性炎族燃机","heading":3,"title":"光属性炎族燃机","children":[],"id":"光属性炎族燃机"},{"key":"炎属性雷族电机","href":"#炎属性雷族电机","heading":3,"title":"炎属性雷族电机","children":[],"id":"炎属性雷族电机"}],"id":"下级"},{"key":"本家额外","href":"#本家额外","heading":2,"title":"本家额外","children":[{"key":"二哥","href":"#二哥","heading":3,"title":"二哥","children":[],"id":"二哥"},{"key":"大哥","href":"#大哥","heading":3,"title":"大哥","children":[],"id":"大哥"}],"id":"本家额外"},{"key":"魔陷","href":"#魔陷","heading":2,"title":"魔陷","children":[{"key":"场地","href":"#场地","heading":3,"title":"场地","children":[],"id":"场地"},{"key":"速攻","href":"#速攻","heading":3,"title":"速攻","children":[],"id":"速攻"}],"id":"魔陷"},{"key":"主要打法","href":"#主要打法","heading":2,"title":"主要打法","children":[],"id":"主要打法"}],"wikiRefAliases":["雷火沸动死旋爆震机","雷火沸动交界机","外燃雷火沸动机","内燃雷火沸动机","星式热气雷火沸动机","剑式阴极雷火沸动机","节式阳极雷火沸动机","雷火沸动油电双动机","雷火沸动死旋爆震机","雷火沸动交界机","雷火沸动机插电","外燃雷火沸动机","剑式阴极雷火沸动机","内燃雷火沸动机","篝火","时空之七皇"],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2025-08-18-ygomd-chronicle-cup-six-samurai.md","pagePath":"/articles/ygomd-chronicle-cup-six-samurai","slug":"ygomd-chronicle-cup-six-samurai"},"meta":{"content":"同调杯后紧接着就来了编年史杯。\n\n这次编年史杯环境比较舒适，没有各路神仙横跳。三套预组里六武众在这个环境可以说是风生水起。六武众预组里有新卡三张[[六武众的指南番]]和三张[[六武众的破戒僧]]，额外还放了三张[[真魔六武众-紫炎]]，足够强劲。能出真魔紫炎就赢一半，能出三个终端能赢大部分卡组。\n\n以前算是玩过一点六武众，现在趁杯赛重新学习一下六武众卡组，这篇文章也算是我的学习笔记。可能会有很多很多谬误，如果发现了请评论指正。\n\n## 特点\n\n这套预组延续了六武众一贯的特点：\n\n- 下级补点成堆：六武众的下级有一大半都可以直接从手卡跳上场\n- 武士道指示物：以六武门为代表的一系列的卡，自己特招成功就能放指示物，摘指示物就能赚卡\n- 出一大堆紫炎就能赢\n\n## 下级补点\n\n不计条件苛刻的[[六武众的隐退者]]，六武众下级里能从手牌自己跳出来的怪有四只，其中两张新卡两张老卡。\n\n两张新卡的特招都有同名卡一回合一次，都是调整，送墓都有效果，当作同调素材还有隐藏效果。\n\n两张老卡的特招都没有一回合一次，可以无限回收特招，但没有其他赚卡效果。\n\n| 卡名          | 新/老 | 特招条件            | 离场效果      |\n| ----------- | --- | --------------- | --------- |\n| [[六武众的指南番]] | 新   | 有非同名六武众，一回合一次   | 检索/回收六武式卡 |\n| [[六武众的破戒僧]] | 新   | 有非同名六武众，一回合一次   | 检索六武众速攻   |\n| [[真六武众-辉斩]] | 旧   | 有非同名六武众         |           |\n| [[六武众的师范]]  | 旧   | 有六武众，但同名卡只能存在一张 |           |\n| [[六武众的隐退者]] | 旧   | 对方有怪自己没怪        |           |\n\n预组里只有指南番和破戒僧这两张新卡是调整，即只有Lv2/Lv3的调整。\n\n### [[六武众的指南番]]\n\n![六武众的指南番](https://cdn.233.momobako.com/ygopro/pics/16968936.jpg!half)\n\n新卡，2星调整。\n\n1. 手卡特招\n2. 送墓检索六武式\n3. 隐藏效果：降对面攻\n\n预组里能找的六武式卡只有[[六武式袭双阵]]。\n\n### [[六武众的破戒僧]]\n\n![六武众的破戒僧](https://cdn.233.momobako.com/ygopro/pics/80570228.jpg!half)\n\n1. 手卡特招\n2. 送墓检索六武众速攻魔法\n3. 隐藏效果：降对面星\n\n预组里能找的速攻魔法只有[[六武众的荒行]]。\n\n因为预组里没有 Lv2 非调整，也没有 Lv7 同调，隐藏效果要开出来一般只能靠 3+3 出真魔紫炎。\n\n### [[真六武众-辉斩]]\n\n![真六武众-辉斩](https://cdn.233.momobako.com/ygopro/pics/49721904.jpg!half)\n\n1. 手卡特招\n2. 加攻\n\n没有其他特招限制，在六武门等其他卡配合下，可以无限回收特招。\n\n### [[六武众的师范]]\n\n![六武众的师范](https://cdn.233.momobako.com/ygopro/pics/83039729.jpg!half)\n\n1. 自身限制\n2. 手卡特招\n3. 略\n\n师范5星在预组里比较尴尬，用于同调只能 3+5=8 出御用王。所以师范的用处一般是用来作为连接素材。\n\n## 终端\n\n由于预组里只有 Lv2 和 Lv3 的调整，也没有 Lv2 非调整，因此同调的策略很简单明了。\n\n三个紫炎都有统一的代破效果：场上的这张卡被战斗·效果破坏的场合，可以作为代替把自己场上1只怪兽破坏。\n\n### Lv6 [[真魔六武众-紫炎]]\n\n![真魔六武众-紫炎](https://cdn.233.momobako.com/ygopro/pics/34235530.jpg!half)\n\n新紫炎。\n\n1. 同调时，检索/回手一张六武众/紫炎怪\n2. 怪效康\n3. 代破\n\n比老紫炎平白无故多出一个赚卡效果，这就是时代的威力。\n\n只能 2+4 或 3+3 出。由于限制战士族调整，不能用灰流丽出。\n\n\u003e [!info]\n\u003e 真魔紫炎既是终端，也是 combo 的中转部件。只要是能做真魔紫炎的起手，一般都是起手真魔紫炎先战场，然后再考虑其他（链接军大将调动指示物系统）。\n\n### Lv5 [[真六武众-紫炎]]\n\n![真六武众-紫炎](https://cdn.233.momobako.com/ygopro/pics/29981921.jpg!half)\n\n老紫炎，古老而强大。\n\n1. 魔陷康\n2. 代破\n\n只能 2+3 出，即必须用指南番+影鬼/隐居者。\n\n### [[大将军 紫炎]]\n\n![大将军 紫炎](https://cdn.233.momobako.com/ygopro/pics/63176202.jpg!half)\n\n1. 对方魔陷只能发一次\n2. 代破\n\n能检索到这张卡的只有[[紫炎的狼烟]]、真魔紫炎的效果、[[紫炎的道场]]。由于狼烟、真魔紫炎的效果一般用于检索其他卡，而道场在一般展开中不会去检索，因此大部分情况下都不会摸到这张卡。\n\n\u003e [!info]\n\u003e 大将军紫炎与[[真六武众-紫炎]]同时在场时，如果真紫炎发动效果康对面魔陷，对面仍能发第二次魔陷。因为[[真六武众-紫炎]]的康是发动无效并破坏，对方算作未发动成功。\n\n## 武士道指示物\n\n以[[六武之门]]为代表的一系列卡都有放置武士道指示物的效果。放置指示物的条件都为六武众怪兽双召。放置指示物的条件不分敌我，也就是说对面双召六武众，自己也会加豆，反之亦然。\n\n[[六武众的团结]]与[[紫炎的道场]]只关心自己上面的指示物，使用指示物的效果都为将自己送墓发动的一次性效果。\n\n[[六武众的军大将]]与[[六武之门]]都关心场上所有的武士道指示物。六武门摘指示物发动效果时可以摘场上所有卡上的指示物。\n\n| 卡名          | 放指示物条件  | 放几个 |\n| ----------- | ------- | --- |\n| [[六武众的军大将]] | 链接箭头处双召 | 1   |\n| [[六武之门]]    | 双召      | 2   |\n| [[六武众的团结]]  | 双召      | 1   |\n| [[紫炎的道场]]   | 双召      | 1   |\n\n\u003e [!info]\n\u003e 由于这几张指示物的卡都是延迟启动，需要特招几次六武众才能开始赚卡，因此如果手牌资源不是很充足，一般会选择直接只做紫炎，不会专门进指示物展开。\n\n### L2 [[六武众的军大将]]\n\n![六武众的军大将](https://cdn.233.momobako.com/ygopro/pics/74752631.jpg!half)\n\n1. 链接时检索放指示物的卡\n2. 双召放指示物1\n3. 加攻\n\n登场检索还要丢一手，不算赚，但也算任意两下级就能转进指示物系统。如果资源充足要走指示物展开，一般就是从军大将开始。\n\n### [[六武之门]]\n\n![六武之门](https://cdn.233.momobako.com/ygopro/pics/27970830.jpg!half)\n\n1. 双召放指示物2\n2. 取指示物：加攻/检索/回手/苏生\n\n没有一回合一次！可以看出以前的环境里三门六武众的资源有多恐怖。\n\n很明显六武门就是指示物系统的核心。其他的卡的指示物效果基本可以忽略，只要有门在，那些卡就充当六武门的指示物仓库，给六武门打工。\n\n### [[六武众的团结]]\n\n![六武众的团结](https://cdn.233.momobako.com/ygopro/pics/72345736.jpg!half)\n\n1. 双召放指示物1\n2. 送墓抽卡\n\n六武门的打工仔其之一。如果初始手牌里有，就拍下来当个补点。不会主动检索。\n\n### [[紫炎的道场]]\n\n![紫炎的道场](https://cdn.233.momobako.com/ygopro/pics/47436247.jpg!half)\n\n1. 双召放指示物1\n2. 送墓卡组特招\n\n六武门的打工仔其之二。同上。\n\n## 荒行系统\n\n### [[六武众的荒行]]\n\n![六武众的荒行](https://cdn.233.momobako.com/ygopro/pics/27821104.jpg!half)\n\n①：以自己场上1只「六武众」怪兽为对象才能发动。和那只怪兽是卡名不同并是攻击力相同的1只「六武众」怪兽从卡组特殊召唤。作为对象的怪兽在这个回合的结束阶段破坏。\n\n荒行要求攻击力相等，而由于效果变化过的攻击力也算在内。\n\n一般由破戒僧检索上手。\n\n### 卡组下级攻击力列表\n\n先看预组里各下级在卡组中原本的攻击力。\n\n| 卡名          | ATK  |\n| ----------- | ---- |\n| [[六武众的指南番]] | 200  |\n| [[真六武众-阴鬼]] | 200  |\n| [[六武众的隐退者]] | 400  |\n| [[六武众的破戒僧]] | 500  |\n| [[真六武众-辉斩]] | 1800 |\n| [[影六武众-木猿]] | 1900 |\n| [[六武众的师范]]  | 2100 |\n\n### 常见加攻效果加值\n\n| 效果                 | +ATK | To ATK |\n| ------------------ | ---- | ------ |\n| 阴鬼给自己加攻            | 1500 | 1700   |\n| 辉斩给自己加攻            | 300  | 2100   |\n| 六武门摘2豆             | 500  |        |\n| [[真魔六武众-缘]]战阶（全场）  | 500  |        |\n| [[真魔六武众-辉斩]]战阶（全场） | 600  |        |\n| 军大将给自己加攻（每豆）       | 100  | 1100+  |\n\n可以发现六武门等可以给别的怪加攻的效果都很难被利用到。硬要说的话可以[[六武众的隐退者]] +500 +500 +500 特招[[影六武众-木猿]]，但也已经算是杂技的范畴。\n\n### 常见查找\n\n\n- [[六武众的指南番]]找[[真六武众-阴鬼]]（这样找可以2+3同调出[[真六武众-紫炎]]）\n- [[真六武众-辉斩]]+300 后找[[六武众的师范]]\n- [[六武众的军大将]]偶尔有奇效\n\n这几种查找链都不能反向查找：阴鬼只要有其他六武众就会 +1500 不能找指南番；辉斩原本攻击不是 2100 不能被师范找。\n\n## 其他下级\n\n### [[真六武众-阴鬼]]\n\n![真六武众-阴鬼](https://cdn.233.momobako.com/ygopro/pics/2511717.jpg!half)\n\n1. 通招拉手卡六武众\n2. 加攻\n\n因为其他下级都有自己特招的效果，因此阴鬼最大的作用是特招隐退者和木猿。\n\n### [[影六武众-木猿]]\n\n![影六武众-木猿](https://cdn.233.momobako.com/ygopro/pics/6579928.jpg!half)\n\n1. 特招时检索不同属性的六武众\n2. 墓效代破\n\n特招方法有两种：\n- 阴鬼效果拉出来，但需要阴鬼与木猿同时上手\n- 两只三星叠召来者，从卡组特招。\n\n卡组下级大部分都是地属性，因此基本只能检索风属性的阴鬼和暗属性的破戒僧。而能特招木猿的情况下基本已经通招过了，所以木猿一般用于检索[[六武众的破戒僧]]。\n\n### [[六武众的隐退者]]\n\n![六武众的隐退者](https://cdn.233.momobako.com/ygopro/pics/61737116.jpg!half)\n\n1. 对方有怪自己没怪，手卡特招\n\n打酱油的三星非调整。\n\n## 检索点\n\n### [[紫炎的狼烟]]\n\n![紫炎的狼烟](https://cdn.233.momobako.com/ygopro/pics/54031490.jpg!half)\n\n- 卡组检索3星以下本家\n\n两只调整都是3星以下，都能检索到。\n\n### [[增援]]\n\n![增援](https://cdn.233.momobako.com/ygopro/pics/32807846.jpg!half)\n\n- 检索四星以下战士族\n\n战士族大腿，能检索几乎所有本家。\n\n### R3 [[失X-剑士 招来者]]\n\n![失X-剑士 招来者](https://cdn.233.momobako.com/ygopro/pics/4423206.jpg!half)\n\n- 拔素材特招4星\n\n刚好适合用于特招[[影六武众-木猿]]。阴鬼特招隐退者，刚好3+3又没有调整，此时可以叠招来者特招木猿找调整继续做 combo 。\n\n### [[真魔六武众-紫炎]]\n\n能检索/回手任意本家怪，上面已经提到不再赘述。\n\n## 其他终端\n\n### [[六武式袭双阵]]\n\n![六武式袭双阵](https://cdn.233.momobako.com/ygopro/pics/28273805.jpg!half)\n\n1. 拉手牌/墓地六武众 or 盖对面一只怪。有两只以上六武众可两方适用。\n2. 墓效，回手墓地六武众。\n\n可作为展开的补点，也可盖下去作为终端干扰。一般由指南番检索上手。\n\n### [[影六武众-理伴]]\n\n![影六武众-理伴](https://cdn.233.momobako.com/ygopro/pics/33964637.jpg!half)\n\n1. 取对象除外卡\n2. 墓效代破\n\n偶尔有奇效。然而出场条件太苛刻，几乎没有用到的机会。\n\n## 展开\n\n以下为一个阴鬼拉木猿的二卡做完 combo ：\n\n1. 通招[[真六武众-阴鬼]]，手牌拉[[影六武众-木猿]]，效果检索[[六武众的破戒僧]]\n2. 阴鬼+破戒僧=[[真魔六武众-紫炎]]，真魔检索[[六武众的指南番]]，破戒僧检索[[六武众的荒行]]\n3. 指南番自跳，荒行点指南番特招[[真六武众-阴鬼]]\n4. 指南番+阴鬼=[[真六武众-紫炎]]，指南番检索[[六武式袭双阵]]\n5. 袭双阵效果苏生[[六武众的指南番]]\n6. 指南番+木猿=[[真魔六武众-辉斩]]\n\n实际上，杯赛里这套预组 combo 十分自由。基本可以遵循以下流程：\n\n1. 如果手里有指示物那几张卡，就先拍下去，如果对手对着这几张交康就再好不过。\n2. 能做真魔紫炎，就尽量先做真魔紫炎。真魔紫炎找调整/非调整中缺少的那一方 or 荒行的对象，继续扩大场值。\n3. 不能做真魔紫炎的场合，考虑能否做失 X 继续特招木猿做 combo 。\n4. 连失 X 都做不了，最后考虑做军大将找六武门会不会有奇效。\n\n## 参考文献\n\n- [【游戏王MD】主题编年史杯六武众预组介绍_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1qUY4zgE5L/?spm_id_from=333.337.search-card.all.click\u0026vd_source=ba01a1932b530e32e2576726fdda41d7)\n","title":"【游戏王大学习】六武众——游戏王 MD 2025-08编年史杯六武众预组","abstract":"同调杯后紧接着就来了编年史杯。\n这次编年史杯环境比较舒适，没有各路神仙横跳。三套预组里六武众在这个环境可以说是风生水起。六武众预组里有新卡三张[[六武众的指南番]]和三张[[六武众的破戒僧]]，额外还放了三张[[真魔六武众-紫炎]]，足够强劲。能出真魔紫炎就赢一半，能出三个终端能赢大部分卡组。\n以前算是玩过一点六武众，现在趁杯赛重新学习一下六武众卡组，这篇文章也算是我的学习笔记。可能会有很多很多谬误，如果发现了请评论指正。","length":330,"created_at":"2025-08-18T17:22:37.000Z","updated_at":"2025-08-18T17:23:32.000Z","tags":["游戏王","游戏王MD","游戏王大师决斗","杂谈"],"license":false,"headingTrees":[{"key":"特点","href":"#特点","heading":2,"title":"特点","children":[],"id":"特点"},{"key":"下级补点","href":"#下级补点","heading":2,"title":"下级补点","children":[{"key":"六武众的指南番","href":"#六武众的指南番","heading":3,"title":"六武众的指南番","children":[],"id":"六武众的指南番"},{"key":"六武众的破戒僧","href":"#六武众的破戒僧","heading":3,"title":"六武众的破戒僧","children":[],"id":"六武众的破戒僧"},{"key":"真六武众-辉斩","href":"#真六武众-辉斩","heading":3,"title":"真六武众-辉斩","children":[],"id":"真六武众-辉斩"},{"key":"六武众的师范","href":"#六武众的师范","heading":3,"title":"六武众的师范","children":[],"id":"六武众的师范"}],"id":"下级补点"},{"key":"终端","href":"#终端","heading":2,"title":"终端","children":[{"key":"lv6-真魔六武众-紫炎","href":"#lv6-真魔六武众-紫炎","heading":3,"title":"Lv6 真魔六武众-紫炎","children":[],"id":"lv6-真魔六武众-紫炎"},{"key":"lv5-真六武众-紫炎","href":"#lv5-真六武众-紫炎","heading":3,"title":"Lv5 真六武众-紫炎","children":[],"id":"lv5-真六武众-紫炎"},{"key":"大将军-紫炎","href":"#大将军-紫炎","heading":3,"title":"大将军 紫炎","children":[],"id":"大将军-紫炎"}],"id":"终端"},{"key":"武士道指示物","href":"#武士道指示物","heading":2,"title":"武士道指示物","children":[{"key":"l2-六武众的军大将","href":"#l2-六武众的军大将","heading":3,"title":"L2 六武众的军大将","children":[],"id":"l2-六武众的军大将"},{"key":"六武之门","href":"#六武之门","heading":3,"title":"六武之门","children":[],"id":"六武之门"},{"key":"六武众的团结","href":"#六武众的团结","heading":3,"title":"六武众的团结","children":[],"id":"六武众的团结"},{"key":"紫炎的道场","href":"#紫炎的道场","heading":3,"title":"紫炎的道场","children":[],"id":"紫炎的道场"}],"id":"武士道指示物"},{"key":"荒行系统","href":"#荒行系统","heading":2,"title":"荒行系统","children":[{"key":"六武众的荒行","href":"#六武众的荒行","heading":3,"title":"六武众的荒行","children":[],"id":"六武众的荒行"},{"key":"卡组下级攻击力列表","href":"#卡组下级攻击力列表","heading":3,"title":"卡组下级攻击力列表","children":[],"id":"卡组下级攻击力列表"},{"key":"常见加攻效果加值","href":"#常见加攻效果加值","heading":3,"title":"常见加攻效果加值","children":[],"id":"常见加攻效果加值"},{"key":"常见查找","href":"#常见查找","heading":3,"title":"常见查找","children":[],"id":"常见查找"}],"id":"荒行系统"},{"key":"其他下级","href":"#其他下级","heading":2,"title":"其他下级","children":[{"key":"真六武众-阴鬼","href":"#真六武众-阴鬼","heading":3,"title":"真六武众-阴鬼","children":[],"id":"真六武众-阴鬼"},{"key":"影六武众-木猿","href":"#影六武众-木猿","heading":3,"title":"影六武众-木猿","children":[],"id":"影六武众-木猿"},{"key":"六武众的隐退者","href":"#六武众的隐退者","heading":3,"title":"六武众的隐退者","children":[],"id":"六武众的隐退者"}],"id":"其他下级"},{"key":"检索点","href":"#检索点","heading":2,"title":"检索点","children":[{"key":"紫炎的狼烟","href":"#紫炎的狼烟","heading":3,"title":"紫炎的狼烟","children":[],"id":"紫炎的狼烟"},{"key":"增援","href":"#增援","heading":3,"title":"增援","children":[],"id":"增援"},{"key":"r3-失x-剑士-招来者","href":"#r3-失x-剑士-招来者","heading":3,"title":"R3 失X-剑士 招来者","children":[],"id":"r3-失x-剑士-招来者"},{"key":"真魔六武众-紫炎","href":"#真魔六武众-紫炎","heading":3,"title":"真魔六武众-紫炎","children":[],"id":"真魔六武众-紫炎"}],"id":"检索点"},{"key":"其他终端","href":"#其他终端","heading":2,"title":"其他终端","children":[{"key":"六武式袭双阵","href":"#六武式袭双阵","heading":3,"title":"六武式袭双阵","children":[],"id":"六武式袭双阵"},{"key":"影六武众-理伴","href":"#影六武众-理伴","heading":3,"title":"影六武众-理伴","children":[],"id":"影六武众-理伴"}],"id":"其他终端"},{"key":"展开","href":"#展开","heading":2,"title":"展开","children":[],"id":"展开"},{"key":"参考文献","href":"#参考文献","heading":2,"title":"参考文献","children":[],"id":"参考文献"}],"wikiRefAliases":["六武众的指南番","六武众的破戒僧","真魔六武众-紫炎","六武众的隐退者","六武众的指南番","六武众的破戒僧","真六武众-辉斩","六武众的师范","六武众的隐退者","六武众的指南番","六武式袭双阵","六武众的破戒僧","六武众的荒行","真六武众-辉斩","六武众的师范","真魔六武众-紫炎","真六武众-紫炎","大将军 紫炎","紫炎的狼烟","紫炎的道场","真六武众-紫炎","真六武众-紫炎","六武之门","六武众的团结","紫炎的道场","六武众的军大将","六武之门","六武众的军大将","六武之门","六武众的团结","紫炎的道场","六武众的军大将","六武之门","六武众的团结","紫炎的道场","六武众的荒行","六武众的指南番","真六武众-阴鬼","六武众的隐退者","六武众的破戒僧","真六武众-辉斩","影六武众-木猿","六武众的师范","真魔六武众-缘","真魔六武众-辉斩","六武众的隐退者","影六武众-木猿","六武众的指南番","真六武众-阴鬼","真六武众-紫炎","真六武众-辉斩","六武众的师范","六武众的军大将","真六武众-阴鬼","影六武众-木猿","六武众的破戒僧","六武众的隐退者","紫炎的狼烟","增援","失X-剑士 招来者","影六武众-木猿","真魔六武众-紫炎","六武式袭双阵","影六武众-理伴","真六武众-阴鬼","影六武众-木猿","六武众的破戒僧","真魔六武众-紫炎","六武众的指南番","六武众的荒行","真六武众-阴鬼","真六武众-紫炎","六武式袭双阵","六武众的指南番","真魔六武众-辉斩"],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2025-08-10-ygomd-synchro-cup-crystron.md","pagePath":"/articles/ygomd-synchro-cup-crystron","slug":"ygomd-synchro-cup-crystron"},"meta":{"content":"\n这次的同调杯三个预组中，唯一算是比较有强度的就是水晶机巧了。\n\n水机卡组刚出来的时候我也算是小小玩过，但现在的水晶机巧已经跟第 9 期那时完全不同打法了。连一刻都没有为继承玻纤的死亡哀悼，立即赶到 MD 的是 12 期的五张新卡！三位玉晶、柠晶救龙、圣天骸晶、绿阵、红阵，5张新时代的补强可以说完全重构了水晶机巧这个卡组。\n\n为了打这次同调杯，我专门重新学习了水机卡组。这篇文章也算是学习过程中的总结笔记。可能会有很多很多谬误，如果发现了请评论指正。\n\n## 关键卡\n\n### [[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/25865565.jpg!half)\n\n新柠晶， combo 核心。\n\n1. 炸场上一水机卡跳上场。自肃额外卡组只能特招机械族。\n2. 双召时卡组堆两张不同名水机卡。\n\n\u003e [!info]\n\u003e 水晶机巧 combo 启动的关键在于新卡[[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]跳出来堆二。\n\u003e \n\u003e 救龙能跳就能打完 \n\u003e =\u003e [[80-水晶机巧·内蕴|水晶机巧·内蕴]]一卡就能跳救龙 \n\u003e =\u003e [[10-水晶机巧-烟晶虎|水晶机巧-烟晶虎]]进墓能找内蕴\n\u003e =\u003e [[废铁回收员]]（垃圾桶）可以堆烟晶虎\n\u003e \n\u003e 因此，水机的内蕴/愚埋/垃圾桶可以一卡动。\n\n\n### [[80-水晶机巧·内蕴|水晶机巧·内蕴]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/31552317.jpg!half)\n\n本家绿阵。\n\n1. 发动时检索其他水机卡\n2. 自己所有水机各一次战破抗性\n3. 墓地除外，苏生一只水机\n\n最大用处是被救龙炸掉，因此2效果基本没有存在感。\n\n### [[10-水晶机巧-烟晶虎|水晶机巧-烟晶虎]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/83443619.jpg!half)\n\n1. 炸自己场上表侧卡，从卡组特招水机调整，进老自肃。\n2. 墓地除外发动，检索一张水机魔陷。\n\n2效果能检索绿阵，因此要想办法让烟晶虎进墓地。\n\n\u003e [!info]\n\u003e 水晶机巧有新老两种自肃：\n\u003e - 老自肃：额外只能特招机械族同调怪兽\n\u003e - 新自肃：额外只能特招机械族怪兽\n\u003e \n\u003e 新自肃比老自肃宽松一点，可以出其他融合超量链接。只有救龙和三位玉晶这两张新卡是新自肃，其他非调整的下级是老自肃，而除三位白晶外的调整、以及柠晶法夫纳（老柠晶）都没有自肃。\n\u003e \n\u003e 一般来说展开过程中只会触发新自肃。\n\n\u003e  本来水机卡组里烟晶虎也能占通招点一卡动：通招烟晶虎，链接 Link1 让烟晶虎进墓。但这次同调杯没有 Link1 可用， so ……\n\n### [[废铁回收员]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/4334811.jpg!half)\n\n垃圾桶，墓效机械族卡组永远的神。堆墓范围能覆盖到全体水机本家。\n\n1. 双召发动，堆墓一只机械族怪兽\n2. 不太重要\n\n垃圾桶通招就能堆烟晶虎，也算是个动点。然而与[[00-水晶机巧-三位玉晶|三位玉晶]]抢通招点，如果被灰泡遮可能直接停牌。\n\n### [[31-水晶机巧-柠晶法夫纳|水晶机巧-柠晶法夫纳]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/3422200.jpg!half)\n\n老柠晶。\n\n1. 丢手里一张其他水机起跳，然后炸自己场上一卡。\n2. 战破/效破时发动，卡组拉一只水机。\n\n毕竟老卡，没有新柠晶那么牌效拉满了。但也是配合任意水机就能直接二卡启动的动点，而且还没有自肃。\n\n\u003e [!info]\n\u003e 本家四只下级非调整基本只需要使用墓地效果，而两只柠晶在手卡或是墓地都能发效果。因此丢手里的水机本家非调整基本不会亏卡。\n\n### [[00-水晶机巧-三位玉晶|水晶机巧-三位玉晶]] \n\n![](https://cdn.233.momobako.com/ygopro/pics/99471856.jpg!half)\n\n新卡小白人，三位。\n\n1. 对方动时连锁，特招卡组水机并同调。\n2. 墓地除外发动，破坏自己场上同调怪兽，从卡组特招2只水机，进新自肃。\n\n1效果有点吓人，只要在场就能大概率躲掉对面的取对象效果。2效果也是炸一拉二的赚卡行为。\n\n\u003e [!info]\n\u003e 水机 combo 中一个关键赚卡点为墓地的[[00-水晶机巧-三位玉晶|水晶机巧-三位玉晶]]炸场上[[50-水晶机巧-圣天骸晶|水晶机巧-圣天骸晶]]，骸晶被破坏再拉除外的三位玉晶。\n\u003e \n\u003e [[00-水晶机巧-三位玉晶|水晶机巧-三位玉晶]]1效果过于强劲，通招就能形成威慑，可以护航其他卡躲遮泡。\n\n### Lv7 [[50-水晶机巧-圣天骸晶|水晶机巧-圣天骸晶]] \n\n![](https://cdn.233.momobako.com/ygopro/pics/47736165.jpg!half)\n\n7星白，骸晶，重要展开中间件。\n\n- 同调时发动，回收墓地/除外的水机卡\n- 永续效果，对方攻防-500\n- 战破/效破时发动，特招墓地/除外的水机 \n\n一般被三位破坏的就是他。1、3效果资源回收也是 combo 的重要组成部分。除外三位炸骸晶拉2，骸晶被炸拉除外的三位，赚爆。\n\n\n## 终端\n\n### Lv9 [[52-水晶机巧-中枢大蛇|水晶机巧-中枢大蛇]] \n\n![](https://cdn.233.momobako.com/ygopro/pics/13455674.jpg!half)\n\n9星中枢大蛇，大哥，出场要两个以上调整。\n\n- 登场时取对象场墓三叉。\n- 遗言特招除外的一只怪兽。\n\n大哥还是很强的，虽然没有抗性但有个破坏遗言。三位玉晶在场的情况下还能加速出。把对面叉飞后用遗言可以牛过来。\n\n但要注意登场时只能叉怪兽而且取对象，不像三叉那样能不取对象叉任意卡。（但中枢大蛇登场效果不会被卡时点）\n\n\u003e [!info]\n\u003e 中枢大蛇的最佳用法当然是对方回合加速同调。\n\u003e \n\u003e 但预组卡组里有加速同调出大蛇能力的，只有：\n\u003e - Lv2 三位玉晶\n\u003e - Lv4 量子刚玉\n\u003e - Lv5 加速同调士\n\u003e\n\u003e 且只有三位玉晶有加速时拉人的能力。黄玉虽然也能加速拉人同调，但不能直接从黄玉出大蛇。\n\u003e\n\u003e 而同时，三位玉晶只能拉不同名卡，因此当场上有三位玉晶+5时想做加速大蛇，只能拉卡组黄晶。\n\n### [[81-水晶机巧·晶簇|水晶机巧·晶簇]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/53829527.jpg!half)\n\n本家红阵。\n\n1. 自己场上的水机卡不会被对方除外\n2. 取对象发动，墓地、除外1张水机卡回卡组，炸对面1卡（如果有水机同调在场，炸两卡）\n\n1效果上抗性，二效果炸卡带回收，实用性拉满。\n\n由于是陷阱卡，1效果的抗性可以连锁在对方的效果上发动，偷偷赚一个卡差。\n\n\n\u003e [!info]\n\u003e 虽然烟晶虎、绿阵都能将红阵检索上手，但一般展开中，检索链一般为烟晶虎-\u003e绿阵-\u003e柠晶救龙。此时，红阵一般需要先堆进墓地（柠晶救龙双召时），然后再回收上手（骸晶同调时）。\n\u003e \n\n### Lv7 [[方程式运动员 电光赛道名将]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/33158448.jpg!half)\n\n7星赛车，一般由黄晶加速出。\n\n1. 这张卡攻击力跟等级有关\n2. 不重要\n3. 没用\n4. 1回合1次魔陷康，需要自降2星\n\n4效果康是效果的发动无效并破坏，可以康墓效。是小黄单体能出的最简单强力的同调。\n\n康效果需要自降2星，变为5星后可以和量子刚玉加速出轴子凤凰，或是和加速同调士出卫星战士。算是个 Bonus 效果。\n\n\u003e [!info]\n\u003e 上面提到如果场上只有三位玉晶 + 5 ，卡组必须要有黄晶才能加速大蛇。如此可以得出终场是三位、黄晶、柠晶时想要加速大蛇必须以以下顺序打：\n\u003e \n\u003e 1. 黄晶拉柠晶加速赛车\n\u003e 2. 红阵炸1，回收黄晶\n\u003e 3. 三位拉黄晶，与场上柠晶 2+2+5 加速大蛇\n\u003e \n\u003e 可以看出顺序要求十分严格，所以如果想以加速大蛇为主，尽量不要留 225 在场。\n\n## 其他主卡组\n\n水晶机巧的主卡怪兽主要可以分三种：\n\n- 4星以下非调整（四色圣兽）\n- 5星非调整（新老柠晶）\n- 1、2、3星调整（各色小人）\n\n### 5星非调整\n\n其实只有[[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]与[[31-水晶机巧-柠晶法夫纳|水晶机巧-柠晶法夫纳]]，之前都已经介绍过了。\n\n两只的一效果都是在手卡·墓地的场合，xxx才能发动，这张卡特招。因此把他们俩当 cost 丢进墓地也不亏卡，把他们对进墓地相当于检索上手。\n\n| 不同点    | 救龙           | 法夫纳          |\n| ------ | ------------ | ------------ |\n| 1效果条件  | 取对象破坏自己场上水机卡 | 丢弃手卡其他水机卡    |\n| 1效果副作用 | 破坏取对象的卡，进自肃  | 破坏自己场上一卡     |\n| 2效果    | 双召发动，堆墓两水机卡  | 双破发动，从卡组特招水机 |\n\n两只都是同名卡一二效果各一回合一次。\n\n### 4星以下非调整\n\n![](https://cdn.233.momobako.com/ygopro/pics/83443619.jpg!half)\n\n![](https://cdn.233.momobako.com/ygopro/pics/29838323.jpg!half)\n\n4星以下非调整共四只，分别是四色圣兽，都是老卡。\n\n- [[13-水晶机巧-绿晶龟|水晶机巧-绿晶龟]]\n- [[10-水晶机巧-烟晶虎|水晶机巧-烟晶虎]]\n- [[11-水晶机巧-紫晶龙|水晶机巧-紫晶龙]]\n- [[12-水晶机巧-红晶雀|水晶机巧-红晶雀]]\n\n四只都有共通的效果模版：\n\n\u003e 这个卡名的①②的效果1回合只能有1次使用其中任意1个。 \n\u003e \n\u003e ①：以自己场上1张表侧表示的卡为对象才能发动。那张卡破坏，从卡组把1只「水晶机巧」调整特殊召唤。这个效果的发动后，直到回合结束时自己不是机械族同调怪兽不能从额外卡组特殊召唤。\n\u003e   \n\u003e ②：把墓地的这张卡除外才能发动。XXX。\n\n一效果共通为场上效果，会进入老自肃。二效果都为墓地效果。\n\n要注意四只都是同名卡一二效果只能发其一。时代感拉满了。\n\n| 卡名  | 等级  | 二效果的效果部分               |\n| --- | --- | ---------------------- |\n| 绿晶龟 | 2   | 从手牌特招水机                |\n| 烟晶虎 | 3   | 从牌组检索水机魔陷              |\n| 紫晶龙 | 3   | 从牌组检索其他水机怪兽            |\n| 红晶雀 | 4   | 特招水机衍生物（机械族・水・星1・攻/守0） |\n\n四只里主要关注能检索的[[10-水晶机巧-烟晶虎|水晶机巧-烟晶虎]]与[[11-水晶机巧-紫晶龙|水晶机巧-紫晶龙]]。龟和雀基本只有三位拉出来凑素材的用处。\n\n\u003e 虽然烟晶虎和紫晶龙都是检索，但烟晶虎-\u003e绿阵-\u003e柠晶救龙的路线里救龙可以直接炸绿阵跳上场，而紫晶龙-\u003e柠晶救龙却少一个绿阵无卡可炸。因此水机卡组里烟晶虎下3，紫晶龙下1。\n\n### 主卡组调整\n\n![](https://cdn.233.momobako.com/ygopro/pics/20050865.jpg!half)\n\n水机的主卡组调整有一张新卡：\n\n- [[00-水晶机巧-三位玉晶|水晶机巧-三位玉晶]]（2星）\n\n和三张老卡：\n\n- 水晶机巧-量子白晶（1星）\n- [[01-水晶机巧-黄晶|水晶机巧-矩阵黄晶]]（2星）\n- 水晶机巧-胶子黑晶（3星）\n\n同调杯预组里除了三位白晶以外只下了一张黄晶，但这也足够了。（因为除了三位玉晶以外都很菜）\n\n三张老卡有共通模板：\n\n\u003e 同名卡1回合1次。  \n\u003e \n\u003e ①：对方的主要阶段以及战斗阶段，以调整以外的【XXX区域】的1只自己怪兽为对象才能发动。那只怪兽效果无效特殊召唤，只用那只怪兽和这张卡为素材把1只机械族同调怪兽同调召唤。那个时候的同调素材怪兽不去墓地而去【XXX区域】。\n\n|      | 从哪特招   | 同调后去哪 |\n| ---- | ------ | ----- |\n| 白晶   | 手卡     | 墓地    |\n| 黄晶   | 墓地     | 除外    |\n| 黑晶   | 除外     | 回卡组   |\n| 三位白晶 | **卡组** | 墓地    |\n\n\u003e [!info]\n\u003e \n\u003e 除三位玉晶外的下级的加速都只能用自己和拉出来的那张卡做素材，无论如何都无法直接加速出大蛇。\n\n三位玉晶的效果更为现代，上面[[#00-水晶机巧-三位玉晶 水晶机巧-三位玉晶|关键卡章节]]已经讲过了，不再赘述。\n\n值得注意的是三位玉晶的加速同调效果只要求将特招的那张卡作为素材，不要求三位玉晶自己也作为同调素材。\n\n\u003e [!info]\n\u003e 机械族同调怪兽从7星以上起才比较强力，而墓地里一般会有5星（两柠晶），正好配合黄晶同调。因此三张老卡中，黄晶会比另外两个更重要。\n\n\n### [[02-瀑征龙-潮龙|瀑征龙-潮龙]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/26400609.jpg!half)\n\n征龙大哥，再带我们冲一次吧。\n\n水属性卡组专用的愚埋，直接转进烟晶虎绿阵 combo 。就是要两手启动，以前超主流的强劲效果现在已经快跟不上时代了。\n\n因为预组卡组里有带[[碧钢之机龙]]，所以黄晶可以拉瀑征龙 2+7 ，除外瀑征龙还能再检索另一张瀑征龙。\n\n然而瀑征龙自己跳上场没有太大用处，而且本家基本上都是墓效，除外两张跳瀑征龙太亏了。\n\n\n## 其他额外\n\n\n\u003e [!info]\n\u003e 水机的额外还在世的都是同调怪兽，效果有类似的模板。\n\u003e - 一效果都为这张卡同调召唤成功的场合发动的登场效果。（除量子刚玉外）\n\u003e - 二效果都为同调召唤的这张卡被战斗·效果破坏的场合发动的遗言效果。（圣天骸晶为三效果）\n\u003e \n\u003e 继承玻纤😭，我的继承玻纤😭，没有你我还怎么活啊😭\n\n\n### Lv4 [[51-水晶机巧-量子刚玉白晶|水晶机巧-量子刚玉]] \n\n![](https://cdn.233.momobako.com/ygopro/pics/39964797.jpg!half)\n\n跟加速同调士比起来优点就是能战阶同调，以及是本家。\n\n预组里轴子凤凰只能通过量子刚玉出，所以几乎只在必须要轴子凤凰的情况下才会考虑。\n\n### Lv5 [[54-水晶机巧-矩阵紫黄晶|水晶机巧-矩阵紫黄晶]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/76359406.jpg!half)\n\n效果是来打酱油的，不会主动出。有时需要用三位调度烟晶虎或紫晶龙的时候才会出一下。\n\n### Lv9 [[53-水晶机巧-量子红雀白晶|水晶机巧-轴子凤凰]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/2743001.jpg!half)\n\n效果是够强力了，但需要 S 调整 + S 其他，很难登场。\n\n### Lv5 [[加速同调士]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/37675907.jpg!half)\n\nOCG 中一般用于在对方回合加速同调规避自肃，但预组里没有鲜花。\n\n### Lv9 [[碧钢之机龙]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/80040886.jpg!half)\n\n需要 2+7 ，一般是黄晶拉墓地 7 星出。\n\n然而无效效果的对象数量取决于墓地里调整的数量，一般要先出大蛇才有足够的威力。\n\n因为预组里只有一张赛车，算是 T3 用完赛车后的平替。\n\n\n### Lv10 [[相剑大公-承影]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/96633955.jpg!half)\n\n更像是预组里没有鲜花才选的妥协终端。与黄晶配合除外，同时还有弱压制能力。\n\n一般是 5+5 加速与柠晶出。因为只有黄晶有对方回合除外卡的能力，所以效果想要开出来需要场上有黄晶。\n\n### Lv10 [[卫星战士]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/84664085.jpg!half)\n\n需要调整+S其他。\n\n展开一般会有 5、7 的S做终场，但预组里没有 3 调整。因此只能用加速同调士出，会跟轴子凤凰抢生态位。\n\n### Lv12 [[骑士皇 雷加蒂娅]]\n\n![](https://cdn.233.momobako.com/ygopro/pics/15982593.jpg!half)\n\n通招三位护航柠晶救龙的展开中，需要从卡组拉黄晶才能与救龙同调躲对象。但如果黄晶在手上，此时可以从卡组拉另一只柠晶，2+5+5 躲对象并抽一。\n\n## 展开终端\n\n由上面分析已经可以得出基本的烟晶虎找绿阵 combo 。以废铁回收员一卡动为例：\n\n1. 通招[[废铁回收员]]堆墓[[10-水晶机巧-烟晶虎|水晶机巧-烟晶虎]]，烟晶虎除外检索[[80-水晶机巧·内蕴|水晶机巧·内蕴]]（绿阵），发动绿阵检索[[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]\n2. 救龙炸绿阵起跳，堆红阵、[[00-水晶机巧-三位玉晶|水晶机巧-三位玉晶]]。这里假设手卡没有其他水机卡。而通招也用过了，如果选择堆紫晶龙或柠晶法夫纳的话会打不下去。优先调度三位出骸晶为重。\n3. 除外绿阵拉三位\n4. 三位救龙同调[[50-水晶机巧-圣天骸晶|水晶机巧-圣天骸晶]]，骸晶回收红阵\n5. 三位炸骸晶，效果分别拉[[01-水晶机巧-黄晶|水晶机巧-矩阵黄晶]]、三位、三位，盖红阵过\n\n到对方回合，黄晶先动出[[方程式运动员 电光赛道名将|方程式运动员 光明御主]]，然后：\n- 红阵炸一回收黄晶\n- 三位拉[[31-水晶机巧-柠晶法夫纳|水晶机巧-柠晶法夫纳]]，三位+三位+法夫纳加速大蛇\n\n可以以任意顺序动。\n\n\u003e [!info]\n\u003e 这种展开场上会呆站一个垃圾桶。要灵活运用场上的垃圾桶，需要用下面讨论的 2223 / 2253 变式。\n\n三位炸骸晶这步拉出来三张卡选择上比较关键，不同的组合决定了不同的终端。\n\n### 222\n\n\u003e [!info]\n\u003e 三位+三位+黄晶。\n\u003e \n\u003e 终场为红阵+赛车+加速大蛇。一炸三叉一魔陷康。\n\u003e \n\u003e 如果先用赛车效果，加速大蛇可以换为卫星战士 or 轴子凤凰。\n\n正是上面示例 combo 的打法。\n\n到对方回合，黄晶先动出[[方程式运动员 电光赛道名将|方程式运动员 光明御主]]，然后：\n- 红阵炸一回收黄晶\n- 三位拉[[31-水晶机巧-柠晶法夫纳|水晶机巧-柠晶法夫纳]]，三位+三位+法夫纳加速大蛇\n\n优点是交康的顺序比较自由，黄晶是 freechain ，而红阵、大蛇、赛车之间的顺序没有要求。\n\n赛车如果先发效果变5星，而对方比较依赖于魔陷，可以改为如下变式：\n\n1. 三位+2=量子刚玉\n2. 4+5=轴子凤凰清一波\n\n### 225\n\n\u003e [!info]\n\u003e 三位+黄晶+柠晶。\n\u003e \n\u003e 终场为红阵+承影+赛车，一炸、二叉、一魔陷康\n\n在对方回合，三位先动：\n\n1. 三位+3星=[[加速同调士]]\n2. 加速+柠晶，5+5=[[相剑大公-承影]]\n3. 黄晶+5=赛车魔陷康，此时承影还可以二叉\n4. 红阵炸一回收黄晶\n\n优点非要说的话是承影压制力强一点点，如果场值更多，变化会更多。而且理论上大蛇的三叉通常打不满，承影的二叉已经足够。\n\n缺点也很明显，各个干扰要按顺序交才能打完，如果黄晶被先瞄准，甚至承影除外都开不出来。\n\n如果黄晶先被瞄准，可以先黄晶+5=赛车，舍弃承影路线。但此时如果红阵开效果前三位就被瞄准，无法直接加速大蛇（黄晶不在卡组）。此时可：\n\n- 赛车先开效果，(三位+3)+5=卫星战士炸卡，或(三位+2)+5=轴子凤凰清后场\n- 赛车后开效果，只能先做骸晶当个续航，或赌对手行动做S调整祈祷能当个干扰\n\n### 227\n\n\u003e [!info]\n\u003e 三位+黄晶+骸晶\n\u003e \n\u003e 红阵炸2，终场为红阵、骸晶、5星赛车后变卫星战士/轴子凤凰/加速大蛇。\n\n骸晶被炸可以从墓地苏生骸晶，场上黄晶+三位+骸晶。\n\n优点是红阵可以随时炸2，如果先用赛车的话也能出卫星战士/轴子凤凰/加速大蛇。\n\n缺点是如果想加速大蛇，必须先发动红阵回收黄晶。\n\n\n### 223 （妥协场）\n\n\u003e [!info]\n\u003e 三位+三位+烟晶虎\n\u003e \n\u003e 妥协场，终场为红阵+加速大蛇 or 赛车变卫星战士\n\n做 223 一般是救龙被灰，调度不到红阵也堆不了烟晶虎的情况，需要卡组特招一个烟晶虎堆下去检索红阵做妥协。\n\n1. 三位+烟晶虎 = 加速\n2. 对方回合，三位+2+加速=加速大蛇 or 三位+5=赛车\n\n赛车用完效果后可以加速+5星赛车=卫星战士，或自己回合加速主动变4星，加速+5星赛车=轴子凤凰\n\n### 2223 or 2253 （垃圾桶场、加速场）\n\n\u003e [!info]\n\u003e 三位+加速+黄晶 or 三位+加速+柠晶，有红阵。\n\u003e \n\u003e 终场与 222 / 225 一样，没有扩大，但更灵活。\n\u003e \n\u003e - 2223型：红阵+赛车+加速大蛇/卫星战士\n\u003e - 2253型：红阵+承影+赛车\n\n在自己回合用一个三位与3星做成了[[加速同调士]]。\n\n四点场值，有两种情况：\n\n1. [[废铁回收员]]展开，最后废铁回收员留场，必成这种情况。\n2. 三位炸骸晶时拉 223 or 235 ，选择先同调[[加速同调士]]后绿阵苏生三位。\n\n与 222 、 225 相比，一个三位变为了一个加速同调士的 freechain 加速同调点。对顺序的要求变得更宽松：\n\n- 2223 与 222 相比，一方面保留了加速大蛇的能力（三位拉绿晶龟与加速同调，2+5+2 ），三位被康时可以多一次 5+5 的机会。\n- 2253 与 225 相比，freechain 必出承影，黄晶先被瞄准的可能性降低。\n\n\n但可以看出，与 222 、 225 相比终场并没有扩大。\n\n\u003e 2273 与 227 相比，失去赛车变五星前动的能力，赛车变五星后也不能做轴子凤凰或加速大蛇。所以一般不做 2273 。\n\n\u003e 2223 还有一个变式为 2222 ，即加速同调士换为量子刚玉，优点为红阵可以随时炸2。\n\n\n### 2275 （赛车场）\n\n\u003e [!info]\n\u003e 三位+赛车+骸晶\n\u003e \n\u003e 终场与 227 一样，但更灵活。\n\u003e \n\u003e 红阵炸2，终场为红阵、骸晶、5星赛车后变卫星战士/轴子凤凰/加速大蛇。\n\n在自己回合用三位与5星同调出了赛车。\n\n四点场值：\n\n- 三位炸骸晶时拉 225 or 257 ，选择先同调出[[方程式运动员 电光赛道名将|方程式运动员 光明御主]]后绿阵再苏生一次。\n\n相当于 227 中黄晶在自己回合就已经做成了赛车。因此三位与五星赛车加速大蛇不需要顾虑回收黄晶。\n\n同样，与 227 比场面没有扩大，只是更灵活。\n\n\u003e 如果做 2225 ，与 222 相比终场基本一样。因此不做 2225 。 2255 更不用说，退化成了 225 的妥协场。\n\n### 2223+绿阵 or 2253+绿阵 or 2273+绿阵（最大场）\n\n\u003e [!info]\n\u003e 222/225/227 + 三星 + 墓地绿阵\n\u003e \n\u003e 222 型终端：红阵+赛车+加速大蛇，赛车五星后多一个卫星战士。\n\u003e 225 型终端：红阵+承影+赛车+三位动点，赛车五星后多一个卫星战士/轴子凤凰。\n\u003e 227 型终端：红阵+骸晶+赛车+卫星战士/加速大蛇。比纯 227 型顺序灵活。\n\n这个场需要四点场值，且墓地有绿阵。\n\n能做这个场，一般需要展开 combo 到三位炸骸晶前，保留绿阵墓效，且除绿阵以外的三个场值全部调度到。即天胡起手且没被打断。\n\n这个场可以先三位+3星=加速，除外绿阵苏生三位，场上为 222 / 225 / 227 + 加速同调士。\n\n- 222 型，可以在赛车变5星后在加速大蛇的基础上多做赛车-\u003e卫星战士。\n- 225 型，可以直接加速+5星=承影，不依赖于三位效果，且多一个三位的加速点，赛车变5星后可以赛车-\u003e轴子凤凰，先回收黄晶还可以赛车-\u003e加速大蛇。\n- 227 型，可以用三位+加速直接做卫星/加速大蛇，不需要等赛车发效果。（预组这里做不了轴子凤凰，因为没有四星非调整S）\n\n\u003e 如果只能垃圾桶单卡展开，不拿红阵也能做这个场。此时三星为垃圾桶自己。\n\u003e \n\u003e 垃圾桶妥协因为没有红阵， 225 型里的三位不能通过调度卡组里的黄晶进行加速大蛇。更多时候垃圾桶启动会更优先调度红阵，保留灵活性。\n\n### 终端总结\n\n总结三种型的终端：\n\n| 情况             | 222型                  | 225型                       | 227型                         |\n| :------------- | --------------------- | -------------------------- | ---------------------------- |\n| 赛车效果前最大终端      | 红阵+赛车+加速大蛇            | 红阵+承影+赛车                   | 红阵+赛车(+骸晶+三位)                |\n| 赛车效果后最大终端      | 红阵+赛车-\u003e卫星战士/轴子凤凰/加速大蛇 | 红阵+承影+赛车                   | 红阵(+骸晶)+赛车-\u003e卫星战士/轴子凤凰(/加速大蛇) |\n| 被干扰最妥协场        | 红阵+赛车+加速大蛇（基本不被干扰）    | 红阵+赛车(+骸晶)                 | 红阵+赛车(+骸晶+三位)                |\n| 最大场（四点场值+绿阵苏生） | 红阵+加速大蛇+赛车-\u003e卫星战士      | 红阵+承影+赛车-\u003e卫星战士/轴子凤凰(/加速大蛇) | 红阵+骸晶+赛车+卫星战士/加速大蛇           |\n\n可以看出有几种型之间通用的公式：\n\n- 5星赛车+三位 =\u003e 轴子凤凰/卫星战士(/加速大蛇，仅在回收黄晶后)\n- 三位+三位/加速同调士/量子刚玉 =\u003e 加速大蛇\n- 赛车变5星前，场上没有另一个调整，三位需要发效果躲坑 =\u003e 考虑做骸晶续航 or 做量子刚玉/加速同调士赌能出轴子凤凰/卫星战士\n\n\n\u003e [!info] 红阵回收黄晶小技巧\n\u003e \n\u003e 225 ， 227 等会有需要先回收黄晶再加速大蛇的要求。如果对方主阶第一步就需要红阵炸，可以 C1 红阵 C2 黄晶，红阵回收不取对象正好可以回收到黄晶。\n\n总结：\n\n- 222 型最稳定，但压制只能靠赛车\n- 225 型最大场理论值最高，基本型有承影弱压制，但最不稳定极易被干扰\n- 227 型变式最多能妥协，但如果三位、红阵的效果同时被干扰，场面会只剩赛车和呆站的骸晶\n\n\u003e [!info]\n\u003e 杯赛中通常会遇到白森、疾行机人、黑羽等卡组，一般过不了红阵+赛车+加速大蛇。因此杯赛中先攻无脑做 222 基本没问题。\n\u003e \n\u003e 在 OCG 中，会多出 5+5 叠新星无限等选择，终端的变化会更多。\n\n\n## 展开思路\n\n### 调度三位与救龙\n\n从上面终端可以看出， combo 关键点在于[[00-水晶机巧-三位玉晶|水晶机巧-三位玉晶]]炸[[50-水晶机巧-圣天骸晶|水晶机巧-圣天骸晶]]后特招三只。有如下逻辑链：\n\n- 只要能同调出骸晶，三位炸到了骸晶效果通过，无论如何都能打完。\n- 为了同调出骸晶，需要两点场值。\n- 除非特殊情况一般只能用三位+5星同调骸晶。为了同调出骸晶，需要调度三位到场上。\n- 为了堆墓，需要特招[[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]发效果。救龙留场后正好可作为同调骸晶的另一个素材。\n\n因此，做骸晶之前需要考虑如何调度出[[00-水晶机巧-三位玉晶|水晶机巧-三位玉晶]]与[[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]。\n\n\u003e [!info] 三位炸骸晶前可调度的四点场值\n\u003e 1. [[31-水晶机巧-柠晶法夫纳|水晶机巧-柠晶法夫纳]]效果特招\n\u003e 2. [[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]特招自己\n\u003e 3. [[80-水晶机巧·内蕴|水晶机巧·内蕴]]墓效苏生\n\u003e 4. 通招\n\n做骸晶需要两点场值，因此最多可以吃两次场上干扰。如果还能保留绿阵苏生，能做更稳定的场。\n\n另外，水机卡组中对通招基本没有要求。因此在能打完的前提下，通招尽量给三位。\n\n### 调度红阵\n\n红阵兼顾作为终场和续航，从上面也能看出几乎所有情况下拿红阵的终场比不拿红阵要更好。因此另一个关键在于[[81-水晶机巧·晶簇|水晶机巧·晶簇]]如何检索。\n\n\u003e [!info] 调度红阵的3种方法：\n\u003e 1. 墓地[[10-水晶机巧-烟晶虎|水晶机巧-烟晶虎]]除外检索\n\u003e 2. [[80-水晶机巧·内蕴|水晶机巧·内蕴]]直接检索\n\u003e 3. [[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]堆墓，然后[[50-水晶机巧-圣天骸晶|水晶机巧-圣天骸晶]]回收\n\n同调出骸晶时，一般没有办法让三位护航骸晶。因此如果红阵在墓地而骸晶被遮/泡，终场会少一个红阵。因此如果烟晶虎与绿阵都在调度救龙、三位的过程中可以省下来，可以优先直接将红阵检索上手。\n\n### 堆墓\n\n水晶机巧的墓效很多，因此资源的增长主要依赖于堆墓。将烟晶虎、紫晶龙、法夫纳、红阵堆墓的方法有：\n\n1. [[30-水晶机巧-柠晶救龙|水晶机巧-柠晶救龙]]特招效果\n2. 通招[[废铁回收员]]\n3. [[02-瀑征龙-潮龙|瀑征龙-潮龙]]丢手、堆墓\n4. [[31-水晶机巧-柠晶法夫纳|水晶机巧-柠晶法夫纳]]丢手里的烟晶虎、紫晶龙\n5. 用场值特招出来再同调下去（一般用于妥协）\n\n234都是不稳定方法，因此堆墓关键点在于救龙。\n\n单绿阵救龙展开很脆弱，因此要尽量用三位护航，或是延迟救龙展开时机先用绿阵检索[[31-水晶机巧-柠晶法夫纳|水晶机巧-柠晶法夫纳]]，把手里的烟晶虎、紫晶龙丢到墓地变为资源。\n\n救龙只能堆2，任务很重。如果手牌不佳，如何堆墓需要取舍。\n\n### 总结\n\n\u003e [!info] 调度三位的优先级\n\u003e 1. 通招（因为三位站场就能护航，能打完的前提下优先让三位站场）\n\u003e 2. 法夫纳从卡组拉（不能通招三位时，只能用这种方法）\n\u003e 3. 绿阵墓效拉（但是希望尽量保留绿阵墓效，仅用于法夫纳也拉不出来的情况）\n\n\u003e [!info] 调度柠晶救龙的优先级\n\u003e 1. 绿阵检索（因为可以直接满足柠晶龙特招条件，还可以把绿阵送墓）\n\u003e 2. 法夫纳从卡组拉（没法调度到绿阵时用）\n\u003e 3. 紫晶龙检索（需要紫晶龙检索救龙的场合，一般场上没有绿阵。救龙起跳需要亏一点场值，所以不到万一一般不用紫晶龙检索救龙，而且一般紫晶龙需要救龙堆下去）\n\n\u003e [!info] 绿阵启动检索优先级\n\u003e 1. 救龙\n\u003e 2. 三位（手里有救龙的情况下，通招三位护航）\n\u003e 3. 法夫纳（如果手里有一大堆墓效下级，只有一张绿阵能展开，直接调度救龙会吃坑死）\n\u003e 4. 红阵（资源充裕的情况下）\n\u003e \n\u003e 手里有烟晶虎、紫晶龙的情况下，可以特招救龙前检索法夫纳，把手里的下级扔进墓。可以增强韧性，避免救龙被遮泡打断直接 GG 。\n\n\u003e [!info] 救龙堆2的优先级\n\u003e 1. 红阵（烟晶虎、绿阵都用过的情况下必须通过堆墓调度）\n\u003e 2. 烟晶虎（绿阵用过而烟晶虎没用过的情况下，优先烟晶虎找红阵）\n\u003e 3. 紫晶龙（通招点没用过的情况下，优先紫晶龙找三位）\n\u003e 4. 法夫纳（手里有烟晶虎、紫晶龙的情况下，法夫纳丢手节省一个堆墓点）\n\u003e 5. 三位玉晶\n\u003e \n\u003e 需要救龙堆三位玉晶一般两种情况，手牌要么极好要么极差：\n\u003e - 其他都不需要救龙堆的情况，多堆一个三位玉晶可以充当续航\n\u003e - 通招已用，必须堆一张红阵，手牌里也没其他水机的情况。这时只能堆三位，用绿阵苏生继续做场\n\n所以一拿到手牌，考虑 combo 时主要想：\n\n- 如何调度救龙\n- 如何调度三位 -\u003e 能否先出三位护航\n- 如何调度红阵 -\u003e 是否有余力直接检索\n- 堆墓堆什么 -\u003e 救龙堆什么 -\u003e 烟晶虎、紫晶龙、法夫纳能发动几个\n- 最后想有多少场值，怎么出终端\n\n\u003e [!info] 一句话总结\n\u003e 绿阵优先检索到救龙，通招三位能打完优先通招三位，如果烟晶虎绿阵都检索过只能堆红阵回收。\n\n\n\n\n## 参考文献\n\n- [[抛砖引玉] 新手向喂饭式的MD纯水晶机巧前瞻 NGA玩家社区](https://bbs.nga.cn/read.php?tid=44192462\u0026rand=827)\n- [md 同调杯 租借水晶机巧卡组讲解 对局讲解 最强租借卡组 不怕假g 高展开韧性高妥协能力_哔哩哔哩bilibili_游戏王](https://www.bilibili.com/video/BV1k3t1zSEMb/?vd_source=ba01a1932b530e32e2576726fdda41d7)\n- [【游戏王MD】同调杯！预组水晶机巧展开教学_哔哩哔哩bilibili_游戏王_游戏集锦](https://www.bilibili.com/video/BV1eGtUz2EYp/?spm_id_from=333.337.search-card.all.click\u0026vd_source=ba01a1932b530e32e2576726fdda41d7)\n\n\n","title":"【游戏王大学习】水晶机巧——游戏王 MD 2025-08同调杯水晶机巧预组","abstract":"这次的同调杯三个预组中，唯一算是比较有强度的就是水晶机巧了。\n水机卡组刚出来的时候我也算是小小玩过，但现在的水晶机巧已经跟第 9 期那时完全不同打法了。连一刻都没有为继承玻纤的死亡哀悼，立即赶到 MD 的是 12 期的五张新卡！三位玉晶、柠晶救龙、圣天骸晶、绿阵、红阵，5张新时代的补强可以说完全重构了水晶机巧这个卡组。\n为了打这次同调杯，我专门重新学习了水机卡组。这篇文章也算是学习过程中的总结笔记。可能会有很多很多谬误，如果发现了请评论指正。","length":671,"created_at":"2025-08-10T23:48:00.000Z","updated_at":"2025-08-11T00:48:00.000Z","tags":["游戏王","杂谈","游戏王MD","游戏王大师决斗"],"license":false,"headingTrees":[{"key":"关键卡","href":"#关键卡","heading":2,"title":"关键卡","children":[{"key":"水晶机巧-柠晶救龙","href":"#水晶机巧-柠晶救龙","heading":3,"title":"水晶机巧-柠晶救龙","children":[],"id":"水晶机巧-柠晶救龙"},{"key":"水晶机巧内蕴","href":"#水晶机巧内蕴","heading":3,"title":"水晶机巧·内蕴","children":[],"id":"水晶机巧内蕴"},{"key":"水晶机巧-烟晶虎","href":"#水晶机巧-烟晶虎","heading":3,"title":"水晶机巧-烟晶虎","children":[],"id":"水晶机巧-烟晶虎"},{"key":"废铁回收员","href":"#废铁回收员","heading":3,"title":"废铁回收员","children":[],"id":"废铁回收员"},{"key":"水晶机巧-柠晶法夫纳","href":"#水晶机巧-柠晶法夫纳","heading":3,"title":"水晶机巧-柠晶法夫纳","children":[],"id":"水晶机巧-柠晶法夫纳"},{"key":"水晶机巧-三位玉晶","href":"#水晶机巧-三位玉晶","heading":3,"title":"水晶机巧-三位玉晶","children":[],"id":"水晶机巧-三位玉晶"},{"key":"lv7-水晶机巧-圣天骸晶","href":"#lv7-水晶机巧-圣天骸晶","heading":3,"title":"Lv7 水晶机巧-圣天骸晶","children":[],"id":"lv7-水晶机巧-圣天骸晶"}],"id":"关键卡"},{"key":"终端","href":"#终端","heading":2,"title":"终端","children":[{"key":"lv9-水晶机巧-中枢大蛇","href":"#lv9-水晶机巧-中枢大蛇","heading":3,"title":"Lv9 水晶机巧-中枢大蛇","children":[],"id":"lv9-水晶机巧-中枢大蛇"},{"key":"水晶机巧晶簇","href":"#水晶机巧晶簇","heading":3,"title":"水晶机巧·晶簇","children":[],"id":"水晶机巧晶簇"},{"key":"lv7-方程式运动员-电光赛道名将","href":"#lv7-方程式运动员-电光赛道名将","heading":3,"title":"Lv7 方程式运动员 电光赛道名将","children":[],"id":"lv7-方程式运动员-电光赛道名将"}],"id":"终端"},{"key":"其他主卡组","href":"#其他主卡组","heading":2,"title":"其他主卡组","children":[{"key":"5星非调整","href":"#5星非调整","heading":3,"title":"5星非调整","children":[],"id":"5星非调整"},{"key":"4星以下非调整","href":"#4星以下非调整","heading":3,"title":"4星以下非调整","children":[],"id":"4星以下非调整"},{"key":"主卡组调整","href":"#主卡组调整","heading":3,"title":"主卡组调整","children":[],"id":"主卡组调整"},{"key":"瀑征龙-潮龙","href":"#瀑征龙-潮龙","heading":3,"title":"瀑征龙-潮龙","children":[],"id":"瀑征龙-潮龙"}],"id":"其他主卡组"},{"key":"其他额外","href":"#其他额外","heading":2,"title":"其他额外","children":[{"key":"lv4-水晶机巧-量子刚玉","href":"#lv4-水晶机巧-量子刚玉","heading":3,"title":"Lv4 水晶机巧-量子刚玉","children":[],"id":"lv4-水晶机巧-量子刚玉"},{"key":"lv5-水晶机巧-矩阵紫黄晶","href":"#lv5-水晶机巧-矩阵紫黄晶","heading":3,"title":"Lv5 水晶机巧-矩阵紫黄晶","children":[],"id":"lv5-水晶机巧-矩阵紫黄晶"},{"key":"lv9-水晶机巧-轴子凤凰","href":"#lv9-水晶机巧-轴子凤凰","heading":3,"title":"Lv9 水晶机巧-轴子凤凰","children":[],"id":"lv9-水晶机巧-轴子凤凰"},{"key":"lv5-加速同调士","href":"#lv5-加速同调士","heading":3,"title":"Lv5 加速同调士","children":[],"id":"lv5-加速同调士"},{"key":"lv9-碧钢之机龙","href":"#lv9-碧钢之机龙","heading":3,"title":"Lv9 碧钢之机龙","children":[],"id":"lv9-碧钢之机龙"},{"key":"lv10-相剑大公-承影","href":"#lv10-相剑大公-承影","heading":3,"title":"Lv10 相剑大公-承影","children":[],"id":"lv10-相剑大公-承影"},{"key":"lv10-卫星战士","href":"#lv10-卫星战士","heading":3,"title":"Lv10 卫星战士","children":[],"id":"lv10-卫星战士"},{"key":"lv12-骑士皇-雷加蒂娅","href":"#lv12-骑士皇-雷加蒂娅","heading":3,"title":"Lv12 骑士皇 雷加蒂娅","children":[],"id":"lv12-骑士皇-雷加蒂娅"}],"id":"其他额外"},{"key":"展开终端","href":"#展开终端","heading":2,"title":"展开终端","children":[{"key":"222","href":"#222","heading":3,"title":"222","children":[],"id":"222"},{"key":"225","href":"#225","heading":3,"title":"225","children":[],"id":"225"},{"key":"227","href":"#227","heading":3,"title":"227","children":[],"id":"227"},{"key":"223-妥协场","href":"#223-妥协场","heading":3,"title":"223 （妥协场）","children":[],"id":"223-妥协场"},{"key":"2223-or-2253-垃圾桶场加速场","href":"#2223-or-2253-垃圾桶场加速场","heading":3,"title":"2223 or 2253 （垃圾桶场、加速场）","children":[],"id":"2223-or-2253-垃圾桶场加速场"},{"key":"2275-赛车场","href":"#2275-赛车场","heading":3,"title":"2275 （赛车场）","children":[],"id":"2275-赛车场"},{"key":"2223绿阵-or-2253绿阵-or-2273绿阵最大场","href":"#2223绿阵-or-2253绿阵-or-2273绿阵最大场","heading":3,"title":"2223+绿阵 or 2253+绿阵 or 2273+绿阵（最大场）","children":[],"id":"2223绿阵-or-2253绿阵-or-2273绿阵最大场"},{"key":"终端总结","href":"#终端总结","heading":3,"title":"终端总结","children":[],"id":"终端总结"}],"id":"展开终端"},{"key":"展开思路","href":"#展开思路","heading":2,"title":"展开思路","children":[{"key":"调度三位与救龙","href":"#调度三位与救龙","heading":3,"title":"调度三位与救龙","children":[],"id":"调度三位与救龙"},{"key":"调度红阵","href":"#调度红阵","heading":3,"title":"调度红阵","children":[],"id":"调度红阵"},{"key":"堆墓","href":"#堆墓","heading":3,"title":"堆墓","children":[],"id":"堆墓"},{"key":"总结","href":"#总结","heading":3,"title":"总结","children":[],"id":"总结"}],"id":"展开思路"},{"key":"参考文献","href":"#参考文献","heading":2,"title":"参考文献","children":[],"id":"参考文献"}],"wikiRefAliases":["30-水晶机巧-柠晶救龙","30-水晶机巧-柠晶救龙","80-水晶机巧·内蕴","10-水晶机巧-烟晶虎","废铁回收员","80-水晶机巧·内蕴","10-水晶机巧-烟晶虎","废铁回收员","00-水晶机巧-三位玉晶","31-水晶机巧-柠晶法夫纳","00-水晶机巧-三位玉晶","00-水晶机巧-三位玉晶","50-水晶机巧-圣天骸晶","00-水晶机巧-三位玉晶","50-水晶机巧-圣天骸晶","52-水晶机巧-中枢大蛇","81-水晶机巧·晶簇","方程式运动员 电光赛道名将","30-水晶机巧-柠晶救龙","31-水晶机巧-柠晶法夫纳","13-水晶机巧-绿晶龟","10-水晶机巧-烟晶虎","11-水晶机巧-紫晶龙","12-水晶机巧-红晶雀","10-水晶机巧-烟晶虎","11-水晶机巧-紫晶龙","00-水晶机巧-三位玉晶","01-水晶机巧-黄晶","#00-水晶机巧-三位玉晶 水晶机巧-三位玉晶","02-瀑征龙-潮龙","碧钢之机龙","51-水晶机巧-量子刚玉白晶","54-水晶机巧-矩阵紫黄晶","53-水晶机巧-量子红雀白晶","加速同调士","碧钢之机龙","相剑大公-承影","卫星战士","骑士皇 雷加蒂娅","废铁回收员","10-水晶机巧-烟晶虎","80-水晶机巧·内蕴","30-水晶机巧-柠晶救龙","00-水晶机巧-三位玉晶","50-水晶机巧-圣天骸晶","01-水晶机巧-黄晶","方程式运动员 电光赛道名将","31-水晶机巧-柠晶法夫纳","方程式运动员 电光赛道名将","31-水晶机巧-柠晶法夫纳","加速同调士","相剑大公-承影","加速同调士","废铁回收员","加速同调士","方程式运动员 电光赛道名将","00-水晶机巧-三位玉晶","50-水晶机巧-圣天骸晶","30-水晶机巧-柠晶救龙","00-水晶机巧-三位玉晶","30-水晶机巧-柠晶救龙","31-水晶机巧-柠晶法夫纳","30-水晶机巧-柠晶救龙","80-水晶机巧·内蕴","81-水晶机巧·晶簇","10-水晶机巧-烟晶虎","80-水晶机巧·内蕴","30-水晶机巧-柠晶救龙","50-水晶机巧-圣天骸晶","30-水晶机巧-柠晶救龙","废铁回收员","02-瀑征龙-潮龙","31-水晶机巧-柠晶法夫纳","31-水晶机巧-柠晶法夫纳"],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2024-11-16-try-cursor-and-thinking.md","pagePath":"/articles/try-cursor-and-thinking","slug":"try-cursor-and-thinking"},"meta":{"content":"\n试着用了一下 cursor ，感觉还不错。非技术也能半小时能做一款 App 可能是真的。但替代不了技术岗也是真的。\n\n## 先说问题\n\n虽然 Cursor 基于 VSCode 二次开发，但可能为了做 AI 功能把 Editor Pooling 或者 File Watching 能力搞坏了，经常 Apply 了修改后 Explorer 和 Editor 里没有及时反馈。然后自动补全功能因为可以删内容导致手感跟 VSCode 里的 Copilot 比较不同，用起来比较 annoying 。\n\n### 文件系统监控问题\n\n作为一个基于 VSCode 二次开发的编辑器，Cursor 在文件系统监控方面存在一些问题。当对文件进行修改后，Explorer 和 Editor 经常无法及时反映这些变化，这可能是因为为了实现 AI 功能而对原有的 Editor Pooling 或 File Watching 机制进行了修改导致的。\n\n\u003e 这简直太让人抓狂了！😫 你改了代码，编辑器却在那装傻充愣。就好像你发了消息，对方已读不回 💬。程序员最讨厌等待了，对吧？⏳\n\n### 自动补全体验差异\n\nCursor 的自动补全功能与 VSCode 中的 GitHub Copilot 有明显的使用体验差异。由于 Cursor 的补全可以删除已有内容，这种行为方式与程序员习惯的编辑模式不太相符，使用起来感觉比较突兀和烦人。\n\n\u003e 这个功能真的让人又爱又恨 💔！AI 小助手太热情了，动不动就想帮你重写代码。冷静点，老铁！我只是想要一点提示而已！🤪\n\n### 性能影响\n\n这些技术问题不仅影响了开发体验，还可能会降低编码效率。实时的文件系统反馈对于开发工作流程来说是非常重要的，而自动补全功能的差异也会影响到日常编码的流畅度。\n\n\u003e 性能问题真是让人头大 🤯！写代码就应该是行云流水的感觉，现在却经常要等等等...等到我都能喝完一杯咖啡了 ☕️！\n\n\n## Chat Anywhere\n\n不过 Chat Anywhere 这个做法应该是做对了。需要用 AI 代写的场景，很多时候并不是不会写而是懒得写，以前在 VSCode 里需要切到 Coplilot 的 Tab ，写 prompt 等回复，然后再将答案复制粘贴回去，多数情况下有这闲工夫还不如直接自己写🤣，在 Cursor 里可以直接原地调 AI 改写，真的巨舒服。\n\n\u003e 这功能简直就是懒人福音啊！🎯 再也不用在各种窗口之间跳来跳去了！爽歪歪！🎊\n\n## 智能代码分析\n\n还有 Cursor 可以直接将整个项目 Indexing 掉，还能理解代码间的调用关系，一个 prompt 直接出调用关系图，再也不用挠爆头想怎么做 RAG 怎么给文章分块了，爽到。\n\n![[Pasted image 20241116200220.png]]\n\n![[Pasted image 20241116200148.png]]\n\n## Cursor 可能会比较有用的场景\n\n### 智能注释生成\n\nCursor 在生成代码注释方面表现出色。它不仅能分析当前文件的代码，还能理解整个项目的上下文。通过分析 import 关系、函数调用链、接口实现和类型定义等多个维度，它能生成更加准确和有意义的注释。这对于维护大型项目或者需要快速理解他人代码的场景特别有帮助。\n\n\u003e 终于不用为写注释抓耳挠腮了！🎉 AI 帮你分析完所有代码关系，三下五除二就能生成一份漂亮的注释！💡\n\n### 文档和文章创作\n\n在文档和文章创作方面，Cursor 的原地 AI 改写功能特别实用。当你需要写一篇长文，需要参考多个文档源，但又不需要特别严格的逻辑推导时，这个功能简直是神器。你可以：\n\n- 让 AI 帮你规划文章结构，生成合适的目录\n- 根据已有内容快速扩充段落\n- 实时调整文章语气和风格\n- 参考相关文档自动补充内容\n\n\u003e 写文档再也不用对着空白发呆了！✍️ AI 小助手随时待命，帮你把想法变成优美的文字！📝\n\n### 项目结构优化\n\n在项目结构维护方面，Cursor 提供了一系列强大的功能：\n\n1. **可视化项目结构**：一键生成项目依赖关系图，让项目结构一目了然。再也不用在复杂的目录结构中迷失方向。\n\n2. **智能重构建议**：基于项目分析，AI 可以提供项目结构优化建议，帮助你建立更清晰的代码组织方式。\n\n3. **自动化工具生成**：需要批量处理文件？Cursor 可以直接生成 Shell 命令或 Python 脚本，帮你完成繁琐的目录操作。\n\n\u003e 项目管理变得如此轻松！🚀 让 AI 帮你梳理项目结构，生成工具脚本，程序员的生产力简直起飞！✨\n\n\n## 总结\n\n\u003e 总的来说，Cursor 作为一款基于 AI 的代码编辑器有其独特的优势，尤其是 Chat Anywhere 和智能代码分析这样的创新功能确实提升了开发效率。但同时也存在一些技术问题，比如文件系统监控和自动补全体验等需要改进的地方。尽管如此，它展示了 AI 辅助编程的潜力，为未来编程工具的发展提供了新的思路。\n\n顺便一提，在引用块里的内容都是由 AI 生成的。\n","title":"尝试 Cursor 的感想和一些思考","abstract":"试着用了一下 cursor ，感觉还不错。非技术也能半小时能做一款 App 可能是真的。但替代不了技术岗也是真的。\n虽然 Cursor 基于 VSCode 二次开发，但可能为了做 AI 功能把 Editor Pooling 或者 File Watching 能力搞坏了，经常 Apply 了修改后 Explorer 和 Editor 里没有及时反馈。然后自动补全功能因为可以删内容导致手感跟 VSCode 里的 Copilot 比较不同，用起来比较 annoying 。\n作为一个基于 VSCode 二次开发的编辑器，Cursor 在文件系统监控方面存在一些问题。当对文件进行修改后，Explorer 和 Editor 经常无法及时反映这些变化，这可能是因为为了实现 AI 功能而对原有的 Editor Pooling 或 File Watching 机制进行了修改导致的。","length":78,"created_at":"2024-11-16T15:42:00.000Z","updated_at":"2024-11-16T15:42:00.000Z","tags":["Cursor","杂谈"],"license":true,"headingTrees":[{"key":"先说问题","href":"#先说问题","heading":2,"title":"先说问题","children":[{"key":"文件系统监控问题","href":"#文件系统监控问题","heading":3,"title":"文件系统监控问题","children":[],"id":"文件系统监控问题"},{"key":"自动补全体验差异","href":"#自动补全体验差异","heading":3,"title":"自动补全体验差异","children":[],"id":"自动补全体验差异"},{"key":"性能影响","href":"#性能影响","heading":3,"title":"性能影响","children":[],"id":"性能影响"}],"id":"先说问题"},{"key":"chat-anywhere","href":"#chat-anywhere","heading":2,"title":"Chat Anywhere","children":[],"id":"chat-anywhere"},{"key":"智能代码分析","href":"#智能代码分析","heading":2,"title":"智能代码分析","children":[],"id":"智能代码分析"},{"key":"cursor-可能会比较有用的场景","href":"#cursor-可能会比较有用的场景","heading":2,"title":"Cursor 可能会比较有用的场景","children":[{"key":"智能注释生成","href":"#智能注释生成","heading":3,"title":"智能注释生成","children":[],"id":"智能注释生成"},{"key":"文档和文章创作","href":"#文档和文章创作","heading":3,"title":"文档和文章创作","children":[],"id":"文档和文章创作"},{"key":"项目结构优化","href":"#项目结构优化","heading":3,"title":"项目结构优化","children":[],"id":"项目结构优化"}],"id":"cursor-可能会比较有用的场景"},{"key":"总结","href":"#总结","heading":2,"title":"总结","children":[],"id":"总结"}],"wikiRefAliases":[],"richRefAliases":["Pasted image 20241116200220.png","Pasted image 20241116200148.png"]}},{"pathMapping":{"filePath":"public/content/articles/2022-08-20-introduction-for-k8s-2.md","pagePath":"/articles/introduction-for-k8s-2","slug":"introduction-for-k8s-2"},"meta":{"content":"\n我们之前说的都是用于部署 Pod 的资源，我们接下来介绍与创建 Pod 不相关的资源：储存与网络。\n\n# 储存\n\n其实我们之前已经接触过储存相关的内容了：在讲 Stateful Set 时我们提过 Stateful Set 创建出来的 Pod 都会有相互独立的储存；而讲 Daemon Set 时我们提到 K8s 推荐只在 Daemon Set 的 Pod 中访问宿主机磁盘。但独立的储存具体指什么？除了访问宿主机磁盘以外还有什么其他的储存？\n\n在 Docker 中，我们可以把宿主机磁盘上的一个路径作为一个 Volume 来给容器绑定，或者直接使用 Docker Engine 管理的 Volume 来提供持久化存储或是容器间共享文件。在 K8s 里面也沿用了 Volume 这个概念，可以通过 Mount 绑定到容器内的路径，并通过实现 CSI 的各种引擎来提供更多样的存储。\n\n\u003e CSI: Container Storage Interface ，容器储存接口标准，是 K8s 提出的一种规范。不管是哪种储存引擎，只要编写一个对应的插件实现 CSI ，都可以在 K8s 中使用。\n\n### K8s 中使用 Volume 与可用的 Volume 类型\n\n其实 K8s 中使用 Volume 的例子我们一开始就已经接触过了。还记得一开始介绍 Pod 时的 Nginx 例子吗？\n\n```yaml\nmetadata:\n  name: simple-webapp\nspec:\n  containers:\n    - name: main-application\n      image: nginx\n      volumeMounts:\n        - name: shared-logs\n          mountPath: /var/log/nginx\n    - name: sidecar-container\n      image: busybox\n      command: [\"sh\",\"-c\",\"while true; do cat /var/log/nginx/access.log; sleep 30; done\"]\n      volumeMounts:\n        - name: shared-logs\n          mountPath: /var/log/nginx\n  volumes:\n    - name: shared-logs\n      emptyDir: {}\n```\n\n这个 Pod 描述中声明了一个种类为 `emptyDir` 的，名为 `shared-logs` 的 Volume ，然后 Pod 中的两个容器都分别 Mount 了这个 Volume 。\n\nK8s 中默认提供了几种 Volume ，比如：\n\n- emptyDir ：一个简单的空目录，一般用于储存临时数据或是 Pod 的容器之间共享数据。\n- hostPath ：绑定到节点宿主机文件系统上的路径，一般在 Daemon Set 中使用。\n- gitRepo ：这种 Volume 其实相当于 emptyDir ，不过在 Pod 启动时会从 Git 仓库 clone 一份内容作为默认数据。\n- configMap 、 secret ：一般用于配置文件加载，需要与 configMap 、 secret 这两种资源一同使用。会将 configMap 、 secret 中对应的内容拷贝一份作为 Volume 绑到容器。（下一节中会展开讨论）\n- nfs 、 glusterfs 、 ……：可以通过各种网络存储协议直接挂载一个网络存储\n- (deprecated!) gcePersistentDisk 、 awsElasticBlockStore ……：可以调用各个云平台的 API ，创建一个块储存硬件挂载到宿主机上，再将那个硬件挂载到容器中。\n- persistentVolumeClaim ：持久卷声明，用于把实际储存方式抽象化，使得 Pod 不需要关心具体的储存类型。这种类型会在下面详细介绍。\n\n我们可以注意到， Volume 的声明是 Pod 的一个属性，而不是一种单独的资源。 Volume 是 Pod 的一部分，因此不同的 Pod 之间永远不可能共享同一个 Volume 。\n\n\u003e 但是 Volume 所指向的位置可以相同，比如 HostPath 类型的 Volume 就可以两个 Pod 可以绑定到宿主机上同一个路径，因此 Volume 里的数据还是能通过一定方式在 Pod 间共享。但当然 K8s 不推荐这么做。\n\n另外，由于 Volume 是 Pod 的一部分， Volume 的生命周期也是跟随 Pod 的，当一个 Pod 被销毁时， Volume 也会被销毁，因此最主要还是用于 Pod 内容器间的文件共享。如果需要持久化储存，需要使用 Persistent Volume 。\n\n\u003e Volume 会被销毁不代表 Volume 指向的内容会被销毁。比如 hostPath 、 NFS 等类型 Volume 中的内容就会继续保留在宿主机或是 NAS 上。下面提到的 Presistent Volume Claim 也是，拥有 `persistentVolumeClaim` 类型 Volume 的 Pod 被删除后对应的 PVC 不一定会被删除。\n\n### Presistent Volume 、 Presistent Volume Claim 、 Storage Class\n\n如果需要在 Pod 声明中直接指定 NFS 、 awsElasticBlockStore 之类的信息，就需要应用的开发人员对真实可用的储存结构有所理解，违背了 K8s 的理念。因此 K8s 就弄出了小标题中的三种资源来将储存抽象化。\n\n一个 Persistent Volume (PV) 对应云平台提供的一个块存储，或是 NAS 上的一个路径。可以简单地理解为 **PV 直接描述了一块可用的物理存储** 。因为 PV 直接对应到硬件，因此 PV 跟节点一样，是名称空间无关的。\n\n而一个 **Persistent Volume Claim (PVC) 则是描述了怎样去使用储存** ：使用多少空间、只读还是读写等。一个 PVC 被创建后会且只会对应到一个 PV 。 PVC 从属于一个名称空间，并能被该名称空间下的 Pod 指定为一个 Volume 。\n\nPV 与 PVC 这两种抽象是很必要的。试想一下用自己的物理机搭建一个 K8s 集群的场景。你会提前给物理机插上许多个储存硬件，这时你就需要用 PV 来描述这些硬件，之后才能在 K8s 里利用这些硬件的储存。而实际将应用部署到 K8s 中时，你才需要用 PVC 来描述 Pod 中需要怎么样的储存卷，然后 K8s 就会自动挑一个合适 PV 给这个 PVC 绑定上。这样实际部署应用的时候就不用再特意跑去机房给物理机插硬件了。\n\n但是现在都云原生时代了，各供应商都有提供 API 可以直接创建一个块储存，还要想办法提前准备 PV 实在是太蠢了。于是便需要 Storage Class 这种资源。\n\n使用 Storage Class 前需要先安装各种云供应商提供的插件（当然使用云服务提供的 K8s 的话一般已经准备好了），然后再创建一个 Storage Class 类型的资源（当然一般也已经准备好了）。下面是 AWS 上的 EKS 服务中默认自带的 Storage Class ：\n\n```yaml\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  annotations:\n    storageclass.kubernetes.io/is-default-class: \"true\"\n  name: gp2\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  fsType: ext4\n  type: gp2\n# 当 PVC 被删除时会同时删除 PV\nreclaimPolicy: Delete\n# 只有当 PVC 被绑定为一个 Pod 的 Volume 时才会创建一个 PV\nvolumeBindingMode: WaitForFirstConsumer\n```\n\n可以看到 EKS 自带的 gp2 提供了一些默认的选项，我们也可以类似地去定义自己的 Storage Class 。有了 gp2 这个 Storage Class ，我们创建一个 PVC 后 K8s 就会调用 AWS 的 API ，创建一个块储存接到我们的节点上，然后 K8s 再自动创建一个 PV 并绑定到 PVC 上。\n\n例如，我们部署 Kafka 时会创建一个这样的 PVC ：\n\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: data-kafka-0\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: gp2\n```\n\nK8s 就会自动为我们创建出一个对应的 PV ：\n\n```sh\n# `pvc-` 开头这个是 AWS 自动给我们起的名字。它虽然是 `pvc-` 开头，但他其实是一个 PV 。\nNAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS   REASON   AGE\npvc-3614c15f-5697-4d66-a13c-6ddf7eb89998   10Gi       RWO            Delete           Bound    kafka/data-kafka-0   gp2                     152d\n```\n\n要是打开 AWS Console 还会发现， K8s 调用了 AWS 的 API ，自动为我们创建了一个 EBS 块储存并绑定到了我们对应的宿主机上。\n\n可以用下面这张图来表示 Pod 中的 Volume 、 PVC 、 PV 之间的关系：\n\n```mermaid\nflowchart TD\n\nsubgraph Pod[Pod: Kafka-0]\nsubgraph Container[Container: docker.io/bitnami/kafka:3.1.0]\nvm[VolumeMount: /bitnami/kafka]\nend\nvolume[(Volume: data)]\nvm --\u003e volume\nend\n\npvc[pvc: data-kafka-0]\npv[pv: pvc-3614c15f-5697-4d66-a13c-6ddf7eb89998]\nebs[ebs: AWS 为我们创建的块储存硬件]\n\nvolume --\u003e pvc\npvc --\u003e pv\npv --\u003e ebs\n```\n\n而 Storage Class 在上图中则负责读取我们提交的 PVC ，然后创建 PV 与 EBS 。\n\n### 再说回 Stateful Set\n\n之前我们提到 Stateful Set 时说到 Stateful Set 创建的 Pod 拥有固定的储存，到底是什么意思呢？跟 Deployment 的储存又有什么区别呢？\n\n我们先来看看，如果要给 Deployment 创建出来的 Pod 挂载 PVC 需要怎么做。下面是一个部署 Nginx 的 Deployment 清单，其中 html 目录下的静态文件存放在 NFS 里，通过 PVC 挂载到 Pod 中：\n\n```yaml\n# 这里省略了 Service 相关的内容\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-dpl-with-nfs-pvc\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:alpine\n        ports:\n        - containerPort: 80\n          name: web\n        volumeMounts: #挂载容器中的目录到 pvc nfs 中的目录\n        - name: www\n          mountPath: /usr/share/nginx/html\n      volumes:\n      - name: www\n        persistentVolumeClaim: #指定pvc\n          claimName: nfs-pvc-for-nginx\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: nfs-pvc-for-nginx\n  namespace: default\nspec:\n  storageclassname: \"\" # 指定使用现有 PV ，不使用 StorageClass 创建 PV\n  accessModes:\n  - ReadWriteMany\n  resources:\n    requests:\n      storage: 1Gi\n---\n# 这个例子中需要挂载 NFS 上的特定路径，所以手动定义了一个 PV\n# 一般情况下我们不会手动创建 PV，而是使用 StorageClass 自动创建\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: nfs-pv-for-nginx\nspec:\n  capacity: \n    storage: 1Gi\n  accessModes:\n  - ReadWriteMany\n  persistentVolumeReclaimPolicy: Retain\n  nfs:\n    path: /nfs/sharefolder/nginx\n    server: 81.70.4.171\n```\n\n这份清单我们主要关注前两个资源，我们可以看到除了一个 Deployment 资源以外我们还单独定义了一个 PVC 资源。然后在 Deployment 的 Pod 模板中声明并绑定了这个 PVC 。\n\n可这样 apply 了之后会发生什么情况呢？因为我们只声明了一份 PVC ，当然我们只会拥有一个 PVC 资源。但这个 Deployment 的副本数是 3 ，因此我们会有 3 个相同的 Pod 去绑定同一个 PVC 。也就是最终会在 3 个容器里访问同一个 NFS 的同一个目录。如果我们在其中一个容器里对这个目录作修改，也会影响到另外两个容器。\n\n\u003e 注：这一现象不一定在任何情况下都适用。比如 AWS 的 EBS 卷只支持单个 AZ 内的绑定。如果 Pod 因为 Node Affinity 等设定被部署到了多个区，没法绑定同一个 EBS 卷，就会在 Scedule 的阶段报错。\n\n很多时候我们都不希望多个 Pod 绑定到同一 PVC 。比如我们部署一个 DB 集群的时候，如果好不容易部署出来的多个实例居然用的是同一份储存，就会显得很呆。 Stateful Set 就是为了解决这种情况，会为其管理下的每个 Pod 都部署一个专用的 PVC 。\n\n下面是给 Stateful Set 创建出来的 Pod 挂载 PVC 的一份清单：\n\n```yaml\n# 这里省略了 Service 相关的内容\n---\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  serviceName: \"nginx\"\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: k8s.gcr.io/nginx-slim:0.8\n        ports:\n        - containerPort: 80\n          name: web\n        volumeMounts:\n        - name: www\n          mountPath: /usr/share/nginx/html\n  volumeClaimTemplates:\n  - metadata:\n      name: www\n    spec:\n      accessModes: [ \"ReadWriteOnce\" ]\n      resources:\n        requests:\n          storage: 1Gi\n```\n\n我们可以看到，部署 Stateful Set 时我们不能另外单独定义一份 PVC 了，只能作为 Stateful Set 定义的一部分，在 volumeClaimTemplates 字段中定义 PVC 的模板。这样一来， Stateful Set 会根据这个模板，为每个 Pod 创建一个对应的 PVC ，并作为 Pod 的 Volume 绑定上：\n\n```bash\n# Stateful Set 创建出来的 Pod ，名字都是按顺序的\n$ kubectl get pods -l app=nginx\nNAME      READY     STATUS    RESTARTS   AGE\nweb-0     1/1       Running   0          1m\nweb-1     1/1       Running   0          1m\n\n# Stateful Set 创建出来的 PVC ，名字与 Pod 的名字一一对应\n$ kubectl get pvc -l app=nginx\nNAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE\nwww-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s\nwww-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s\n```\n\n这样， Stateful Set 的多个 Pod 就会拥有自己的储存，不会相互打架了。另外，如果我们事先定义了 StorageClass ，还能根据 Stateful Set 的副本数动态配置 PV 。\n\n### ConfigMap 与 Secret 挂载作为特殊的卷\n\n有时候我们需要使用配置文件来配置应用（比如 Nginx 的配置文件），而且我们有时候会需要不重启 Pod 就热更新配置。如果用 PVC 来加载配置文件略微麻烦，这时候可以使用 Config Map 。\n\n下面是 K8s 官网上 Config Map 的一个例子：\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: game-demo\ndata:\n  # 一个 Key 可以对应一个值\n  player_initial_lives: \"3\"\n  ui_properties_file_name: \"user-interface.properties\"\n\n  # 一个 Key 也可以对应一个文件的内容\n  game.properties: |\n    enemy.types=aliens,monsters\n    player.maximum-lives=5    \n  user-interface.properties: |\n    color.good=purple\n    color.bad=yellow\n    allow.textmode=true    \n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: configmap-demo-pod\nspec:\n  containers:\n    - name: demo\n      image: alpine\n      command: [\"sleep\", \"3600\"]\n      env:\n        # ConfigMap 的 Key 可以作为环境变量引用\n        - name: PLAYER_INITIAL_LIVES\n          valueFrom:\n            configMapKeyRef:\n              name: game-demo           # 从这个 Config Map 里\n              key: player_initial_lives # 拿到这个 key 的值\n        - name: UI_PROPERTIES_FILE_NAME\n          valueFrom:\n            configMapKeyRef:\n              name: game-demo\n              key: ui_properties_file_name\n      volumeMounts:\n      - name: config\n        mountPath: \"/config\"\n        readOnly: true\n  volumes:\n    # 定义 Pod 的 Volume ，种类为 configMap\n    - name: config\n      configMap:\n        name: game-demo # ConfigMap的名字\n        # 需要作为文件放入 Volume 的 Key\n        items:\n        - key: \"game.properties\"\n          path: \"game.properties\"\n        - key: \"user-interface.properties\"\n          path: \"user-interface.properties\"\n```\n\n我们可以看到 ConfigMap 里的 Key 可以作为文件或是环境变量加载到 Pod 中。另外，作为环境变量加载后其实还能作为命令行参数传入应用，实现各种配置方式。如果修改 Config map 的内容，也可以自动更新 Pod 中的文件。\n\n然而， Config Map 的热更新有一些不太灵活的地方：\n\n1. 作为环境变量加载的 Config Map 数据不会被热更新。想要更新这一部分数据需要重启 Pod。（当然，命令行参数也不能热更新）\n2. 由于 Kubelet 会先将 Config Map 内容加载到本地作为缓存，因此修改 Config Map 后新的内容不会第一时间加载到 Pod 中。而且在旧版本的 K8s 中， Config Map 被更新直到缓存被刷新的时间间隔还会很长，新版本的 K8s 这一部分有了优化，可以设定刷新时间，但会导致 API Server 的负担加重。（这其实是一个 Known Issue ，被诟病多年： https://github.com/kubernetes/kubernetes/issues/22368 ）\n\n除 Config Map 以外， K8s 还提供了一种叫 Secret 的资源，用法和 Config Map 几乎一样。对比 Config Map ，Secret 有以下几个特点：\n\n1. 在 Pod 里， Secret 只会被加载到内存中，而永远不会被写到磁盘上。\n2. 用 `kubectl get` 之类的命令显示的 Secret 内容会被用 base64 编码。（不过， well ，众所周知 base64 可不算是什么加密）\n3. 可以通过 K8s 的 Service Account 等 RBAC 相关的资源来控制 Secret 的访问权限。\n\n不过，由于 Secret 也是以明文的形式被存储在 K8s 的主节点中的，因此需要保证 K8s 主节点的安全。\n\n\u003e **Downward API 挂载作为特殊的卷**\n\u003e \n\u003e 还有另外一种叫 Downward API 的东西，可以作为 Volume 或是环境变量被加载到 Pod 中。有一些参数我们很难事先在 Manifest 中定义（ e.g. Deployment 生成的 Pod 的名字），因此可以通过 Downward API 来实现。\n\u003e \n\u003e ```yaml\n\u003e apiVersion: v1\n\u003e kind: Pod\n\u003e metadata:\n\u003e     name: test-volume-pod\n\u003e     namespace: kube-system\n\u003e     labels:\n\u003e         k8s-app: test-volume\n\u003e         node-env: test\n\u003e spec:\n\u003e     containers:\n\u003e     - name: test-volume-pod-container\n\u003e       image: busybox:latest\n\u003e       env:\n\u003e       - name: POD_NAME # 将 Pod 的名字作为环境变量 POD_NAME 加载到 Pod 中\n\u003e         valueFrom:\n\u003e           fieldRef:\n\u003e             fieldPath: metadata.name\n\u003e       command: [\"sh\", \"-c\"]\n\u003e       args:\n\u003e       - while true; do\n\u003e           cat /etc/podinfo/labels | echo;\n\u003e           env | sort | echo;\n\u003e           sleep 3600;\n\u003e         done;\n\u003e       volumeMounts:\n\u003e       - name: podinfo\n\u003e         mountPath: /etc/podinfo\n\u003e     volumes:\n\u003e     - name: podinfo\n\u003e       downwardAPI: # Downward API 类型的卷\n\u003e         items:\n\u003e         - path: \"labels\" # 将 Pod 的标签作为  labels 文件挂载到 Pod 中\n\u003e           fieldRef:\n\u003e             fieldPath: metadata.labels\n\u003e ```\n\n\n\n# 网络\n\n其实 Pod 只要部署好了，就会被分配到一个集群内部的 IP 地址，流量就可以通过 IP 地址来访问 Pod 了。然而通过可能会有很大问题： **Pod 随时会被杀死。** 虽然通过用 Deployment 等资源可以在挂掉后重新创建一个 Pod ，但那毕竟是不同的 Pod ， IP 已经改变。\n\n另外， Deployment 等资源的就是为了能更方便的做到多副本部署及任意缩容扩容而存在的。如果在 K8s 中访问 Pod 还需要小心翼翼地去找到 Pod 的 IP 地址，或是去寻找 Pod 是否部署了新副本， Deployment 等资源就几乎没有存在价值了。\n\n\u003e 其实 Pod 部署好后不止会被分配 IP 地址，还会被分配到一个类似 `\u003cpod-ip\u003e.\u003cnamespace\u003e.pod.cluster.local` 的 DNS 记录。例如一个位于 default 名字空间，IP 地址为 172.17.0.3 的 Pod ，对应 DNS 记录为 `172-17-0-3.default.pod.cluster.local` 。\n\n### Service\n\n在古代，人们是通过注册中心、服务发现、负载均衡等中间件来解决上面这些问题的，但这样很不云原生。于是 K8s 引入了 Service 这种资源，来实现简易的服务发现、 DNS 功能。\n\n下面是一个经典的例子，部署了一个 Service 和一个 Deployment：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: auth-service\n  labels:\n    app: auth\nspec:\n  type: ClusterIP\n  selector:\n    app: auth # 指向 Deployment 创建的 Pod\n  ports:\n  - port: 80 # Service 暴露的端口\n    targetPort: 8080 # Pod 的端口\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name:  auth\n  labels:\n    app: auth\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: auth\n  template:\n    metadata:\n      name: auth\n      labels:\n        app: auth\n    spec:\n      containers:\n      - name: auth\n        image: xxxxx.dkr.ecr.ap-northeast-1.amazonaws.com/auth:xxxxx\n        ports:\n        - containerPort: 8080\n```\n\n根据前面的知识我们知道，这份文件会部署 Deployment 会创建 2 个相同的 Pod 副本。另外还会部署一个名为 auth-service 的 Service 资源。这个 Service 暴露了一个 80 端口，并且指向那两个 Pod 的 8080 端口。\n\n而这份文件部署后， Service 资源就会在集群中注册一个 DNS A 记录（或 AAAA 记录），集群内其他 Pod （为了辨别我们叫它 Client ）就可以通过相同的 DNS 名称来访问 Deployment 部署的这 2 个 Pod ：\n\n```sh\ncurl http://auth-service.\u003cnamespace\u003e.svc.cluster.local:80\n# 或者省略掉后面的一大串\ncurl http://auth-service.\u003cnamespace\u003e:80\n# 如果 Client 和 Service 在同一个 Namespace 中，还可以：\ncurl http://auth-service:80\n```\n\n像这样 Client 通过 Service 来访问时，会随机访问到其中一个 Pod ，这样一来无论 Deployment 到底创建了多少个副本，只要副本的标签相同，就能通过同一个 DNS 名称来访问，还能自动实现一些简单的负载均衡。\n\n\u003e **为什么 DNS 名称可以简化？**\n\u003e \n\u003e Pod 被部署时， kubelet 会为每个 Pod 注入一个类似如下的 `/etc/resolv.conf` 文件：\n\u003e \n\u003e ```\n\u003e nameserver 10.32.0.10\n\u003e search \u003cnamespace\u003e.svc.cluster.local svc.cluster.local cluster.local\n\u003e options ndots:5\n\u003e ```\n\u003e \n\u003e Pod 中进行 DNS 查询时，默认会先读取这个文件，然后按照 `search` 选项中的内容展开 DNS 。例如，在 test 名称空间中的 Pod ，访问 data 时的查询可能被展开为 data.test.svc.cluster.local 。\n\u003e 更多关于 `/etc/resolv.conf` 文件的内容可参考 https://www.man7.org/linux/man-pages/man5/resolv.conf.5.html\n\n### Service 的种类\n\n我们上面的例子中，可以看到 Service 资源有个字段 `type:ClusterIP` 。其实 Service 资源有以下几个种类：\n\n| 种类           | 作用                                                                                                                                                                                                                                                                                             |\n| :------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `ClusterIP`    | 这个类型的 Service 会在集群内创建一条 DNS A 记录并通过一定方法将流量代理到其指向的 Pod 上。这种 Service 不会暴露到集群外。这是最基础的 Service 种类。                                                                                                                                            |\n| `NodePort`     | 这种 Service 会在 ClusterIP 的基础上，在所有节点上各暴露一个端口，并把端口的流量也代理到指向的 Pod 上。可以通过这种方法从集群外访问集群内的资源。                                                                                                                                                |\n| `LoadBalancer` | 这种 Service 会在 ClusterIP 的基础上，在所有节点上各暴露一个端口，并在集群外创建一个负载均衡器来将外部流量路由到暴露的端口，再把流量代理到指向的 Pod 上。这种 Service 一般需要调用云服务提供的 API 或是额外安装的插件。如果什么插件都没安装的话，这种 Service 部署后会与 `NodePort` 的表现一样。 |\n| `ExternalName` | 这种 Service 不需要 selector 字段指定后端，而是用 externalName 字段指定一个外部 DNS 记录，然后将流量全部指向外部服务。如果打算将集群内的服务迁移到集群外、或是集群外迁移到集群内，这种类型的 Service 可以实现无缝迁移。                                                                          |\n\n### 虚拟 IP 与 Headless Service\n\n如果你在集群内尝试对 Service 对应的 DNS 记录进行域名解析，会发现返回来的 IP 地址与 Service 指向的任何一个 Pod 对应的 IP 地址都不相同。如果你还尝试了去 Ping 这个 IP 地址，会发现不能 Ping 通。为什么会这样呢？\n\n原来，每个 Service 被部署后， K8s 都会给他分配一个集群内部的 IP 地址，也就是 Cluster IP （这也是最基础的 Service 种类会起名叫 Cluster IP 的原因）。\n\n但是这个 Cluster IP 不会绑定任何的网卡，是一个虚拟 IP 。然后 K8s 中有一个叫 kube-proxy 的组件（这里叫他做组件，是因为 kube-proxy 与 Service 、 Deployment 等不一样，不是一种资源而是 K8s 的一部分）， kube-proxy 通过修改 iptables ，将虚拟 IP 的流量经过一定的负载均衡规则后代理到 Pod 上。\n\n![K8s 官网上的虚拟 IP 图](https://d33wubrfki0l68.cloudfront.net/27b2978647a8d7bdc2a96b213f0c0d3242ef9ce0/e8c9b/images/docs/services-iptables-overview.svg)\n\n\u003e **为什么不使用 DNS 轮询？**\n\u003e \n\u003e 为什么 K8s 不配置多条 DNS A 记录，然后通过轮询名称来解析？为什么需要搞出虚拟 IP 这么复杂的东西？这个问题 K8s 官网上也有特别提到原因：\n\u003e \n\u003e - DNS 实现的历史由来已久，它不遵守记录 TTL，并且在名称查找结果到期后对其进行缓存。\n\u003e - 有些应用程序仅执行一次 DNS 查找，并无限期地缓存结果。\n\u003e - 即使应用和库进行了适当的重新解析，DNS 记录上的 TTL 值低或为零也可能会给 DNS 带来高负载，从而使管理变得困难。\n\n有些时候（比如想使用自己的服务发现机制或是自己的负载均衡机制时）我们确实也会想越过虚拟 IP ，直接获取背后 Pod 的 IP 地址。这时候我们可以将 Service 的 `spec.clusterIP` 字段指定为 `None` ，这样 K8s 就不会给这个 Service 分配一个 Cluster IP 。这样的 Service 被称为 **Headless Service** 。\n\nHeadless Service 资源会创建一组 A 记录直接指向背后的 Pod ，可以通过 DNS 轮询等方式直接获得其中一个 Pod 的 IP 地址。另外更重要的一点， Headless Service 还会创建一组 SRV 记录，包含了指向各个 Pod 的 DNS 记录，可以通过 SRV 记录来发现所有 Pod 。\n\n我们可以在集群里用 nsloopup 或 dig 命令去验证一下：\n\n```sh\n# 在集群的 Pod 内部运行\n$ nslookup kafka-headless.kafka.svc.cluster.local\nServer:     10.96.0.10\nAddress:    10.96.0.10#53\n\nName:   kafka-headless.kafka.svc.cluster.local\nAddress: 172.17.0.6\nName:   kafka-headless.kafka.svc.cluster.local\nAddress: 172.17.0.5\nName:   kafka-headless.kafka.svc.cluster.local\nAddress: 172.17.0.4\n\n$ dig SRV kafka-headless.kafka.svc.cluster.local\n# .....\n;; ANSWER SECTION:\nkafka-headless.kafka.svc.cluster.local.      30      IN      SRV     0 20 9092 kafka-0.kafka-headless.kafka.svc.cluster.local.\nkafka-headless.kafka.svc.cluster.local.      30      IN      SRV     0 20 9092 kafka-1.kafka-headless.kafka.svc.cluster.local.\nkakfa-headless.kafka.svc.cluster.local.      30      IN      SRV     0 20 9092 kafka-2.kafka-headless.kafka.svc.cluster.local.\n\n;; ADDITIONAL SECTION:\nkafka-0.kafka-headless.kafka.svc.cluster.local. 30 IN A  172.17.0.6\nkafka-1.kafka-headless.kafka.svc.cluster.local. 30 IN A  172.17.0.5\nkafka-2.kafka-headless.kafka.svc.cluster.local. 30 IN A  172.17.0.4\n```\n\n\u003e 拥有 Cluster IP 的 Service 其实也有 SRV 记录。但这种情况的 SRV 记录中对应的 Target 仍为 Service 自己的 FQDN 。\n\n### 第三次回到 Stateful Set\n\n在上面 Headless Service 的例子中，我们看到，各个 Pod 对应的 DNS A 记录格式为 `\u003cpod_name\u003e.\u003csvc_name\u003e.\u003cnamespace\u003e.svc.cluster.local` 。不对啊，之前的小知识里不是说过 Pod 被分配的 DNS A 记录格式应该是 `172-17-0-3.default.pod.cluster.local` 的吗？\n\n其实 Headless Service 还有一个众所周知的隐藏功能。 Pod 这种资源本身的参数中有 `subdomain` 字段和 `hostname` 字段，如果设置了这两个字段，这个 Pod 就拥有了形如 `\u003chostname\u003e.\u003csubdomain\u003e.\u003cnamespace\u003e.svc.cluster.local` 的 FQDN （全限定域名）。如果这时刚好在同一名称空间下有与 `subdomain` 同名的 Headless Service ， DNS 就会用为这个 Pod 用它的 FQDN 来创建一条 DNS A 记录。\n\n比如 Pod1 在 `kafka` 名称空间中， `hostname` 为 `kafka-1` ， `subdomain` 为 `kafka-headless` ，那么 Pod1 的 FQDN 就是 `kafka-1.kafka-headless.kakfa.svc.cluster.local` 。而同样在 `kafka` 名称空间中，刚好又有一个 `kafka-headless` 的 Headless Service ，那么 DNS 就会创建一条 A 记录，就可以通过 `kafka-1.kafka-headless.kafka.svc.cluster.local` 来访问 Pod1 了。当然，由于 DNS 展开，也可以用 `kafka-1.kafka-headless.kafka` 甚至是 `kafka-1.kafka-headless` 来访问这个 Pod 。\n\n其实这些 Pod 是用 Stateful Set 来部署的，这一部分其实是 Stateful Set 相关的功能。之前我们说到 Stateful Set 有唯一稳定的网络标识。我们现在就来详细讲讲，这“唯一稳定的网络标识”到底是在指什么。\n\n我们来看一下这个 kafka Stateful Set 到底是怎么部署的：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: kafka-headless\nspec:\n  clusterIP: None # 这是一个 headless service\n  ports:\n  - name: tcp-client\n    port: 9092\n    protocol: TCP\n    targetPort: kafka-client\n  selector:\n    select-label: kafka-label\n  type: ClusterIP\n---\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: kafka\nspec:\n  replicas: 3\n  serviceName: kafka-headless # 注意到这里有 serviceName 字段\n  selector:\n    matchLabels:\n      select-label: kafka-label\n  template:\n    metadata:\n      labels:\n        select-label: kafka-label\n    spec:\n      containers:\n      - name: kafka\n        image: docker.io/bitnami/kafka:3.1.0-debian-10-r52\n        # 接下来 Pod 相关部分省略\n  # 下面 Volume 相关部分也省略\n```\n\n我们看到， Stateful Set 的定义中必须要用 `spec.serviceName` 字段指定一个 Headless Service 。 Stateful Set 创建 Pod 时，会自动给 Pod 指定 `hostname` 和 `subdomain` 字段。这样一来，每个 Pod 才有了唯一固定的 hostname ，唯一固定的 FQDN ，以及通过与 Headless Service 共同部署而获得唯一固定的 A 记录。（此外，其实当 Pod 因为版本升级等原因被重新创建时，相同序号的 Pod 还会被分配到相同固定的集群内 IP 。）\n\n\u003e **关于 Stateful Set 中 `serviceName` 字段的争议**\n\u003e \n\u003e Stateful Set 中的 serviceName 字段是必填字段。这个字段唯一的作用其实就是给 Pod 指定 subdomain 。其实这样会有一些问题：\n\u003e \n\u003e 1. Stateful Set 部署时不会检查是否真的存在这么一个 Headless Service 。如果 serviceName 乱填一个值，会导致虽然 Pod 的 `hostname` 和 `subdomain` 都指定了却没有创建 A 记录的情况。\n\u003e 2. 有时 Stateful Set 的 Pod 不需要接收流量，也不需要相互发现，这时候还强行需要指定一个 serviceName 显得有点多余。\n\u003e \n\u003e 在 GitHub 上有关于这个问题的 Issue ： https://github.com/kubernetes/kubernetes/issues/69608\n\n### 从集群外部访问\n\n在 K8s 集群里把应用部署好了，可是如何让集群外部的客户端访问我们集群中的应用呢？这可能是大家最关心的问题。\n\n不过有认真听的同学估计已经有这个问题的答案了。之前我们讲过 NodePort 和 LoadBalancer 这两种 Service 类型。\n\n其中 NodePort Service 只是简单地在节点机器上各开一个端口，而如何路由、如何负载均衡等则一概不管。\n\n而 LoadBalancer Service 则是在 NodePort 的基础上再加一个一个负载均衡器，然后把节点暴露的端口注册到这个负载均衡器上。这样一来，集群外部的客户端就可以通过同一个 IP 来访问集群中的应用。但是要使用 LoadBalancer Service ，一般需要先安装云供应商提供的 Controller ，或是安装其他第三方的 Controller （比如 Nginx Controller ）。\n\n在 Service 之外还另有一种资源类型叫 Ingress ，也可以用来实现集群外部访问集群内部应用的功能。 Ingress 其实也会在集群外创建一个负载均衡器，因此也需要预先安装云供应商的 Controller 。但 Ingress 与 Service 不同的是，它还会管理一定的路由逻辑，接收流量后可以根据路由来分配给不同的 Service 。\n\n| 类型                 | OSI 模型工作层数 | 依赖于云平台或其他插件 |\n| :------------------- | :--------------- | :--------------------- |\n| NodePort Service     | 第四层           | 否                     |\n| LoadBalancer Service | 第四层           | 是                     |\n| Ingress              | 第七层           | 是                     |\n\n特别再详细说一下 Ingress 这种资源。 Ingress 本身不会在集群内的 DNS 上创建记录，一般也不会主动去路由集群内的流量（除非你在集群内强行访问 Ingress 的负载均衡器…… 不过一般也没什么理由要这样做对吧）。但 Ingress 可以根据 HTTP 的 hostname 和 path 来路由流量，把流量分发到不同的 Service 上。 Ingress 也是 K8s 的原生资源里唯一能看到 OSI 第七层的资源。\n\n下面是 AWS 的 EKS 服务中部署的一个 Ingress 的例子（集群中已安装 AWS Load Balancer Controller ）：\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: alb\n    alb.ingress.kubernetes.io/scheme: internet-facing\n    alb.ingress.kubernetes.io/target-type: ip\n    alb.ingress.kubernetes.io/backend-protocol-version: GRPC\n    alb.ingress.kubernetes.io/listen-ports: '[{\"HTTPS\":443}]'\n    alb.ingress.kubernetes.io/healthcheck-path: /grpc.health.v1.Health/Check\n    alb.ingress.kubernetes.io/healthcheck-protocol: HTTP\n    alb.ingress.kubernetes.io/success-codes: 0,12\n    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:xxxxxxxxxx:certificate/xxxxxxxxxx\n\n    external-dns.alpha.kubernetes.io/hostname: sample.example.com\n  \n  name: gateway-ingress\nspec:\n  rules:\n  - host: sample.example.com\n    http:\n      paths:\n      - path: /grpc.health.v1.Health\n        pathType: Prefix\n        backend:\n          service:\n            name: health-service\n            port:\n              number: 50051\n      - path: /proto.sample.v1.Sample\n        pathType: Prefix\n        backend:\n          service:\n            name: sample-service\n            port:\n              number: 50051\n```\n\n可以看到， Ingress 资源可以通过 `spec.rules` 字段中定义各条规则，通过 hostname 或是 path 等第七层的信息来进行路由。 Ingress 部署下去后， AWS Load Balancer Controller 会读取会根据的配置，并在云上创建一个 AWS Application Load Balancer （ALB），而 `spec.rules` 会应用到 ALB 上，由 ALB 来负责流量的路由。\n\n我们也会注意到，怎么 `metadata.annotations` 里有这么多奇奇怪怪的字段！ Ingress 本身的功能都是 AWS Load Balancer Controller 调用 AWS 的 API 创建 ALB 来实现的。但 AWS 的 ALB 能实现的功能可不止 Ingress 字段定义的这些，比如安装 TLS 证书、 health check 等 spec 字段中描述不下的功能，就只能是通过 annotation 的形式来定义了。\n\n\u003e 小彩蛋：可以看到例子中的 Ingress 资源 annotation 字段里还有一行 `external-dns.alpha.kubernetes.io/hostname: sample.example.com` 。其实这个 K8s 集群中还安装了 external-dns 这个应用，它可以根据 annotation 来在外部 DNS 上直接创建 DNS 记录！有了这个插件我们可不用再慢慢打开公共 DNS 管理页面，再小心翼翼地记下 IP 地址去添加 A 记录了。\n\n# 更高级的部署方式（一）\n\n一路说道这里， K8s 中最基础的资源大部分都已经介绍了。但是，这么多资源之间又需要相互配合，只部署一种资源基本没什么生产能力。\n\n比如只部署 Deployment 的话，我们确实是能在一组多副本的 Pod 里跑起可执行程序，但这组 Pod 却几乎没办法接受集群里其他 Pod 的流量（只能通过制定 Pod 的 IP 来访问，但 Pod 的 IP 是会变的）。因此一般来说一个 Deployment 都会搭配一个 Service 来使用。这还是最简单的一种搭配了。\n\n假若我们现在要在自己的 K8s 里安装一个别人提供的应用。当然由于 K8s 是基于容器的，只要别人提供了他应用的 yaml 清单，我们只用把清单用 `kubectl apply -f` 提交给 K8s ，然后让 K8s 把清单中的镜像拉下来就能跑了。可如果我们需要根据环境来改一些参数呢？\n\n如果别人提供的 yaml 文件比较简单还好说，改改对应的字段就好了。如果别人的应用比较复杂，那改 yaml 文件可就是一个大难题了。比如 AWS 的 Load Balancer Controller ，它的 yaml 清单文件可是多达 939 行！\n\n[[aws-elb-controller-lines.png]]\n\n在这种复杂的场景下，我们就需要一些更高级的部署方式了。\n\n### Helm\n\n首先来介绍的是 Helm 。 Helm 是一个包管理工具，可以类比一下 CentOS 中的 yum 工具。它可以把一组 K8s 资源发布成一个 Chart ，然后我们可以用 Helm 来安装这个 Chart ，并且可以通过参数设值来改变 Chart 中的部分资源。利用 Helm 安装 Chart 后还可以管理 Chart 的升级、回滚、卸载。\n\n使用别人提供的 Helm Chart 前，需要先 add 一下 Chart 的仓库，然后再安装仓库里提供的 Chart 。比如我们要安装 bitnami 提供的 Kafka Chart 时：\n\n```bash\n# 添加 https://charts.bitnami.com/bitnami 这个仓库，命名为 bitnami\nhelm repo add bitnami https://charts.bitnami.com/bitnami\n\n# 在 kafka 名称空间里安装 bitnami 仓库里的 kafka Chart ，并通过参数设置为 3 个副本，并同时安装一个 3 副本的 Zookeeper\nhelm install kafka -n kafka \\\n  --set replicaCount=3 \\\n  --set zookeeper.enabled=true \\\n  --set zookeeper.replicaCount=3 \\\n  bitnami/kafka\n```\n\n命令执行后， helm 就会根据参数与 Chart 的内容，在 K8s 里安装 StatefulSet 、 Service 、 ConfigMap 等一切所需要的资源。\n\n```sh\n$ k -n kafka get all,cm\nNAME                    READY   STATUS    RESTARTS      AGE\npod/kafka-0             1/1     Running   1             46d\npod/kafka-1             1/1     Running   3             46d\npod/kafka-2             1/1     Running   3             46d\npod/kafka-zookeeper-0   1/1     Running   0             46d\npod/kafka-zookeeper-1   1/1     Running   0             46d\npod/kafka-zookeeper-2   1/1     Running   0             46d\n\nNAME                               TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/kafka                      ClusterIP      172.20.1.196     \u003cnone\u003e           9092/TCP                     164d\nservice/kafka-headless             ClusterIP      None             \u003cnone\u003e           9092/TCP,9093/TCP            164d\nservice/kafka-zookeeper            ClusterIP      172.20.227.236   \u003cnone\u003e           2181/TCP,2888/TCP,3888/TCP   164d\nservice/kafka-zookeeper-headless   ClusterIP      None             \u003cnone\u003e           2181/TCP,2888/TCP,3888/TCP   164d\n\nNAME                               READY   AGE\nstatefulset.apps/kafka             3/3     164d\nstatefulset.apps/kafka-zookeeper   3/3     164d\n\nNAME                                DATA   AGE\nconfigmap/kafka-scripts             2      164d\nconfigmap/kafka-zookeeper-scripts   2      164d\nconfigmap/kube-root-ca.crt          1      165d\n```\n\n甚至， Helm 可以通过模板生成的 Pod 环境变量，来预先设置好 Kafka 的配置，让他找得到 Zookeeper 服务：\n\n```yaml\napiVersion: v1\nkind: Pod\n# 略去无关信息\nspec:\n  containers:\n  - name: kafka\n    command:\n    - /scripts/setup.sh\n    env:\n    - name: KAFKA_CFG_ZOOKEEPER_CONNECT\n      value: kafka-zookeeper\n    # ...\n```\n\n通过设置 `KAFKA_CFG_ZOOKEEPER_CONNECT` 这个环境变量，指定了 Kafka Broker 可以通过访问 `kafka-zookeeper` 来找到 zookeeper 服务。（还记得 zookeeper 的 Service 名字是 `kafka-zookeeper` 吗？ zookeeper 与 kafka 部署在同一个名称空间里，因此可以直接通过 Service 名访问。）\n\n如果我们打开这个 helm chart 对应的[代码仓库](https://github.com/bitnami/charts/tree/master/bitnami/kafka)，会发现原来有一组 go template 文件，以及一个 `values.yaml` 文件和 `Chart.yaml` 文件：\n\n```sh\n.\n├── Chart.lock\n├── Chart.yaml\n├── README.md\n├── templates\n│   ├── NOTES.txt # 这里定义的是 helm 工具的命令行信息\n│   ├── _helpers.tpl # 这里面是一些定义好的 go template 代码块可以供其他模板使用\n│   ├── configmap.yaml\n│   ├── statefulset.yaml\n│   ├── svc-headless.yaml\n│   ├── svc.yaml\n│   └── # 以下省略若干模板文件\n└── values.yaml\n```\n\n- `Chart.yaml` 中定义了这个 Chart 的基本信息，包括名称、版本、描述、依赖等。\n- `values.yaml` 中定义了这个 Chart 的默认参数，包括各种资源的默认配置、副本数量、镜像版本等。其中的值都可以通过 `helm install` 命令的 `--set` 参数来覆盖。\n- `templates/` 文件夹下的都是 go template 的模板文件。\n\n`helm install` 就是通过用 `values.yaml` 中预定义的参数，渲染 `templates/` 文件夹下的 go template 文件，生成最终的 yaml 文件，然后再通过 kubectl apply -f 的方式，将 yaml 文件里的资源部署到 K8s 里。然后通过忘资源里注入一些特殊 annotation 的方式来记住自己部署了那些资源，进而提供 `update` 、 `uninstall` 等功能。\n\n关于更多 Helm 的内容，可以参考[官方文档](https://helm.sh/docs/)。\n\n### Kustomize\n\n另一个部署工具是 Kustomize 。之前提到 Config Map 时的例子中，将配置文件的内容直接写进了 yaml 清单的一个字段里：\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: game-demo\ndata:\n  # 一个 Key 可以对应一个值\n  player_initial_lives: \"3\"\n  ui_properties_file_name: \"user-interface.properties\"\n\n  # 一个 Key 也可以对应一个文件的内容\n  game.properties: |\n    enemy.types=aliens,monsters\n    player.maximum-lives=5    \n  user-interface.properties: |\n    color.good=purple\n    color.bad=yellow\n    allow.textmode=true    \n```\n\n其实这样很不好，先不说这样写没办法在 IDE 里用配置文件自己的语法检查，每行还需要一定的缩进，如果配置文件有好几百行，你甚至会忘了这一行到底是哪个配置文件！此时我们就会自然而然的想把每个配置文件以单独文件的形式保存。\n\nKustomize 就是这样一个工具，它可以帮助我们把每个配置文件以单独文件的形式保存，然后再通过一个 `kustomization.yaml` 文件，将这些配置文件组合起来，生成最终的 yaml 文件。\n\n```yaml\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n  # 其他资源也可以单独使用一个文件定义\n  - deployment.yaml\n\n# 用 configMapGenerator 从文件中生成 ConfigMap\nconfigMapGenerator:\n  - name: game-demo\n    literals:\n      - \"ui_properties_file_name=user-interface.properties\"\n      - \"player_initial_lives=3\"\n    # 从文件中读取内容\n    files:\n      - game.properties\n      - user-interface.properties\n# 有多个 configMap 时，可以通过统一的 generatorOptions 来设置一些通用的选项\ngeneratorOptions:\n  disableNameSuffixHash: true\n```\n\n然后两个配置文件的内容可以单独用文件定义，此时可以结合 IDE 的语法检查，以及代码补全功能，来编写配置文件。\n\n```properties\n# user-interface.properties\ncolor.good=purple\ncolor.bad=yellow\nallow.textmode=true    \n```\n\n然后将 `kustomization.yaml` 和其他所需的文件都放在同一个目录下：\n\n```bash\n.\n├── kustomization.yaml\n├── deployment.yaml\n├── game.properties\n└── user-interface.properties\n```\n\n然后就可以通过 `kubectl apply -k ./` 来将整个 kustomize 文件夹转换为 yaml 清单直接部署到 K8s 中。\n（没错，现在 Kustomize 已经成为 kubectl 中的内置功能！可以不用先 `kustomize build` 生成 yaml 文件再 `kubectl apply` 两步走了！）\n\n值得提醒的是，虽然 `kustomization.yaml` 有 `apiVersion` 和 `kind` 字段，长得很像一个资源清单，但其实 K8s 的 API server 并不认识他。 Kustomize 的工作原理其实是先根据 `kustomization.yaml` 生成 K8s 认识的 yaml 资源清单，然后再通过 `kubectl apply` 来部署。\n\n除了可以直接将 ConfigMap 与 Secret 中的文件字段内容用单独的文件定义外， Kustomize 还有其他比如为部署的资源添加统一的名称前缀、添加统一字段等功能。这些大家可以阅读 Kustomize 的[官方文档](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/)来了解。\n\n### 各种工具的优缺点\n\n我们目前已经知道有三种在 K8s 中部署资源的方式： `kubectl apply`、Helm 和 Kustomize 。\n\n其中 `kubectl apply` 的优缺点很明确，优点是最简单直接，缺点是会导致要么 yaml 清单过长，要么需要分多文件多次部署，使集群中产生中间状态。\n\n而 Helm 与 Kustomize 我们上面也分析过，其实都是基于 `kubectl apply` 的。 Helm 是通过 go template 先生成 yaml 文件再 `kubectl apply` ，而 Kustomize 是通过 `kustomization.yaml` 中的定义用自己的一套逻辑生成 yaml 文件，然后再 `kubectl apply` 。\n\nHelm 的优点是 Helm Chart 安装时可以直接使用别人 Helm 仓库中已经上传好的 Chart ，只需要设置参数就可以使用。这也是 Kustomize 的缺点：如果想要使用别人提供的 Kustomization 而只修改其中的一些配置，必须要先把放 `kustomization.yaml` 的整个文件夹下载下来才能做修改。\n\n而 Helm 的缺点也是明显的， Helm 依赖于往资源里注入特殊的 annotation 来管理 Chart 生成的资源，这可能会很难与集群中现有的一些系统（比如 Service Mesh 或是 GitOps 系统等）放一起管理。而 Kustomize 生成的 yaml 清单就是很干净的 K8s 资源，原先的 K8s 资源该是什么表现就是什么表现，与现有的系统兼容一般会比较好。\n\n而另外，由于 Helm 与 Kustomize 都是基于 `kubectl apply` 的，因此他们有共同的缺点，就是不能做 `kubectl apply` 不能做的事情。\n\n什么叫 `kubectl apply` 不能做的事情呢？比如说我们要在 K8s 中部署 Redis 集群。聪明的你可能就想到要用 Stateful Set 、 PVC 、 Headless Service 来一套组合拳。这确实可以部署一个多节点、有状态的 Redis Cluster 。可是如果我们要往 Redis Cluster 里加一个节点呢？\n\n你当然可以把 Stateful Set 中的 `Replicas` 字段加个 1 然后用 `kubectl apply` 部署，可是这实际上只能增加一个一个 Redis 实例 —— 然后什么都没发生。其他节点不认识这个新的节点，访问这个新节点也不能拿到正确的数据。要知道往 Redis Cluster 里加节点，是要先让集群发现这个新节点，然后还要迁移 slot 的！ `kubectl apply` 可不会做这些事。\n\n\u003e Well, 其实这些也是可以通过增加 initContainer 、修改镜像增加启动脚本等方式，实现用 `kubectl apply` 部署的。可是，这会让整个 Pod 资源变得很难理解，也不好维护。而且，如果不是因为做不到，谁会想去修改别人的镜像呢？\n\n我们接下来会介绍 K8s 的核心架构，来理解我们之前讲的这些资源到底是怎么工作的。最后会引出一组新的概念： Operator 与自定义资源（ Custom Resource Definition ，简称 CRD ）。通过 Operator 与 CRD ，我们可以做到 `kubectl apply` 所不能做到的事，包括 Redis Cluster 的扩容。\n\n\u003e DIO: `kubectl apply` 的能力是有限的……\n\u003e 越是部署复杂的应用，就越会发现 `kubectl apply` 的能力是有极限的……除非超越 `kubectl apply` 。\n\u003e \n\u003e JOJO: 你到底想说什么？\n\u003e \n\u003e DIO: 我不用 `kubectl apply` 了！ JOJO ！\n\u003e （其实还是要用的）\n\n","title":"Kubernetes 入门 （2）","abstract":"我们之前说的都是用于部署 Pod 的资源，我们接下来介绍与创建 Pod 不相关的资源：储存与网络。\n其实我们之前已经接触过储存相关的内容了：在讲 Stateful Set 时我们提过 Stateful Set 创建出来的 Pod 都会有相互独立的储存；而讲 Daemon Set 时我们提到 K8s 推荐只在 Daemon Set 的 Pod 中访问宿主机磁盘。但独立的储存具体指什么？除了访问宿主机磁盘以外还有什么其他的储存？\n在 Docker 中，我们可以把宿主机磁盘上的一个路径作为一个 Volume 来给容器绑定，或者直接使用 Docker Engine 管理的 Volume 来提供持久化存储或是容器间共享文件。在 K8s 里面也沿用了 Volume 这个概念，可以通过 Mount 绑定到容器内的路径，并通过实现 CSI 的各种引擎来提供更多样的存储。","length":875,"created_at":"2022-08-20T21:56:52.000Z","updated_at":"2022-08-20T14:02:18.000Z","tags":["Kubernetes","DevOps","Docker","Cloud Native"],"license":true,"headingTrees":[{"key":"储存","href":"#储存","heading":1,"title":"储存","children":[{"key":"k8s-中使用-volume-与可用的-volume-类型","href":"#k8s-中使用-volume-与可用的-volume-类型","heading":3,"title":"K8s 中使用 Volume 与可用的 Volume 类型","children":[],"id":"k8s-中使用-volume-与可用的-volume-类型"},{"key":"presistent-volume--presistent-volume-claim--storage-class","href":"#presistent-volume--presistent-volume-claim--storage-class","heading":3,"title":"Presistent Volume 、 Presistent Volume Claim 、 Storage Class","children":[],"id":"presistent-volume--presistent-volume-claim--storage-class"},{"key":"再说回-stateful-set","href":"#再说回-stateful-set","heading":3,"title":"再说回 Stateful Set","children":[],"id":"再说回-stateful-set"},{"key":"configmap-与-secret-挂载作为特殊的卷","href":"#configmap-与-secret-挂载作为特殊的卷","heading":3,"title":"ConfigMap 与 Secret 挂载作为特殊的卷","children":[],"id":"configmap-与-secret-挂载作为特殊的卷"}],"id":"储存"},{"key":"网络","href":"#网络","heading":1,"title":"网络","children":[{"key":"service","href":"#service","heading":3,"title":"Service","children":[],"id":"service"},{"key":"service-的种类","href":"#service-的种类","heading":3,"title":"Service 的种类","children":[],"id":"service-的种类"},{"key":"虚拟-ip-与-headless-service","href":"#虚拟-ip-与-headless-service","heading":3,"title":"虚拟 IP 与 Headless Service","children":[],"id":"虚拟-ip-与-headless-service"},{"key":"第三次回到-stateful-set","href":"#第三次回到-stateful-set","heading":3,"title":"第三次回到 Stateful Set","children":[],"id":"第三次回到-stateful-set"},{"key":"从集群外部访问","href":"#从集群外部访问","heading":3,"title":"从集群外部访问","children":[],"id":"从集群外部访问"}],"id":"网络"},{"key":"更高级的部署方式一","href":"#更高级的部署方式一","heading":1,"title":"更高级的部署方式（一）","children":[{"key":"helm","href":"#helm","heading":3,"title":"Helm","children":[],"id":"helm"},{"key":"kustomize","href":"#kustomize","heading":3,"title":"Kustomize","children":[],"id":"kustomize"},{"key":"各种工具的优缺点","href":"#各种工具的优缺点","heading":3,"title":"各种工具的优缺点","children":[],"id":"各种工具的优缺点"}],"id":"更高级的部署方式一"}],"wikiRefAliases":["aws-elb-controller-lines.png"],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2022-08-13-introduction-for-k8s.md","pagePath":"/articles/introduction-for-k8s","slug":"introduction-for-k8s"},"meta":{"content":"\n# 容器， Docker 与 K8s\n\n我们知道 K8s 利用了容器虚拟化技术。而说到容器虚拟化就要说 Docker 。可是，容器到底是什么？ Docker 又为我们做了些什么？我们又为什么要用 K8s ？\n\n### 关于容器虚拟化\n\n\u003e 要把一个不知道打过多少个升级补丁，不知道经历了多少任管理员的系统迁移到其他机器上，毫无疑问会是一场灾难。 —— Chad Fowler 《Trash Your Servers and Burn Your Code》\n\n\"Write once, run anywhere\" 是 Java 曾经的口号。 Java 企图通过 JVM 虚拟机来实现一个可执行程序在多平台间的移植性。但我们现在知道， Java 语言并没能实现他的目标，会在操作系统调用、第三方依赖丢失、两个程序间依赖的冲突等各方面出现问题。\n\n要保证程序拉下来就能跑，最好的方法就是把程序和依赖打包到一起，然后将外部环境隔离起来。容器虚拟化技术就是为了解决这个。\n\n与常说的虚拟机不同， Docker 等各类容器是用隔离名称空间的方式进行资源隔离的。 Linux 系统的内核直接提供了名称空间隔离的能力，是针对进程设计的访问隔离机制，可以进行一些资源封装。\n\n| 名称空间     | 隔离内容                      | 内核版本 |\n| :----------- | :---------------------------- | :------- |\n| Mount        | 文件系统与路径等              | 2.4.19   |\n| UTS          | 主机的Hostname、Domain names  | 2.6.19   |\n| IPC          | 进程间通信管道                | 2.6.19   |\n| PID          | 独立的进程编号空间            | 2.6.24   |\n| Network      | 网卡、IP 地址、端口等网络资源 | 2.6.29   |\n| User         | 进程独立的用户和用户组        | 3.8      |\n| Cgroup       | CPU 时间片，内存分页等        | 4.6      |\n| Time \\\u003c- New! | 进程独立的系统时间            | 5.6      |\n\n值得注目的是， Linux 系统提供了 Cgroup 名称空间隔离的支持。通过隔离 Cgroup ，可以给单独一个进程分配 CPU 占用比率、内存大小、外设 I/O 访问权限等。再配合 IPC 、 PID 等的隔离，可以让被隔离的进程看不到同一实体机中其他进程的信息，就像是独享一整台机器一样。\n\n由于容器虚拟化技术直接利用了宿主机操作系统内核，因此远远要比虚拟机更轻量，也更适合用来给单个程序进行隔离。但也同样由于依赖了宿主机内核，在不同的架构、不同种类的操作系统间容器可能不能移植。\n\n### 关于 Docker\n\n在介绍 K8s 之前，我们要先搞清楚 Docker 是什么。或者说，我们平时说的“ Docker ”是什么？\n\n我们平时说的 Docker ，可能是以下几个东西：\n\n- Docker Engine: 在宿主机上跑的一个进程，专门用来管理各个容器的生命周期、网络连接等，还暴露出一些 API 供外部调用。有时会被称为 Docker Daemon 或是 dockerd 。\n- Docker Client: 命令行中的 `docker` 命令，其实只会跟 Docker Server 通信，不会直接创建销毁一个容器进程。\n- Docker Container: 宿主机上运行的一组被资源隔离的进程，在容器中看来像是独占了一台虚拟的机器，不需要考虑外部依赖。\n- Docker Image: 是一个打包好的文件系统，可以从一个 Image 运行出复数个 Container 。 Image 内部包含了程序运行所需的所有文件、库依赖，以及运行时的环境变量等。\n- Docker 容器运行时: 是 Docker Engine 中专门管理容器状态、生命周期等的那个组件，原来名为 libcontainer 。[《开放容器交互标准》](https://en.wikipedia.org/wiki/Open_Container_Initiative)制定后， Docker 公司将此部分重构为 [runC 项目](https://github.com/opencontainers/runc)，交给 Linux 基金会管理。而 Docker Engine 中与运行时进行交互的部分则抽象出来成为 [containerd 项目](https://containerd.io/)，捐献给了 CNCF 。\n\n我们平时在 linux 机上运行 `yum install docker` 之类的命令，安装的其实是 Docker Engine + Docker Client 。（而在 Windows 或 MacOS 上安装的 Docker Desktop 其实是一个定制过的 linux 虚拟机。）下面说的 Docker 的功能其实都是指 Docker Engine 的功能。\n\n而 Docker 提供给我们的功能，除了最基础的运行和销毁容器外，还包括了一些容器网络编排、重启策略、文件路径映射、端口映射等功能。\n\n而我认为 Docker 最大的贡献，还是容器的镜像与镜像仓库。有了镜像与镜像仓库，人们就可以把自己的程序与执行环境直接打包成镜像发布，也可以直接拿打包好的镜像来运行容器进行部署，而不需要额外下载或是安装一些东西，也不需要担心程序会与已经跑起来的其他程序冲突。\n\n### 为什么要用 K8s ？\n\n其实 Docker 有一个很强大的工具叫 docker-compose ，可以通过一个 manifest 对多个容器组成的网络进行编排。那为什么我们还需要 K8s 呢？换句话说，有什么事是 Docker 不能做的？而 K8s 设计出来的目标是为了解决什么问题？\n\n首先， Docker 做不到以下的功能：\n\n1. **Docker 不能做跨多主机的容器编排。** docker-compose 再方便，他也只能编排单台主机上的容器。对跨主机的集群编排无能为力。（实际上，用了 Docker-Swarm 后是可以多主机编排的，但一来 Docker-Swarm 出现的比 K8s 晚，而来 Docker-Swarm 功能不如 K8s ，因此用的人很少，我们下面就默认 Docker-Swarm 不存在了。）\n2. **Docker 提供的容器部署管理功能不够丰富。** Docker 有一些简单的容器重启策略，但也只是简单的失败后重启之类的，没有完整的应用状态检查等功能。同时，版本升级、缩扩容等策略选择的余地也不多。\n3. **Docker 缺乏高级网络功能。** 要让 Docker 的容器间进行网络通信，也只能是说把容器放到同一个网络下，然后再通过各自的 Hostname 来找到对方。但实际上，我们更会想要一些负载均衡、自定义域名、选择某些容器端口不暴露之类的功能。\n\nand more...\n\n总的来说， Docker 更关注单台主机上容器怎么跑，而对部署管理的功能则支持不多。而最大的痛点，就是 Docker 对多主机的集群部署支持的实再很差。然而，为了实现多区可用、负载均衡等功能，多主机集群的容器编排又是必不可少的。\n\nK8s 的出现，主要就是为了解决多主机集群上的容器编排问题。\n\n1. **K8s 可以进行多主机调度。** 用户只需要描述自己需要运行怎样的应用， K8s 就可以自己选择一个合适的节点进行部署，用户不需要关心自己的应用部署到哪个节点上。\n2. **K8s 中一切皆资源。** K8s 有完善的抽象资源机制，用户几乎不需要知道磁盘、网络等任何硬件信息，只需要对着统一的抽象资源进行操作。\n3. **K8s 能保证较强的可用性。** 除了能跨多主机调度实现多区可用外， K8s 还提供了很完善的缩扩容机制、健康检查机制以及自动恢复机制。\n\n可以说， K8s 是容器编排工具的主流选择。\n\n### K8s 与 Docker 的关系\n\nK8s 与 Docker 关系很复杂，是一个逐渐变化的过程。\n\n一开始 K8s 是完全依赖于 Docker Engine 进行容器启动与销毁的。后来[容器运行时接口（CRI）](https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/)、 [CRI-O 标准](https://github.com/cri-o/cri-o)、开放容器交互标准（OCI）等标准逐渐建立，可替代 Docker Engine 的工具越来越多， K8s 中已经完全可以不使用 Docker Engine 了。\n\n[《凤凰架构》](http://icyfenix.cn/)一书中有下面这样一张图来描述 K8s 与 Docker Engine 的关系：\n\n![K8s 与 Docker Engine 的关系](http://icyfenix.cn/assets/img/kubernetes.495f9eae.png)\n\n《凤凰架构》书中[这一章节](http://icyfenix.cn/immutable-infrastructure/container/history.html#%E5%B0%81%E8%A3%85%E9%9B%86%E7%BE%A4%EF%BC%9Akubernetes)详细介绍了 K8s 与 Docker 的历史，我这里就不再赘述。\n\n# 部署一个 Pod\n\n上面说了一堆概念，我们接下来实际上会怎样应用 K8s 。\n\n### Pod 示例\n\n\u003e Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。\n\u003e Pod 是一组容器；Pod 中的内容总是一同调度，在共享的上下文中运行。 Pod 中包含一个或多个应用容器，这些容器相对紧密地耦合在一起。在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。\n\u003e —— Kubernetes 官方文档\n\nPod 是 K8s 的最小部署单位。\n\n因为 K8s 将硬件资源都抽象化了，用户不需要知道自己的应用部署到哪台机上。但是有些场景下两个主进程之间又必须相互协作才能完成任务，如果两个进程不确定会不会部署到同一个节点上会变得很麻烦。因此才需要 Pod 这种资源。\n\n下面是一个 Nginx Pod 的示例（这是 K8s manifest 文件，可以用 `kubectl apply -f \u003cfilepath\u003e` 进行部署）：\n\n```yaml\nmetadata:\n  name: simple-webapp\nspec:\n  containers:\n    - name: main-application\n      image: nginx\n      volumeMounts:\n        - name: shared-logs\n          mountPath: /var/log/nginx\n    - name: sidecar-container\n      image: busybox\n      command: [\"sh\",\"-c\",\"while true; do cat /var/log/nginx/access.log; sleep 30; done\"]\n      volumeMounts:\n        - name: shared-logs\n          mountPath: /var/log/nginx\n  volumes:\n    - name: shared-logs\n      emptyDir: {}\n```\n\n可以看到， Pod 中可以包含多个容器，这组容器总是以一定的逻辑一起部署，且总是部署在同一个节点。对 K8s 操作时，不能说只部署 Pod 中一个特定的容器，也不能说把 Pod 中一个容器部署在这个节点，另一个容器部署在另一个节点上。\n\n在上面这个例子中，我们看到 Pod 中除了 Nginx 容器以外还有一个 Sidecar 容器负责将 Nginx 的 access.log 日志输出到控制台。两个容器可以通过 mount 同一个路径来实现文件共享。这种场景下，单独跑一个 Sidecar 容器没有意义，而我们也不会希望两个容器部署在不同的节点上。 **两个容器同生共死** ，这样的模式被称为 **Sidecar 模式** 。 Jaeger Agent ，或是 Service Mesh 中常见的 Envoy Sidecar 都可以通过这种模式部署，这样业务容器中就可以不考虑 tracing 或是流量控制相关的问题。\n\n此外，由于同一个 Pod 中的容器默认共享了相同的 network 和 UTS 名称空间，不管是在 Pod 的内部还是外部来看，他们一定程度上就像是真的部署在同一主机上一样，有相同的 Hostname 与 ip 地址，在一个容器中也可以通过 localhost 来访问零一个容器的端口。\n\n另外 Pod 中可以定义若干个 initContainer ，这些容器会比 `spec.containers` 中的容器先运行，并且是顺序运行。下面是通过安装 bitnami 的 Kafka Helm Chart 得到的一个 Kafka Broker Pod （有所简化）:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kafka-0\n  namespace: kafka\nspec:\n  containers:\n  - name: kafka\n    image: docker.io/bitnami/kafka:3.1.0-debian-10-r52\n    command:\n    - /scripts/setup.sh\n    volumeMounts:\n    - name: scripts\n      mountPath: /scripts/setup.sh\n      subPath: setup.sh\n    - name: shared\n      mountPath: /shared\n  initContainers:\n  - name: auto-discovery\n    image: docker.io/bitnami/kubectl:1.23.5-debian-10-r1\n    command:\n    - /scripts/auto-discovery.sh\n    volumeMounts:\n    - name: shared\n      mountPath: /shared\n    - name: scripts\n      mountPath: /scripts/auto-discovery.sh\n      subPath: auto-discovery.sh\n  volumes:\n  - name: scripts\n    configMap:\n      defaultMode: 493\n      name: kafka-scripts\n  - name: shared\n    emptyDir: {}\n```\n\n可以看到，在 `kafka` pod 启动前会先启动一个名为 `auto-discovery` 的 initContainer ，负责获得集群信息等准备工作。准备工作完成后，会将信息写入 `/shared` 目录下，然后再启动 `kafka` 容器 Mount 同一目录，就可以获取准备好的信息。\n\n**这样运行容器进行 Pod 初始化就叫 initContainer 模式** 。每个 initContainer 会运行到成功退出为止，如果有一个 initContainer 启动失败，则整个 Pod 启动失败，触发 K8s 的 Pod 重启策略。\n\n\n# 部署更多 Pod\n\n### Replica Set\n\n可是上面说了这么多，还只是单个 Pod 的部署，但我们希望能做多副本部署。\n\n其实，只要把 Pod 的 manifest 改一下 `metadata.name` 再部署一次，就能得到一模一样的两个 Pod ，就是一个简单的多副本部署了。（必须改 `metadata.name` ，不然 K8s 会以为你是想修改同一个 Pod ）\n\n可是这样做会有很多问题：\n\n- 要复制一下还要改名字多麻烦啊，我想用同一份模板，只定义一下副本数就能得到对应数量的 Pod 。\n- 缩容扩容还要对着 Pod 操作很危险，我想直接修改副本数就能缩容扩容。\n- 如果其中一些 Pod 挂掉了不能重启，现在是什么都不会做。我希望能自动建一些新的 Pod 顶上，来保证副本数不变。\n\n为了实现这些需求，就出现了 Replica Set 这种资源。下面是实际应用中一个 Replica Set 的例子：\n\n```yaml\napiVersion: apps/v1\nkind: ReplicaSet\nmetadata:\n  labels:\n    app: gateway\n  name: gateway-9dc546658\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: gateway\n  template:\n    metadata:\n      labels:\n        app: gateway\n      name: gateway\n    spec:\n      containers:\n        name: gateway\n        image: xxxxxxxx.amazonaws.com/gateway:xxxxxxx\n        ports:\n        - containerPort: 50051\n          protocol: TCP\n        readinessProbe:\n          initialDelaySeconds: 5\n          tcpSocket:\n            port: 50051\n        startupProbe:\n          failureThreshold: 60\n          tcpSocket:\n            port: 50051\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - podAffinityTerm:\n              labelSelector:\n                matchLabels:\n                  app: gateway\n              topologyKey: topology.kubernetes.io/zone\n            weight: 80\n```\n\n我们可以看到， `spec.template` 中就是我们要的 Pod 的模板，在 metadata 里带上了 `app:gateway` 标签。而在 `spec.replicas` 中定义了我们需要的 Pod 数量， `spec.selector` 中描述了我们要对带 `app:gateway` 标签的 Pod 进行控制。把这份 manifest 部署后，我们就会得到除名字以外几乎一摸一样的两个 Pod ：\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  generateName: gateway-9dc546658-\n  labels:\n    app: gateway\n    pod-template-hash: 9dc546658\n  name: gateway-9dc546658-6c9qs\n  ownerReferences:\n  - apiVersion: apps/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: ReplicaSet\n    name: gateway-9dc546658\n    uid: 6633f89c-377c-4c90-bd08-3be5bc7b21bd\n  resourceVersion: \"49793842\"\n  uid: f927db88-a39a-4623-852d-4f150a6d853b\nspec:\n  containers:\n    name: gateway\n    image: xxxxxxxx.amazonaws.com/gateway:xxxxxxx\n    ports:\n    # 后续省略\n\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    kubernetes.io/psp: eks.privileged\n  creationTimestamp: \"2022-08-09T08:51:25Z\"\n  generateName: gateway-9dc546658-\n  labels:\n    app: gateway\n    pod-template-hash: 9dc546658\n  name: gateway-9dc546658-8trcs\n  ownerReferences:\n  - apiVersion: apps/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: ReplicaSet\n    name: gateway-9dc546658\n    uid: 6633f89c-377c-4c90-bd08-3be5bc7b21bd\n  resourceVersion: \"49793745\"\n  uid: 0918e3ed-2965-4237-8828-421a7831c9ed\nspec:\n  containers:\n    image: xxxxxxxx.amazonaws.com/gateway:xxxxxxx\n    name: gateway\n    ports:\n    # 后续省略\n```\n\n可以看到，创建出来的 Pod 自动生成了两个后缀（ `6c9qs` 与 `8trcs` ），带上了 Replica Set 的信息（在 `metadata.ownerReferences` ），其他部分基本一模一样。如果其中一个 Pod 挂掉了， K8s 会帮我们从模板中重新创建一个 Pod 。而且由于我们在 Pod 模板定义了 affinity ， K8s 还会按照我们的要求自动筛选合适的节点。例如在上面 Replica Set 的例子中，创建出来的 Pod 就会尽量部署在不同的节点上。\n\n\u003e **K8s 中对 Pod 的生存状态检查机制**\n\u003e \n\u003e 除了线程直接错误退出以外，还有出现死锁等等各种可能性使得容器中的应用不能正常工作。这些情况下虽然是不健康状态，但容器却不一定会挂掉。因此 K8s 提供了一些探针检查的机制来判断 Pod 是否健康。\n\u003e K8s 主要提供了三种探针：\n\u003e 1. **存活探针（ liveness probe ）** : Pod 运行时 K8s 会循环执行 liveness probe 检查容器是否健康。如果检查失败， K8s 会认为这个容器不健康，就会尝试重启容器。\n\u003e 2. **就绪探针（ readiness probe ）** : 程序可能会有一段时间不能提供服务（比如正在加载数据等）。这时可能既不想杀死应用，也不想给它发送请求，这时就需要 readiness probe 。如果 readiness probe 检查失败， K8s 就会将这个 Pod 从 Service 上摘下来，直到 readiness probe 成功重新加入 Service 。\n\u003e 3. **启动探针（ startup probe ）** : 有些程序会有非常长的启动时间，会有较长时间不能提供服务。这时如果 liveness probe 失败了导致重启毫无必要，此时就需要 startup probe 。 startup probe 只会在容器启动时检查直到第一次成功。直到 startup probe 成功为止， liveness probe 与 readiness probe 都不会开始执行检查。\n\u003e \n\u003e 而检测方式主要有：\n\u003e 1. httpGet: 对指定的端口路径执行 HTTP GET 请求，如果返回 2xx 或 3xx 就是成功。\n\u003e 2. tcpSocket: 尝试与容器的端口建立连接，如果不能成功建立连接就是失败。\n\u003e 3. exec: 在容器内执行一段命令，如果退出时状态码不为 0 就是失败。\n\u003e 4. grpc (New!): K8s 1.24 新出的检查方式，直接用 [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md) 对 GRPC Server 进行检查。\n\n此外， Replica Set 还提供了简易的缩容扩容功能。 kubectl 中提供了 scale 命令：\n\n```bash\nkubectl scale replicaset gateway --replicas=10\n```\n\n执行上述命令，就可以将名为 gateway 的 Replica Set 对应的副本数扩容到 10 份。当然，你也可以直接修改 Replica Set 的 `spec.replicas` 字段来实现缩容扩容。\n\n然而， Replica Set 的功能还是有限的。实际上， Replica Set 只关心跟它的 selector 匹配的 Pod 的数量。而至于匹配的 Pod 是否真的是跟 template 字段中描述的一样， Replica Set 就不关心了。因此如果单用 Replica Set ，更新 Pod 就会变得究极麻烦。\n\n### Deployment\n\n为了解决 Pod 的更新问题，我们需要有 Deployment 这种资源。实际上， Replica Set 的主要用途是提供给 Deployment 作为控制 Pod 数量，以及创建、删除 Pod 的一种机制。我们一般不会直接使用 Replica Set 。\n\n下面是实际应用中一个 Deployment 的例子：\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: gateway\n  name: gateway\nspec:\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: gateway\n  template:\n    metadata:\n      labels:\n        app: gateway\n      name: gateway\n    spec:\n      containers:\n        name: gateway\n        image: xxxxxxxx.amazonaws.com/gateway:xxxxxxx\n        ports:\n        # 下略\n```\n\n可以看到 Deployment 的 manifest 跟 Replica Set 很像。但实际上， Deployment 不会直接创建 Pod ，而是创建出一个 Replica Set ，再由 Replica Set 来创建 Pod ：\n\n\n```mermaid\nflowchart TB\n\nDeployment1[Deployment]\nReplicaSet11[Replica Set]\nPod11[Pod1]\nPod12[Pod2]\nDeployment1 --\u003e ReplicaSet11\nReplicaSet11 --\u003e Pod11\nReplicaSet11 --\u003e Pod12\n```\n\n比如在上面的例子中，名为 gateway 的 Deployment 创建后，就会有如下 ReplicaSet 和 Pod ：\n\n```sh\n# Replica Set:\n$ kubectl get rc -l app=gateway\nNAME                 DESIRED   CURRENT   READY   AGE\ngateway-9dc546658    2         2         2       5d3h\n\n# Pod:\n$ kubectl get po -l app=gateway\nNAME                      READY   STATUS    RESTARTS   AGE\ngateway-9dc546658-6c9qs   1/1     Running   0          5d3h\ngateway-9dc546658-8trcs   1/1     Running   0          5d3h\n```\n\n可以看到，gateway Deployment 创建了一个 Replica Set ，然后随机给了它一个 `9dc546658` 后缀。然后 gateway-9dc546658 这个 Replica Set 又根据 template 中创建了两个 Pod ，再在自己名字的基础上加上两个后缀 `6c9qs` 与 `8trcs` 。\n\n接下来就是 Deployment 的重点了： Replica Set 只会根据 template 创建出 Pod ，而不管匹配的 Pod 到底是不是跟 template 中描述的一样。而 **Deployment 则会专门关注 template 的内容变更。**\n\n假如我们现在更新了 Deployment 的 template 中的内容提交给 K8s ， Deployment 就会感知到 template 被修改了， Pod 需要更新。\n感知到更新之后， Deployment 就会创建一个新的 Replica Set 。然后逐渐将旧的 Replica Set 缩容到 0 ，并同时将新的 Replica Set 扩容到目标值。最后，所有旧版本的 Pod 将会被更新成新版本的 Pod 。如下图所示：\n\n```mermaid\nflowchart TB\n\nsubgraph A\ndirection TB\nDeployment1[Deployment]\nReplicaSet11[Replica Set]\nReplicaSet12[New Replica Set]\nPod11[Pod1]\nPod12[Pod2]\nDeployment1 --\u003e ReplicaSet11\nDeployment1 --\u003e ReplicaSet12\nReplicaSet11 --\u003e Pod11\nReplicaSet11 --\u003e Pod12\nend\n\nsubgraph B\ndirection TB\nDeployment2[Deployment]\nReplicaSet21[Replica Set]\nReplicaSet22[New Replica Set]\nPod21[New Pod1]\nPod22[Pod2]\nDeployment2 --\u003e ReplicaSet21\nDeployment2 --\u003e ReplicaSet22\nReplicaSet21 --\u003e Pod22\nReplicaSet22 --\u003e Pod21\nend\n\nsubgraph C\ndirection TB\nDeployment3[Deployment]\nReplicaSet31[Replica Set]\nReplicaSet32[New Replica Set]\nPod31[New Pod1]\nPod32[New Pod2]\nDeployment3 --\u003e ReplicaSet31\nDeployment3 --\u003e ReplicaSet32\nReplicaSet32 --\u003e Pod31\nReplicaSet32 --\u003e Pod32\nend\n\nA --\u003e B --\u003e C\n```\n\n整个过程完成后， Deployment 还不会将旧的 Replica Set 删除掉。我们注意到 Deployment 的声明中有这么一个字段： `revisionHistoryLimit: 10` ，表示 Deployment 会保留历史中 最近的 10 个 Replica Set ，这样在必要的时候可以立刻将 Deployment 回滚到上个版本。而超出 10 个的 Replica Set 才会被从 K8s 中删除。\n\n```sh\n# 实际中被 scale 到 0 但还没被删除的 Replica Set\n$ kubectl get rs -l app=gateway\nNAME                 DESIRED   CURRENT   READY   AGE\ngateway-5c4cdf957d   0         0         0       5d4h\ngateway-5c56f6d487   0         0         0       17d\ngateway-65857cfc78   0         0         0       10d\ngateway-6bddbdd85f   0         0         0       16d\ngateway-6cc9bb5b4c   0         0         0       13d\ngateway-6f4664bc65   0         0         0       17d\ngateway-7bd667cb79   0         0         0       9d\ngateway-7d658d57f5   0         0         0       13d\ngateway-84df97d4c8   0         0         0       6d4h\ngateway-9998f4689    0         0         0       13d\ngateway-9dc546658    2         2         2       5d4h\n```\n\n### Stateful Set\n\nDeployment 中默认了我们不关心自己访问的是哪个 Pod ，因为各个 Pod 的功能是一样的，访问哪个没有差别。\n\n实际上这也符合大多数情况：试想一个 HTTP Server ，如果其所有数据都存放到同一个的数据库中，那这个 HTTP Server 不管部署在哪台主机、不管有多少个实例、不管你访问的是哪个实例，都察觉不出有什么差别。而有了这种默认，我们就能更放心地对 Pod 进行负载均衡、缩扩容等操作。\n\n但实际上我们总会遇到需要保存自己状态的 Pod 。比如我们在 K8s 里部署一个 Kafka 集群，每个 Kafka broker 都需要保存自己的分区数据，而且还要往 Zookeeper 里写入自己的名字来实现选举等功能。如果简单地用 Deployment 来部署， broker 之间可能就会分不清到底哪块是自己的分区，而且由 Deployment 生成出来的 Pod 名字是随机的，升级后 Pod 的名字会变，导致 Kafka 升级后名字与 Zookeeper 里的名字不一致，被以为是一个新的 broker 。\n\nStateful Set 就是为了解决有状态应用的部署而出现的。下面是 用 bitnami 的 Kafka Helm Chart 部署的一个 Kafka Stateful Set 的例子：\n\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  labels:\n    app.kubernetes.io/name: kafka\n  name: kafka\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: kafka\n  serviceName: kafka-headless\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: kafka\n    spec:\n      containers:\n      - name: kafka\n        image: docker.io/bitnami/kafka:3.1.0-debian-10-r52\n        command:\n        - /scripts/setup.sh\n        ports:\n        - containerPort: 9092\n          name: kafka-client\n          protocol: TCP\n        volumeMounts:\n        - mountPath: /bitnami/kafka\n          name: data\n  volumeClaimTemplates:\n  - apiVersion: v1\n    kind: PersistentVolumeClaim\n    metadata:\n      name: data\n    spec:\n      resources:\n        requests:\n          storage: 10Gi\n      storageClassName: gp2\n```\n\n可以看到其实 Stateful Set 类似 Deployment ，也可以通过 replicas 字段定义实例数，如果更新 template 部分， Stateful Set 也会以一定的策略对 Pod 进行更新。\n\n而其创建出来的 Pod 如下所示：\n```sh\n$ kubectl get po -l app.kubernetes.io/name=kafka\nNAME      READY   STATUS    RESTARTS   AGE\nkafka-0   1/1     Running   1          26d\nkafka-1   1/1     Running   3          26d\nkafka-2   1/1     Running   3          26d\n```\n\n与 Replica Set 创建出来的 Pod 相比名字上会有很大差别。 Stateful Set 创建出来的 Pod 会固定的以 `-0` 、 `-1` 、 `-2` 结尾而不是随机生成：\n\n```mermaid\nflowchart TB\nrs[Replica Set A]\nrs --\u003e A-qwert\nrs --\u003e A-asdfg\nrs --\u003e A-zxcvb\n\nss[Stateful Set A]\nss --\u003e A-0\nss --\u003e A-1\nss --\u003e A-2\n```\n\n这样一来，更新时将 Pod 更换之后，新的 Pod 仍能够跟旧的 Pod 保持相同的名字。此外，与 Deployment 相比， Stateful Set 更新后同名的 Pod 仍能保持原来的 IP ，拿到同一个持久化卷，而且不同的 Pod 还能通过独立的 DNS 记录相互区分。这些内容后面还会详细介绍。\n\n\u003e **宠物与牛（ Cattle vs Pets ）的比喻**\n\u003e \n\u003e Deployment 更倾向于将 Pod 看作是牛：我们不会去关心每一个 Pod 个体，如果有一个 Pod 出现了问题，我们只需要把他杀掉并替换成新的 Pod 就好。\n\u003e \n\u003e 但 Stateful Set 更倾向于将 Pod 看作是宠物：弄来一直完全一模一样的宠物并不是容易的事，我们对待这些宠物必须小心翼翼。我们要给他们各自一个专属的名字，替换掉一只宠物时，必须要保证它的花色、名字、行为举止都与之前那只宠物一模一样。\n\n### Daemon Set\n\n不管是 Deployment 还是 Stateful Set ，一般都不会在意自己的 Pod 部署到哪个节点。而假如你不在意自己 Pod 的数量，但需要保证每个节点上都运行一个 Pod 时，就需要 Daemon Set 了。\n\n需要保证每个节点上有且只有一个 Pod 在运行这种情况，经常会在基础结构相关的操作中出现。比如我需要在集群中部署 fluentd 采集 log ，一般来说需要在 Pod 里直接挂载节点磁盘上的文件路径。这种时候如果有一个节点上没有运行 Pod ，那个节点的 log 就采集不到；另一方面，一个节点上运行多个 Pod 毫无意义，而且可能还会导致 log 重复等冲突。\n\n这种需求下简单地使用 Replica Set 或是 Stateful Set 都是不能达到要求的，这两种资源都只能通过亲和性达到“尽量不部署在同一个节点”，做不到绝对。而且当节点数有变更时还需要手动更改设置。\n\n下面是一个用 fluent-bit helm chart 部署的 fluent-bit Daemon Set 的例子：\n\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n    app.kubernetes.io/instance: fluent-bit\n    app.kubernetes.io/name: fluent-bit\n  name: fluent-bit\n  namespace: fluent-bit\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance: fluent-bit\n      app.kubernetes.io/name: fluent-bit\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/instance: fluent-bit\n        app.kubernetes.io/name: fluent-bit\n    spec:\n      containers:\n      - image: cr.fluentbit.io/fluent/fluent-bit:1.9.5\n        volumeMounts:\n        - name: varlibdockercontainers\n          mountPath: /var/lib/docker/containers\n          readOnly: true\n        - name: etcmachineid\n          mountPath: /etc/machine-id\n          readOnly: true\n      volumes:\n      - name: varlibdockercontainers\n        hostPath:\n          path: /var/lib/docker/containers\n          type: \"\"\n      - name: etcmachineid\n        hostPath:\n          path: /etc/machine-id\n          type: File\n```\n\nSelector 之类的都是一样的了，而 Daemon Set 不能指定 replicas 。另外可以看到一个比较刺激的地方： Volume 里使用了 `hostPath` 这种 Volume ，在 Pod 里直接指定了宿主机磁盘上的路径。\n\nK8s 认为经过抽象后， Pod 不应该去关心自己在哪台宿主机上，一般来说是不推荐在 Pod 里直接访问宿主机路径的（不过也没有强制禁止）。不过 Daemon Set 是个特例，由于 Daemon Set 生成的 Pod 与节点强相关， K8s 十分推荐在且仅在 Daemon Set 的 Pod 中访问宿主机路径。\n\n### Job 与 CronJob\n\nReplica Set ， Stateful Set ， Daemon Set 的 Pod 中运行的一般是持续运行的程序，因此这些 Pod 运行终止后会有相应的机制重启这些 Pod 。而 Job 与 Cron Job 这两种资源则专门负责调度不会持续运行的程序。\n\n下面是 《Kubernetes in Action》 书中的一个例子：\n\n```yaml\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: pi\nspec:\n  completions: 5\n  parallelism: 2\n  template:\n    spec:\n      containers:\n      - name: pi\n        image: perl:5.34.0\n        command: [\"perl\",  \"-Mbignum=bpi\", \"-wle\", \"print bpi(2000)\"]\n      restartPolicy: Never\n```\n\n可以看到，这个 Job 描述了一个会输出 PI 小数点后 2000 位的 Pod 模板。这个 Job 部署后，一共会以这个模板跑完 5 个 Pod ，其中最多并行跑 2 个，并在其中一个成功终止后再跑剩下的 Pod 。可以通过调整 `completions` 与 `parallelism` 字段调整并行与穿行数量。\n\n顺带一提，在 Job 定义中一般不会出现 selector ，但其实 Job 有 selector 字段，一般会由 K8s 为每个 Job 生成一个 uuid 作为 selector 。\n\n另外，可以通过部署 CronJob 这种资源来定时执行 Job 。下面是 《Kubernetes in Action》 书中关于 CronJob 的例子：\n\n```yaml\napiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\n  name: pi\nspec:\n  schedule: \"0 0 * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: pi\n            image: perl:5.34.0\n            command: [\"perl\",  \"-Mbignum=bpi\", \"-wle\", \"print bpi(2000)\"]\n          restartPolicy: Never\n```\n\n这个例子中， CronJob 会在每天的 0 点创建一个只运行一个 Pod 的 Job 。 CronJob 不会直接创建 Pod ，而是创建一个 Job ，再由 Job 创建 Pod （就像 Deployment 与 Replica Set 的关系）。另外， CronJob 创建的 Job 会限制 `completions` 与 `parallelism` 都只能等于 1 。\n\n\u003e 关于资源的名称空间\n\u003e \n\u003e 在 K8s 中，各资源都是不能重名的。不能部署两个都叫 `gateway` 的 Pod ，资源之间有可能因为名字冲突而导致部署不成功。（部署一个叫 `gateway` 的 Pod 和一个叫 `gateway` 的 Deployment 倒是可以，因为 `gateway` 不是他们两个的全名，他们的全名分别叫 `pod/gateway` 及 `deployment/gateway` 。）\n\u003e 另外我们已经知道 Deployment 等资源一般会通过标签等来管理自己创建的资源，那两份不相关的应用完全有可能会撞标签，这时候部署逻辑就有可能会出问题。\n\u003e \n\u003e K8s 中提供了名称空间这种资源，用于进行资源隔离。K8s 中大部分资源都从属于一个且仅从属于一个名称空间， Deployment 等资源一般只能控制在同一名称空间下的资源，而不会影响其他名称空间。\n\u003e \n\u003e 另外，也有一些资源是名称空间无关的，比如节点 `Node` 。\n\n\n","title":"Kubernetes 入门 （1）","abstract":"我们知道 K8s 利用了容器虚拟化技术。而说到容器虚拟化就要说 Docker 。可是，容器到底是什么？ Docker 又为我们做了些什么？我们又为什么要用 K8s ？\n\u003e 要把一个不知道打过多少个升级补丁，不知道经历了多少任管理员的系统迁移到其他机器上，毫无疑问会是一场灾难。 —— Chad Fowler 《Trash Your Servers and Burn Your Code》\n\"Write once, run anywhere\" 是 Java 曾经的口号。 Java 企图通过 JVM 虚拟机来实现一个可执行程序在多平台间的移植性。但我们现在知道， Java 语言并没能实现他的目标，会在操作系统调用、第三方依赖丢失、两个程序间依赖的冲突等各方面出现问题。","length":644,"created_at":"2022-08-13T17:45:31.000Z","updated_at":"2022-08-20T14:02:18.000Z","tags":["Kubernetes","DevOps","Docker","Cloud Native"],"license":true,"headingTrees":[{"key":"容器-docker-与-k8s","href":"#容器-docker-与-k8s","heading":1,"title":"容器， Docker 与 K8s","children":[{"key":"关于容器虚拟化","href":"#关于容器虚拟化","heading":3,"title":"关于容器虚拟化","children":[],"id":"关于容器虚拟化"},{"key":"关于-docker","href":"#关于-docker","heading":3,"title":"关于 Docker","children":[],"id":"关于-docker"},{"key":"为什么要用-k8s-","href":"#为什么要用-k8s-","heading":3,"title":"为什么要用 K8s ？","children":[],"id":"为什么要用-k8s-"},{"key":"k8s-与-docker-的关系","href":"#k8s-与-docker-的关系","heading":3,"title":"K8s 与 Docker 的关系","children":[],"id":"k8s-与-docker-的关系"}],"id":"容器-docker-与-k8s"},{"key":"部署一个-pod","href":"#部署一个-pod","heading":1,"title":"部署一个 Pod","children":[{"key":"pod-示例","href":"#pod-示例","heading":3,"title":"Pod 示例","children":[],"id":"pod-示例"}],"id":"部署一个-pod"},{"key":"部署更多-pod","href":"#部署更多-pod","heading":1,"title":"部署更多 Pod","children":[{"key":"replica-set","href":"#replica-set","heading":3,"title":"Replica Set","children":[],"id":"replica-set"},{"key":"deployment","href":"#deployment","heading":3,"title":"Deployment","children":[],"id":"deployment"},{"key":"stateful-set","href":"#stateful-set","heading":3,"title":"Stateful Set","children":[],"id":"stateful-set"},{"key":"daemon-set","href":"#daemon-set","heading":3,"title":"Daemon Set","children":[],"id":"daemon-set"},{"key":"job-与-cronjob","href":"#job-与-cronjob","heading":3,"title":"Job 与 CronJob","children":[],"id":"job-与-cronjob"}],"id":"部署更多-pod"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2022-07-31-why-homogeneous.md","pagePath":"/articles/why-homogeneous","slug":"why-homogeneous"},"meta":{"content":"## 首先，什么是线性变换？\n\n简化了一万倍来说，线性变换主要是在描述符合这两种性质的变换：一是要可加，二是要能数乘。\n也就是说，对于空间中所有向量 $$\\vec{v_1}, \\vec{v_2}$$ ，以及任意数量 $$k_1, k_2$$ ，如果有：\n$$\nA(k_1 \\vec{v_1} + k_2 \\vec{v_2}) = k_1 A(\\vec{v_1}) + k_2 A(\\vec{v_2})\n$$\n符合这种规律的 A 就叫线性变换。而一次矩阵乘法正好可以代表一次线性变换。\n\n为什么叫“线性”变换呢？感性地来说，因为它很“线”。\n\n我们可以直观地从下面这张图看出原因：\n\n![[OnOneLineWillStillOneLine_ManimCE_v0.16.0.post0.gif]]\n\n我们可以看到，在同一直线上的点，经过同一线性变换后还在同一直线上。所以它很“线”。\n\n另一方面，我们可以找一找最简单的线性变换：\n\n考虑函数：\n$$\nf(x) = k_0 x\n$$\n我们都知道这是一条过原点的直线。\n\n而从另一方面想，其实这个函数对于任意一维向量（实数） $$x_1, x_2$$ , 与任意数量（实数） $$k_1, k_2$$ , 都有：\n$$\nf(k_1 x_1 + k_2 x_2) = k_1 k_0 x_1 + k_2 k_0 x_2 = k_1 f(x_1) + k_2 f(x_2) \\\\\n$$\n\n即， xy 平面上过原点的直线（正比例函数）本身就是一种从 x 轴到 y 轴的线性变换。\n\n关于线性变换， [3blue1Brown](https://www.3blue1brown.com/topics/linear-algebra) 上有更详细更感性的介绍，大家感兴趣可以前往观看。\n\n## 为什么普通的线性变换不能表示点平移？\n\n从上面的感性介绍来看，我们知道线性变换的性质就是可加和数乘，写成等式就是：\n\n$$\nA(k_1 \\vec{v_1} + k_2 \\vec{v_2}) = k_1 A(\\vec{v_1}) + k_2 A(\\vec{v_2})\n$$\n\n而当两个向量都为零向量时，等式就会简化成：\n\n$$\nA(\\vec{0}) = A(\\vec{0}) + A(\\vec{0})\n$$\n\n解一下方程，就可以知道，对任意线性变换 A，都会有：\n\n$$\nA(\\vec{0}) = 0\n$$\n\n也就是说，不管是哪个线性变换 A ，原点经过变换后都必须只能是在原点不变。如果变换后原点的位置变了，那它就一定不是线性变换。\n\n我们从下图也可以看出，对于切变 $$\\begin{pmatrix}1 \u0026 1 \\\\ 0 \u0026 1\\end{pmatrix}$$ 、伸缩 $$ \\begin{pmatrix}2 \u0026 0 \\\\ 0 \u0026 \\frac{1}{2}\\end{pmatrix} $$、旋转 $$ \\begin{pmatrix}\n    \\frac{\\sqrt{3}}{2} \u0026 -\\frac{1}{2} \\\\ \\frac{1}{2} \u0026 \\frac{\\sqrt{3}}{2}\n\\end{pmatrix} $$ 这些经典的线性变换，变换后原点都不会变。\n\n![[SliceScaleRotateForOrigin_ManimCE_v0.16.0.post0.gif]]\n\n但是平移这种变换不一样。原点经过平移后，是一定不会还留在原点的。因此平移不是一种线性变换，自然也不能用矩阵来表示。\n\n## 为什么基于齐次坐标下的线性变换就可以表示平移？\n\n我们先来看一下齐次坐标做了些什么。\n\n在上面传统的线性变换中，我们不会考虑向量与点的区别。一个二维坐标 $$(x, y)$$ 既能代表那个坐标上的点，也能代表从原点到 $$(x, y)$$ 的向量。这时，点与向量是一一对应的。\n\n但如果要考虑平移，点与向量就不能再一一对应了，因为对向量平移没有意义（不考虑物理中力矩的场景）。\n所以在齐次坐标下，我们需要区分这个坐标代表的是点还是向量。\n\n以二维空间为例，齐次坐标就是在二维空间上加了第三个维度 w 轴，二维空间里的点在 w 轴上的值为 1 ，而二维向量在 w 轴上的值对应为 0 ：\n\n$$\n\\begin{align}\n    P \u0026= \\begin{pmatrix}x \u0026 y \u0026 1\\end{pmatrix} \\\\\n    \\vec{v} \u0026= \\begin{pmatrix}v_x \u0026 v_y \u0026 0\\end{pmatrix}\n\\end{align}\n$$\n\n从字面上看可能还是不太明显，让我们试着把二维空间齐次坐标强行转化为三维空间坐标看看：\n\n![[HomogeneousTransform_ManimCE_v0.16.0.post0.gif]]\n\n我们发现，原来二维空间中的点，被投射到三维空间中 w = 1 的平面上了！\n\n这样一来，二维空间齐次坐标下的平移矩阵也很好理解了：\n\n$$\n将平面沿向量 (x, y) 平移：\n\\begin{pmatrix}\n    1 \u0026 0 \u0026 x \\\\\n    0 \u0026 1 \u0026 y \\\\\n    0 \u0026 0 \u0026 1\n\\end{pmatrix}\n$$\n\n这不就是三维空间中在 w 轴上做切变时的变换矩阵嘛！\n\n我们可以重点关注一下 $$\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}$$ 这个向量。\n从齐次坐标的定义来看，这个向量对应着二维空间中的原点 $$P_{Origin} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$ 。而由矩阵乘法计算可知，经过 $$ A = \\begin{pmatrix} 1 \u0026 0 \u0026 x \\\\ 0 \u0026 1 \u0026 y \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix} $$ 对应的线性变换后， $$ \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix} $$ 这个向量会被映射到 $$ \\begin{pmatrix}x\\\\y\\\\1\\end{pmatrix} $$ 上。也就是说，二维空间原点 $$ P_{Origin} = \\begin{pmatrix}0\\\\0\\end{pmatrix}$$ 经过变换后会变为 $$ P_{Origin}' = A(P_{Origin}) = \\begin{pmatrix}x\\\\y\\end{pmatrix}$$ 。\n\n而对于二维空间中的向量 $$\\vec{v}=\\begin{pmatrix}v_x\\\\v_y\\end{pmatrix}$$ ，其齐次坐标下 w 轴方向分量为 0 ，因此 w 轴方向上的切变并不会影响二维空间中的向量。即 $$ \\vec{v'} = A(\\vec{v}) = \\vec{v} $$ 。\n\n而对于原来二维空间中的其他点的坐标：\n$$\nP = \\begin{pmatrix}x_0\\\\y_0\\end{pmatrix}\n$$ \n其实可以理解为原点坐标再加上一个偏移向量：\n$$\nP = \\begin{pmatrix}0\\\\0\\end{pmatrix} + \\begin{pmatrix}x_0\\\\y_0\\end{pmatrix} = P_{Origin} + \\vec{v}_{x,y}\n$$\n\n而在齐次坐标下，点坐标 = 原点坐标 + 偏移向量 这一等式仍然成立：\n$$\nP =  \\begin{pmatrix}x_0\\\\y_0\\\\1\\end{pmatrix} = \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix} + \\begin{pmatrix}x_0\\\\y_0\\\\0\\end{pmatrix} = P_{Origin} + \\vec{v}_{x,y}\n$$\n\n而由于切变是线性变换，因此有：\n\n$$\n\\begin{align}\nP' \u0026= A(P) \\\\\n\u0026= A(P_{Origin} + \\vec{v}_{x,y}) \\\\\n\u0026= A(P_{Origin}) + A(\\vec{v}_{x,y}) \\\\\n\u0026= P_{Origin}' + \\vec{v}_{x,y} \\\\\n\\end{align}\n$$\n\n因为切变前后偏移向量没有发生变化，因此二维空间上的点经变换后相对于原点的方向、距离都没有发生变化。由此也可得出，原先由二维空间中的点组成的图案，经齐次坐标下 w 轴的切变后，其大小、形状、方向都不会发生变化。\n\n![[SliceOnHomogeneousWithGraph_ManimCE_v0.16.0.post0.gif]]\n\n而这种大小、形状、方向都不变化，只有整体位置发生了变化的变换，正是我们一般所说的“平移”。因此在齐次坐标下，我们能通过线性变换（aka 矩阵乘法）表示平移。\n\n\u003e 其实 $$\\begin{pmatrix}1 \u0026 0 \u0026 x \\\\0 \u0026 1 \u0026 y \\\\0 \u0026 0 \u0026 1\\end{pmatrix}$$ 对应切变作用后各点坐标如何变化这个过程， 3Blue1Brown 的[这个视频](https://www.3blue1brown.com/lessons/matrix-multiplication) 有更直观明了的解释，大家可以参考。\n\n## 总结一下\n\nQ: 为什么普通的矩阵乘法不能表示平移？\nA: 因为矩阵乘法只能表示线性变换。平移不是线性变换。\n\nQ: 为什么在齐次坐标下的矩阵乘法又能表示平移？\nA: 因为齐次坐标增加了一个维度。平移变换矩阵其实是在新增的这个维度上做切变（一种线性变换）。切变后的结果正好就是原坐标中的平移变换。\n\n\n","title":"为什么使用在齐次坐标下矩阵乘法能表示点平移？","abstract":"简化了一万倍来说，线性变换主要是在描述符合这两种性质的变换：一是要可加，二是要能数乘。\n也就是说，对于空间中所有向量 $$\\vec{v_1}, \\vec{v_2}$$ ，以及任意数量 $$k_1, k_2$$ ，如果有：\n$$","length":149,"created_at":"2022-07-31T15:35:17.000Z","updated_at":"2022-08-05T17:45:09.000Z","tags":[],"license":true,"headingTrees":[{"key":"首先什么是线性变换","href":"#首先什么是线性变换","heading":2,"title":"首先，什么是线性变换？","children":[],"id":"首先什么是线性变换"},{"key":"为什么普通的线性变换不能表示点平移","href":"#为什么普通的线性变换不能表示点平移","heading":2,"title":"为什么普通的线性变换不能表示点平移？","children":[],"id":"为什么普通的线性变换不能表示点平移"},{"key":"为什么基于齐次坐标下的线性变换就可以表示平移","href":"#为什么基于齐次坐标下的线性变换就可以表示平移","heading":2,"title":"为什么基于齐次坐标下的线性变换就可以表示平移？","children":[],"id":"为什么基于齐次坐标下的线性变换就可以表示平移"},{"key":"总结一下","href":"#总结一下","heading":2,"title":"总结一下","children":[],"id":"总结一下"}],"wikiRefAliases":[],"richRefAliases":["OnOneLineWillStillOneLine_ManimCE_v0.16.0.post0.gif","SliceScaleRotateForOrigin_ManimCE_v0.16.0.post0.gif","HomogeneousTransform_ManimCE_v0.16.0.post0.gif","SliceOnHomogeneousWithGraph_ManimCE_v0.16.0.post0.gif"]}},{"pathMapping":{"filePath":"public/content/articles/2022-07-19-graph-for-economics-2.md","pagePath":"/articles/graph-for-economics-2","slug":"graph-for-economics-2"},"meta":{"content":"\n\u003e 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。\n\u003e 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。\n\n上一篇讲供给，这一篇讲需求。\n其实供给与需求有很多相似的地方，有时只需要套一下上一篇中给出的模型就能求解。因此各位如果还没有看过上一篇，可以先看完再回来看这一篇内容也不迟。\n\n讲需求曲线的时候，我们会先假设消费者是一个理性人，做决策时会将成本与收益作比较。比如在买冰酒这个场景，我们就会比较冰酒的价格与我们喝冰酒爽到的满足感（意愿支付价格），如果冰酒价格低于意愿支付价格我们就会去买这瓶冰酒。\n\n而假如我们是葡萄庄园主，我们当然也会去比较各种收益与成本，来决定是否制作冰酒拿出去卖。\n\n当我们选择制作冰酒拿出去卖，那收益自然就是卖冰酒所能拿到的钱，也就是冰酒的价格。\n\n但选择制作冰酒拿出去卖的成本呢？\n\n# 机会成本\n\n有一般会计常识的人可能会很快答出：成本不就是买种子、种葡萄、酿酒等过程中花掉的钱嘛！\n\n但实际上问题没有这么简单。因为我们的决策是“制作冰酒拿出去卖”，所以我们必须计算做出决策和不做出决策两种情况之间的差别。\n如果决定不制作冰酒拿出去卖，那我们可以省下一大笔时间与资金。我们可以拿着这些时间与资金去做其他事情，比如可以去种西瓜卖，可以去投资，甚至可以去打工当码农。这些活动都可以获得收益。\n而如果决定去制作冰酒拿出去卖，就代表你为了获得卖冰酒的收益，要选择放弃上面这些活动中获得的收益。“放弃获得这些收益的机会”也是你卖冰酒的成本。\n\n为了与常识中所说的成本做区别，我们把这种算上放弃收益机会的成本称为**机会成本**。经济学中常说的成本的也是机会成本。\n\n\u003e **机会成本**（ Opportunity cost ）：是指为了得到某种东西所必须放弃的东西。 _ 曼昆《经济学原理：微观经济学分册》：Page 52\n\n## 生产者的理性人决策模型\n\n还记得理性人决策的模型吗？不记得的话可以先看看上一篇。\n引入了机会成本这一概念，我们套模型的三个要素就都准备好了：\n- 做决策 = 生产冰酒拿出去卖\n- 收益 = 冰酒价格（卖冰酒拿到的钱）\n- 成本 = 机会成本\n\n那么我们就有：\n- if 冰酒价格 \u003e 机会成本 : 生产冰酒拿出去卖\n- if 冰酒价格 \u003c 机会成本 : 不生产冰酒\n\n[ [图片：机会成本柱，价格线，线高于柱做决策，线低于柱不做决策]]\n\n假设我们是葡萄庄园主，而且已经能预知冰酒市场价稳定在每瓶 50 元。如果我们荒废掉庄园拿钱去投资，就算减去掉投资风险，赚的钱都比卖冰酒赚的钱多得多，那我们就会毫不犹豫地荒废掉庄园选择躺着赚钱。这种其实就是机会成本高于交易收益的情况。\n\n## 生产者剩余\n\n如果收益高于机会成本，那我们就会毫不犹豫地选择生产冰酒拿出去卖。为啥？因为能赚钱呀！赚钱嘛，不寒掺。\n\n“赚钱”，可能就是生产者剩余最贴切地解释了。因为卖冰酒获得的收益（冰酒价格），比制作冰酒的成本（制作冰酒所放弃的其他收益加上制作冰酒耗费的金钱，也就是机会成本）更多，我们称在卖出冰酒的过程中我们获得了生产者剩余。\n\n\u003e **生产者剩余**（ producer surplus ）：卖者出售一种商品得到的量减去其生产成本。Page 140\n\n与消费者剩余类似，生产者剩余计算上表示为：\n$$\n生产者剩余 = 卖出商品得到的量 - 卖出商品所支付的金钱\n$$\n表示为图的话就是商品价格与成本之间的部分：\n[ [图片：生产者剩余柱，价格线，线与柱之间的部分]]\n\n## 供给曲线\n\n与上一篇里消费者情况类似，市场中的生产者也不会只有我们一个。我们把市场中（可能）卖冰酒的人全部抓过来审问一遍，统计一下他们卖冰酒的机会成本，从低到高排个序后就得到下面的图：\n\n[ [图：机会成本柱状图，从低到高连成曲线，冰酒价格横线，线高于柱做决策，线低于柱不做决策]]\n\n与上一篇需求曲线过程类似，把各人机会成本连成曲线，我们就得到了冰酒市场中的供给曲线。\n\n供给曲线与冰酒价格交点的左边，由于这些生产者机会成本小于商品价格，能获得生产者剩余，他们就会选择制作并卖出冰酒（进入市场）。假设他们全部都能卖出冰酒，那他们卖出冰酒的量就是并就的交易量，他们的生产者剩余总和，也就是需求曲线以上价格线以下的部分，就是冰酒市场中总的生产者剩余。\n\n[ [图：需求曲线与价格的交点，纵坐标横坐标解释，价格变动后，纵坐标与横坐标变化解释，交点连续变为曲线]]\n\n与上一篇同理，由于机会成本比较高，处于供给曲线与价格线交点右方的那些人不会选择制作冰酒，因此他们并不会在冰酒市场获得或失去生产者剩余。\n\n# 均衡\n\n上面分析供给曲线，包括上一篇中分析需求曲线时，我们都是先假设先有一个价格，然后再分析如果价格高了会怎么样，如果价格低了会怎么样。\n\n可是这个价格是谁来定的？\n\n## 完全竞争市场\n\n为了分析这个问题，我们需要引入除理性人假设外第二个假设：完全竞争市场假设：\n\n我们假设市场是完全竞争的，这样的市场必须具有三个特征：\n1. 消费者能自由选择购买任一生产者的商品\n2. 市场中的商品都是完全相同的\n3. 买卖双方都人数众多\n\n在这种假设下，市场中所有商品价格都相等，且没有任何一个消费者或生产者能够影响市场价格。因为如果有一个生产者的商品价格高于市场价，消费者们就会到别的地方购买；而由于他们都是理性人，没有生产者会打算以低于市场价的价格出售商品。消费者角度也同理：没有理由用高价买商品，而低价将买不到商品。\n\n这时，我们就可以把需求曲线与供给曲线放在一起分析，由于完全竞争市场中：\n$$\n任意消费者购买商品的价格 = 任意生产者出售商品的价格\n$$\n因此市场中商品价格是固定值，是水平于供给量/需求量的横线。\n[ [图：需求曲线与供给曲线，价格横线只有一条，高于交点时与低于交点时]]\n\n另外，我们看到供给曲线与需求曲线之间有一个交点。接下来我们就要针对这个交点，解决完全竞争市场中价格由谁来定的问题。\n\n## 市场趋向于均衡\n\n首先我们考虑如果价格高于交点时的情况。\n\n前面我们说过，只有价格线与需求曲线交点左边的消费者会购买商品，而只有价格线与供给曲线交点左边的生产者会生产并出售商品。因此我们可以直观地知道，这时商品供给量比需求量要多。那多出来的那一部分商品一定会卖不出去。\n\n卖不出去咋办呀？那就只能降价。\n之前我们说完全竞争市场中生产者没有低价出售商品的理由，那是建立在商品都能卖出去前提下的。商品都能卖出去时没有道理自损利益，但现在商品卖不出去就只能降价吸引客流了。（其实提升商品质量也增加售出量是一种好方法，但我们这里假设了是完全竞争市场，所有商品都完全相同）\n\n消费者们也都是理性人，既然商品完全相同，自然就会选择购买更低价的商品。原本还凑合着能卖出去的那部分商品反而因为未降价变得卖不出去了，自然他们也会选择降价，最终市场中商品的价格整体降低。\n\n市场价降低，使得一部分生产者的机会成本高过了收益，这一部分生产者就会选择离开，使得供给量下降。另一方面，降价使得价格低过了一部分潜在消费者的意愿支付价格，这一部分人就会选择购买商品，使得需求量上升。\n\n[ [图：均衡P81(Eng P77)，价格高于均衡的情况]]\n\n而另一种情况，也相类似。如果价格低于交点，市场中商品的需求量就会大于供给量。这时必然会有一部分人想买但是买不到商品，他们就会逐渐选择用更高的价格来购买，最终拉高整个市场中的商品价格。市场价升高，使得供给量上升，需求量下降。\n\n[ [图：价格低于均衡的情况]]\n\n价格高于交点时会趋于降价，而价格低于交点时会趋于涨价。在充分选择的情况下，最终市场价会等于交点处商品价格。这时市场达到均衡，生产者生产出的所有商品都能卖出，所有消费者都能购买到他们所需的商品。\n\n## 市场效率与福利\n\n之前我们提过消费者剩余与生产者剩余的概念。\n\n消费者剩余 = 意愿支付价格 - 商品价格，如果一个消费者在一场交易中消费者剩余越大，他就感觉越赚，他就对这场交易越满意。对于市场中所有消费者都是如此，因此市场中所有的消费者剩余，也就是需求曲线以下价格线以上的面积，代表了市场中所有消费者对市场交易的满意度。\n\n同样的，生产者剩余 = 商品价格 - 机会成本。市场中所有的生产者剩余，就是价格曲线以下供给曲线以上的部分，代表了市场中所有生产者对市场交易的满意度。\n\n因此，市场中总的生产者剩余加上总的消费者剩余，代表了市场中所有人对市场交易的满意度。我们称这就是市场中的总剩余。\n\n在市场均衡情况下，我们很容易地就能知道总剩余是多少。由于市场均衡时市场中所有的生产者与所有的消费者都能达成交易，而交易价格就是均衡价格。因此我们很容易地就能在图中找到代表生产者剩余、消费者剩余与总剩余的面积。\n\n[ [图]]\n\n而如果市场没有达到均衡，会出现有的消费者没能买到商品、或是生产者的商品没能卖出去的情况。这些时候，没能买到商品的消费者与没能卖出商品的生产者自然不会对交易满意（因为没能达成交易），自然也不计算剩余。而市场中商品的交易量取决于需求量与供给量中更小的一方。无论如何，总剩余总会小于均衡时的总剩余。\n\n[ [图]]\n\n由此可以看出，只有当市场达到均衡的时候，加入市场的所有人对市场交易的满意度最大。而市场均衡是完全竞争的自由市场中会自发达到的状态。\n\n因此，从经济学的观点来看，在所有人都是理性人、市场是完全竞争市场的假设下，不需要任何外加的制度或政策，市场就会自发地达到人们满意度最高的状态。也正因如此，亚当·斯密才会说市场是一个看不见的手。\n\n# 总结一下\n\n\n\n\n\n\n\nneeded:\n- [ ] svg character\n- [ ] bar graph\n- [ ] function graph\n- [ ] manim command for output path and input path https://docs.manim.community/en/stable/tutorials/configuration.html\n- [ ] want mp4 as picture\n- [ ] interactive manim https://github.com/3b1b/3Blue1Brown.com/tree/main/public/content/lessons/2021/newtons-fractal\n\n\n# 税收，污染权与外部性，国际贸易\n\n※\n# 比较优势\n# 弹性与均衡移动，收益分析 \n# 生产成本，垄断，寡头\n# 生产要素市场\n\n宏观：\n重点：\n1. 三个指标：GDP，价格水平，就业 =》 促使政府调节经济\n2. 两种政策：\n    1. 货币政策 =》 名义利率，量化宽松，前瞻指引，汇率决定制度等\n    2. 财政政策 =》 加息、采购\n3. 两种政策对经济影响（总供给总需求模型），以及国际经济与贸易影响\n\n# 三个指标与两种政策\n## 三个指标\n## 经济增长的原因 —— 全要素生产率\n\n## 经济波动\n## 凯恩斯主义 —— 促进政府调节经济\n## 调节经济两种政策\n# 财政政策\n# 货币政策\n\n## 两种政策对经济影响 —— 总供给总需求模型\n## 国际经济\n\n","title":"图解经济学原理(2)","abstract":"\u003e 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。\n\u003e 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。\n上一篇讲供给，这一篇讲需求。","length":188,"created_at":"2022-07-19T23:12:48.000Z","updated_at":"2022-08-13T09:53:03.000Z","tags":[],"license":true,"headingTrees":[{"key":"机会成本","href":"#机会成本","heading":1,"title":"机会成本","children":[{"key":"生产者的理性人决策模型","href":"#生产者的理性人决策模型","heading":2,"title":"生产者的理性人决策模型","children":[],"id":"生产者的理性人决策模型"},{"key":"生产者剩余","href":"#生产者剩余","heading":2,"title":"生产者剩余","children":[],"id":"生产者剩余"},{"key":"供给曲线","href":"#供给曲线","heading":2,"title":"供给曲线","children":[],"id":"供给曲线"}],"id":"机会成本"},{"key":"均衡","href":"#均衡","heading":1,"title":"均衡","children":[{"key":"完全竞争市场","href":"#完全竞争市场","heading":2,"title":"完全竞争市场","children":[],"id":"完全竞争市场"},{"key":"市场趋向于均衡","href":"#市场趋向于均衡","heading":2,"title":"市场趋向于均衡","children":[],"id":"市场趋向于均衡"},{"key":"市场效率与福利","href":"#市场效率与福利","heading":2,"title":"市场效率与福利","children":[],"id":"市场效率与福利"}],"id":"均衡"},{"key":"总结一下","href":"#总结一下","heading":1,"title":"总结一下","children":[],"id":"总结一下"},{"key":"税收污染权与外部性国际贸易","href":"#税收污染权与外部性国际贸易","heading":1,"title":"税收，污染权与外部性，国际贸易","children":[],"id":"税收污染权与外部性国际贸易"},{"key":"比较优势","href":"#比较优势","heading":1,"title":"比较优势","children":[],"id":"比较优势"},{"key":"弹性与均衡移动收益分析","href":"#弹性与均衡移动收益分析","heading":1,"title":"弹性与均衡移动，收益分析","children":[],"id":"弹性与均衡移动收益分析"},{"key":"生产成本垄断寡头","href":"#生产成本垄断寡头","heading":1,"title":"生产成本，垄断，寡头","children":[],"id":"生产成本垄断寡头"},{"key":"生产要素市场","href":"#生产要素市场","heading":1,"title":"生产要素市场","children":[],"id":"生产要素市场"},{"key":"三个指标与两种政策","href":"#三个指标与两种政策","heading":1,"title":"三个指标与两种政策","children":[{"key":"三个指标","href":"#三个指标","heading":2,"title":"三个指标","children":[],"id":"三个指标"},{"key":"经济增长的原因--全要素生产率","href":"#经济增长的原因--全要素生产率","heading":2,"title":"经济增长的原因 —— 全要素生产率","children":[],"id":"经济增长的原因--全要素生产率"},{"key":"经济波动","href":"#经济波动","heading":2,"title":"经济波动","children":[],"id":"经济波动"},{"key":"凯恩斯主义--促进政府调节经济","href":"#凯恩斯主义--促进政府调节经济","heading":2,"title":"凯恩斯主义 —— 促进政府调节经济","children":[],"id":"凯恩斯主义--促进政府调节经济"},{"key":"调节经济两种政策","href":"#调节经济两种政策","heading":2,"title":"调节经济两种政策","children":[],"id":"调节经济两种政策"}],"id":"三个指标与两种政策"},{"key":"财政政策","href":"#财政政策","heading":1,"title":"财政政策","children":[],"id":"财政政策"},{"key":"货币政策","href":"#货币政策","heading":1,"title":"货币政策","children":[{"key":"两种政策对经济影响--总供给总需求模型","href":"#两种政策对经济影响--总供给总需求模型","heading":2,"title":"两种政策对经济影响 —— 总供给总需求模型","children":[],"id":"两种政策对经济影响--总供给总需求模型"},{"key":"国际经济","href":"#国际经济","heading":2,"title":"国际经济","children":[],"id":"国际经济"}],"id":"货币政策"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2022-06-28-graph-for-economics-1.md","pagePath":"/articles/graph-for-economics-1","slug":"graph-for-economics-1"},"meta":{"content":"\n\u003e 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。\n\u003e 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。\n\n我们先不讲课，先来带个货。\n\n德国和加拿大有一种特别的葡萄酒，叫冰酒。这种葡萄酒制作工艺比较特殊，必须要在严冬葡萄被霜冻在藤曼上时采摘下来，再经过发酵、压榨酿造而成。\n在冰酒压榨过程中，大量的冰被去除，使得葡萄的成分得到浓缩，因此冰酒口感偏甜。但加工过程对温度要求十分苛刻，温度过高、过低、变化太过剧烈等都会对口感产生影响。由于冰酒工艺特别，主要只有德国、加拿大等少数地区生产。\n\n好了，现在来考虑一个消费场景：\n假如你到加拿大去旅游，回国时在机场看到有礼品店在卖冰酒，考虑买一瓶冰酒回国后自己消费饮用。这瓶冰酒容量大概为 400ml ，并且这瓶冰酒只是一个普通牌子，不是奢侈品或高档品牌。\n在这个场景下，请大家考虑两个问题：\n1. 假设商店中这瓶冰酒标价换算为人民币是 ￥100 ，你是否愿意以这个价格购买一瓶冰酒？\n2. 假设你还不知道这瓶冰酒的价格，你会选择购买的最高价格是一瓶冰酒多少元？\n\n在问题 2 中，你愿意支付的最高价格就是你的心理价位，如果商店价格高于心理价位，你就不会购买这件商品。而如果价格低于心理价位，你就会购买这件商品。\n\n# 意愿支付\n\n上面场景中所说的心理价位，在经济学中又叫**意愿支付**。\n\n\u003e **意愿支付**（ willingness to pay ）：是消费者愿意为获得某种物品所支付的最高代价。 —— 曼昆《经济学原理：微观经济学分册》: Page 134\n\n如果这瓶冰酒定价是 100 元，你会觉得太贵了不买，就说明你的意愿支付价格低于 100 元。\n然后我们再假设这瓶冰酒 50 元，你觉得很好很便宜，选择买了，就说明你的意愿支付价格在 100 元到 50 元之间。\n再把范围收窄一点， 80 元选择不买， 60 元选择买。范围逐渐收敛，买与不买之间的意向会变得越来越模糊。我们假设最终收敛到 70 元，你变得非常犹豫，感觉买与不买没有差别，那 70 元就是你的意愿支付价格。\n\n[ [图片：意愿支付价格逼近。价格100时，不买，价格50时，买，80，60，最后70时会犹豫]]\n\n## 意愿支付价格的经济学解释\n\n经济学上有理性人这一概念，实际上是在假设你在决定是否做决策时，会将成本与收益做比较：\n- if 收益 \u003e 成本 : 做出决策\n- if 收益 \u003c 成本 : 不做出决策\n\n在购买冰酒的场景中，做决策就是指“买冰酒”这个行为。而成本就是冰酒的价格，收益就是你喝下冰酒感觉“爽到”。\n而我们不是机器人，我们“爽到”的感觉是很难与价格这种数字相比较的。因此我们要找一个办法把我们的爽到量化为价格。\n而意愿支付价格就是这个办法。在上面的例子中，买与不买的价格范围不断逼近，最终到 70 元时你觉得买还是不买都没什么区别。也就是说你喝冰酒爽到，就相当于得到了 70 元。\n\n\u003e **意愿支付价格**：商品消费行为给消费者带来的效用的货币度量。\n\n\n有了意愿支付价格，买冰酒这件事就很容易模型化了。我们可以直接套回理性人决策的模型：\n- 做决策 = 买冰酒\n- 收益 = 意愿支付价格\n- 成本 = 冰酒价格\n\n则有：\n- if 意愿支付价格 \u003e 冰酒价格 : 买冰酒\n- if 意愿支付价格 \u003c 冰酒价格 : 不买冰酒\n\n[ [图片：意愿支付价格=收益柱=70元，价格=成本=线，线高于柱=不决策，线低于柱=决策]]\n\n在买冰酒这一决策中，你的收益就是 70 元（喝冰酒爽到）。要你花 100 元（冰酒价格）来换 70 元，你肯定是不干的。而要你花 50 元来换 70 元，你就会爽快答应了。\n\n## 消费者剩余\n\n在上面模型中，如果你的意愿支付价格是 70 元，而冰酒只卖 50 元，你就一定会买买买，因为只要花 50 元就能买到 70 元的“爽到”呀！买到就是赚到。\n\n70 元的“爽到”只要花 50 元就能买到，这中间就差了 20 元呢，你就会觉得买冰酒的这笔钱花得真值，赚到 20 元。经济学上就称这是得到了 20 元的消费者剩余。\n\n\u003e **消费者剩余**（ consumer surplus ）：买者原意为一种物品支付的量减去其为此实际支付的量。 —— 曼昆《经济学原理：微观经济学分册》: Page 135\n\n计算上：\n$$\n消费者剩余 = 意愿支付价格 - 商品价格 \n$$\n而实际上，消费者剩余是你买商品时赚到的感觉，是这种感觉的量化。\n你感觉买这瓶冰酒赚飞了，量化后表现为这次交易你获得的消费者剩余多；你感觉这次交易一般般，有点小贵（但还是愿意买），量化后就是这次交易你获得的消费者剩余少。你获得多少消费者剩余，就代表你在这场交易中赚到了多少（感觉上）。\n\n现在考虑另一种情况：你的意愿支付价格为 70 元，而冰酒价格为 100 元时。你没有选择交易，因此在这种情况，你没有获得消费者剩余，当然也没有失去消费者剩余。\n从另一个角度来说，你觉得交易成立后你会得到负的消费者剩余，因此机制的你决定不交易，防止了这次损失。\n\n话又说回来，实际情况中人的决策是不可能这么理性地去比较成本与收益，甚至有可能根本得不出一个意愿支付价格。因此上述讨论都是建立在假设上的——假设理性人模型成立。\n在实际情况中，这一假设可能根本不成立，因此这些讨论在现实中可能根本不适用。可这又有什么关系呢？就算相对论是正确的，牛顿定理仍然有他价值不是吗？\n\n# 需求曲线\n\n好了，上面说了一大堆，其实都是单个消费者（你）进行消费的情况。可实际上，这冰酒总不可能只有一个人买呀！\n\n而实际上，每个人对冰酒的爱好、口感要求、奢侈品需求等都是不同的。这就导致了每个人对冰酒这一商品的意愿支付价格可能都不一样！\n\n## 意愿支付价格统计\n\n我们假设，今天其实有包括你在内的 100 个客人都来过这家冰酒店。我把这 100 个客人全部逮住，按顺序每个人都审问了一遍意愿支付价格。于是得到了这样一幅意愿支付价格统计的图：\n\n[ [图：意愿支付价格柱状图，乱序，横坐标是到店时间，纵坐标价格，横线为冰酒价格，上下浮动，意愿支付价格超过冰酒价格就会购买]]\n\n如果冰酒价格为 80 元，那所有意愿支付价格超过 80 元的客人都会选择买冰酒，而意愿支付价格低于 80 元的人都不会选择买。而如果冰酒价格为 60 元，那意愿支付价格超过 60 元的那部分客人也会开始选择买。冰酒价格越低，选择买冰酒的客人就越多。\n\n可是这图有点乱：\n1. 看不出客人意愿支付价格的分布\n2. 如果有 200 个客人到店，对应价格的冰酒又会有多少人买？\n\n## 需求曲线\n\n为了处理上面提出的两个问题，我把客人按照意愿支付价格从高到低来了个快速排序，然后把柱状图连成了一条曲线：\n\n[ [图：快速排序，意愿支付价格从高到低，然后连成曲线，最后还是有冰酒价格横线]]\n\n我们能看到，代表冰酒价格（市场价格）的横线与曲线形成了一个交点。交点左边的客人都会选择买冰酒，而右边的人都会选择不买。\n冰酒价格下降，交点右移，选择购买冰酒的客人就会变多；冰酒价格上升，交点左移，购买的人就会变少。因此交点的横坐标就是购买冰酒的人数，也就是冰酒交易量。\n\n假设每个客人只会买一瓶冰酒，那么交点的横坐标同时也就是冰酒的需求量（实际上有客人不止买一瓶冰酒也没关系，我们可以当是来了两个客人）。而交点的纵坐标当然就是冰酒的价格。\n冰酒价格变化，交点位置也会变化，对应需求量也跟随发生变化。这条曲线描绘的就是冰酒需求量随冰酒价格变化的关系。\n\n[ [图：需求曲线与价格的交点，纵坐标横坐标解释，价格变动后，纵坐标与横坐标变化解释，交点连续变为曲线]]\n\n我们称这条曲线为冰酒的需求曲线。\n\n\u003e **需求曲线**（ Demand Curve ）：表示一种物品价格与需求量之间关系的图形 —— 曼昆《经济学原理：微观经济学分册》: Page 68\n\n像这样用需求曲线表示价格与需求量的关系，可以解决上面的两个问题：\n1. 客人意愿支付价格的分布就是需求曲线的形状（虽然我们为了简化只画直线，但其实曲线形状也是可以上凸下凹，甚至是S形的）\n2. 如果客人数量翻倍，我们一般认为新来的 100 人意愿支付价格分布跟原先 100 人的分布几乎相同，因此需求曲线形状不变，横坐标轴缩短一半（或者说图形横向拉伸一倍）就是我们要的结果了。\n\n值得一提的是，数学中我们常把横坐标当作自变量，而纵坐标表示因变量。但需求曲线中正相反，纵坐标的价格是自变量，需求量才是因变量。\n我记得高中老师一般都会说这是因为经济学家不懂数学，然后草草带过。但实际上，消费者意愿支付多少钱容易统计，而不同价格下到底有多少人会想买难以统计。通过统计意愿支付价格并排序生成需求曲线时，将价格放在纵轴是一种很合理的选择。马歇尔当初也是在这一框架下推导出需求曲线的，曼昆也在他的[这篇博客](http://gregmankiw.blogspot.com/2006/09/who-invented-supply-and-demand.html)中对此有过讨论。\n（实际上，马歇尔是从效用理论推导出需求曲线的，与我们上面推导的过程不一样，但总的来说还是在同一框架下。说马歇尔不懂数学，就像是在说薛定谔不懂数学——怎么可能嘛。）\n\n\n\n## 市场上所有的消费者剩余\n\n店里来了这么多人，每个人意愿支付价格都不一样，那每个人买到同样价格的冰酒，感觉赚到的程度肯定是不一样的。\n\n[ [图：柱状图，展示个人的消费者剩余，然后到线图，展示面积，即市场中的消费者剩余]]\n\n对于单个人来说，他的消费者剩余就是意愿支付价格减去商品价格，也就是柱子在价格线以上标橙色的部分。\n\n可现在到店里的不止一个人啊，我要算所有消费者一共感觉赚到了多少。那我就要把所有橙色部分加起来，也就是做了一个积分，积分的结果就是到店里所有人通过买冰酒这件事一共能赚多少了。大家别看到积分就怕，其实意思就是求需求曲线以下，价格线以上这一三角形的面积。\n（每个人买冰酒价格肯定是固定的。总不能对不同的人以不同的价格出售吧）\n\n值得一提的是，在价格线与需求曲线交点右边的这些人，是不算消费者剩余的，也不会使总的消费者剩余减少。因为他们嫌冰酒太贵（高于意愿支付价格），根本就没有买冰酒（达成交易）。\n\n\n# 总结一下\n\n","title":"图解经济学原理(1)","abstract":"\u003e 1. 这篇文章参考了曼昆的《经济学原理》与北京大学王辉老师的《微观经济学》课程，内容上会有部分相似。\n\u003e 2. 这篇文章中的图使用 3Blue1Brown 的动画生成工具 manim 的 Community Edition 制作，源代码之后会上传到 GitHub 。\n我们先不讲课，先来带个货。","length":139,"created_at":"2022-06-28T00:59:41.000Z","updated_at":"2022-06-28T14:24:43.000Z","tags":[],"license":true,"headingTrees":[{"key":"意愿支付","href":"#意愿支付","heading":1,"title":"意愿支付","children":[{"key":"意愿支付价格的经济学解释","href":"#意愿支付价格的经济学解释","heading":2,"title":"意愿支付价格的经济学解释","children":[],"id":"意愿支付价格的经济学解释"},{"key":"消费者剩余","href":"#消费者剩余","heading":2,"title":"消费者剩余","children":[],"id":"消费者剩余"}],"id":"意愿支付"},{"key":"需求曲线","href":"#需求曲线","heading":1,"title":"需求曲线","children":[{"key":"意愿支付价格统计","href":"#意愿支付价格统计","heading":2,"title":"意愿支付价格统计","children":[],"id":"意愿支付价格统计"},{"key":"需求曲线-1","href":"#需求曲线-1","heading":2,"title":"需求曲线","children":[],"id":"需求曲线-1"},{"key":"市场上所有的消费者剩余","href":"#市场上所有的消费者剩余","heading":2,"title":"市场上所有的消费者剩余","children":[],"id":"市场上所有的消费者剩余"}],"id":"需求曲线"},{"key":"总结一下","href":"#总结一下","heading":1,"title":"总结一下","children":[],"id":"总结一下"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2022-04-03-use-paste-image-and-vscode-memo.md","pagePath":"/articles/use-paste-image-and-vscode-memo","slug":"use-paste-image-and-vscode-memo"},"meta":{"content":"\n我平时使用 [vscode-memo](https://github.com/svsool/vscode-memo) 插件写笔记，其中插入图片使用 `![[]]` 语法，显示简短，也有较好的预览支持，体验极佳。希望这种特性也能在写 hexo 博客的时候使用。\n\n# 关于 vscode-memo\n\n可能有很多人不熟悉 vscode-memo 这个插件，我先来简单介绍一下。\n\nvscode-memo 定位是一个 knowledge base ，对标的是 [Obsidian.md](https://obsidian.md/) 等软件。其功能包括且不限于：\n\n1. 使用独有的短链接语法 `[[]]` 连接到其他文档与图片。\n2. 修改文件名时自动同步更新链接，反向查找当前文档被那些文档链接。\n3. 鼠标悬停时能预览链接与图片。\n\n同时，由于 vscode-memo 是个 vscode 插件，可以跟 vscode 的其他众多插件合作使用。比如 [vscode-memo 官方文档](https://github.com/svsool/vscode-memo/blob/master/help/How%20to/Pasting%20images%20from%20clipboard.md)里就推荐将 vscode-memo 与 vscode-past-image 插件配合，粘贴图片。\n\n这篇文章主要的目的，也是利用这两个插件，达到把图片粘贴为短链接，并被 Hexo 正常渲染为网页。\n\n# Image Paste 与 Hexo 的配置\n\n这一步其实很简单。\n\n在 Hexo 的文章中，一般需要使用从根目录起的相对链接。如有文件结构：\n\n```tree\nsource\n├───img\n│   └───in-post\n│       ├───heap-cheat-sheet.jpg\n│       └───post-js-version.jpg\n├───playground\n└───_posts\n    ├───2022-03-26-create-blog-cicd-by-github.md\n    └───2022-04-03-use-paste-image-and-vscode-memo.md\n```\n\n在 `2022-03-26-create-blog-cicd-by-github.md` 中引用 `heap-cheat-sheet.jpg` 这个图片，就需要 `![](/img/in-post/heap-cheat-sheet.jpg)` 这样的链接。\n\n但如果在配置里把 `post_asset_folder` 设为 `true` ，就可以在 Markdown 文件的同级位置的同名目录中直接找到图片。如：\n\n```tree\nsource\n├───img\n├───playground\n└───_posts\n    ├───2022-03-26-create-blog-cicd-by-github\n    │    ├───heap-cheat-sheet.jpg\n    │    └───post-js-version.jpg\n    ├───2022-03-26-create-blog-cicd-by-github.md\n    └───2022-04-03-use-paste-image-and-vscode-memo.md\n```\n\n然后在 `2022-03-26-create-blog-cicd-by-github.md` 中可以直接 `![](heap-cheat-sheet.jpg)` 引用图片。为了图片文件管理方便，我们打开这个配置项。\n\n为了能让 Image Paste 粘贴的图片能放到这个同名文件夹下，我们需要修改 Image Paste 配置，在 VSCode 的 Workspace Setting 中，添加如下设置：\n\n```json\n{\n    \"pasteImage.path\": \"${currentFileDir}/${currentFileNameWithoutExt}/\"\n}\n```\n\n# Image Paste 粘贴为 vscode-memo 短链接格式\n\n这一步也很简单。 Image Paste 可以设定粘贴后的格式。我们在 Workspace Setting 中添加如下设置即可：\n\n```json\n{\n    \"pasteImage.insertPattern\": \"![[${imageFileName}]]\",\n}\n```\n\n这样我们粘贴后的图片就能有预览功能了。\n\n# 让 Hexo 正确渲染 vscode-memo 的短链接\n\n这一步其实是最难的。 Hexo 当然不认识 vscode-memo 的短链接，而经过调查，现在还没有现成的方案让 Hexo 与 vscode-memo 集成。虽然我们提倡尽量不要重复造轮子，但这里我们也是除了造轮子没有其他办法了。\n\n我们采用的方案是让 Hexo 在渲染 Markdown 前，先把 Markdown 中形如 `![[]]` 的短链接，替换为 `![]()` 的正常 Markdown 图片链接。\n\n假设我们项目 `source` 文件夹如下：\n\n```tree\nsource\n├───playground\n└───_posts\n    ├───2022-03-26-create-blog-cicd-by-github\n    │    ├───heap-cheat-sheet.jpg\n    │    └───post-js-version.jpg\n    ├───2022-03-26-create-blog-cicd-by-github.md\n    └───2022-04-03-use-paste-image-and-vscode-memo.md\n```\n\n如在渲染 `2022-03-26-create-blog-cicd-by-github.md` 前，需要将其中的 `![[heat-cheat-sheet.jpg]]` 替换为 `![](heap-cheat-sheet.jpg)` 。我们知道 Hexo 在生成静态文件前会先把项目根目录下 `scripts` 目录下的所有脚本执行一遍。我们可以在这里注册一个 filter ，专门做这个替换。代码如下：\n\n```js\n'use-strict';\n\nhexo.extend.filter.register('before_post_render', function (data) {\n    const isToHandle = (data) =\u003e {\n        var source = data.source;\n        var ext = source.substring(source.lastIndexOf('.') + 1, source.length).toLowerCase();\n        return ['md'].indexOf(ext) \u003e -1;\n    }\n\n    if (!isToHandle(data)) {\n        return data;\n    }\n\n    const reg = /(\\s+)\\!\\[\\[(.+)\\]\\](\\s+)/g;\n\n    data.content = data.content\n        .replace(reg, function (raw, start, content, end) {\n            var nameAndTitle = content.split('|');\n            if (nameAndTitle.length == 1) {\n                return `${start}![](${content})${end}`;\n            }\n            return `${start}![${nameAndTitle[1]}](${nameAndTitle[0]})${end}`;\n        });\n    return data;\n\n})\n```\n\n# 测试一下\n\n文章中如下内容：\n\n![[这部分内容会被转换为图片.png]]\n\n\n而你看到上面的内容是一张图片，表示这个转换已经成功了。\n\n# 不足之处\n\n这一段代码仍有以下待改进的地方：\n1. 如果图片短链接的内容写在 Code Block 里，也一样会被转换。实际上我们一般不希望 Code Block 里的内容被转换，需要过滤一下。\n2. 形如 `![[文件|图片描述]]` 的内容会正常转换为 `![图片描述](文件)` 。然而我现在用的这个主题不支持图片描述。以后可能需要更换主题。\n\n# 补充\n\n如果希望网站图片放在 `img` 之类的文件夹下统一管理，不把 `post_asset_folder` 设为 `true` ，也是没问题的，可以通过修改代码，在返回 `${content}` 前添加统一前缀。\n\n而如果希望图片放在 `img` 下，又要按文章分文件夹管理，如下情况：\n\n```tree\nsource\n├───img\n│   ├───2022-03-26-create-blog-cicd-by-github\n│   │    ├───heap-cheat-sheet.jpg\n│   │    └───post-js-version.jpg\n│   └───2022-04-03-use-paste-image-and-vscode-memo\n├───playground\n└───_posts\n    ├───2022-03-26-create-blog-cicd-by-github.md\n    └───2022-04-03-use-paste-image-and-vscode-memo.md\n```\n\n可以通过在代码中引用 `data.source` 解决。","title":"完善 Hexo 编写环境，改善文章中使用图片的体验","abstract":"我平时使用 [vscode-memo](https://github.com/svsool/vscode-memo) 插件写笔记，其中插入图片使用 `![[]]` 语法，显示简短，也有较好的预览支持，体验极佳。希望这种特性也能在写 hexo 博客的时候使用。\n可能有很多人不熟悉 vscode-memo 这个插件，我先来简单介绍一下。\nvscode-memo 定位是一个 knowledge base ，对标的是 [Obsidian.md](https://obsidian.md/) 等软件。其功能包括且不限于：","length":158,"created_at":"2022-04-03T21:03:03.000Z","updated_at":"2022-04-03T17:47:52.000Z","tags":["Blog","VSCode","Hexo","JavaScript"],"license":false,"headingTrees":[{"key":"关于-vscode-memo","href":"#关于-vscode-memo","heading":1,"title":"关于 vscode-memo","children":[],"id":"关于-vscode-memo"},{"key":"image-paste-与-hexo-的配置","href":"#image-paste-与-hexo-的配置","heading":1,"title":"Image Paste 与 Hexo 的配置","children":[],"id":"image-paste-与-hexo-的配置"},{"key":"image-paste-粘贴为-vscode-memo-短链接格式","href":"#image-paste-粘贴为-vscode-memo-短链接格式","heading":1,"title":"Image Paste 粘贴为 vscode-memo 短链接格式","children":[],"id":"image-paste-粘贴为-vscode-memo-短链接格式"},{"key":"让-hexo-正确渲染-vscode-memo-的短链接","href":"#让-hexo-正确渲染-vscode-memo-的短链接","heading":1,"title":"让 Hexo 正确渲染 vscode-memo 的短链接","children":[],"id":"让-hexo-正确渲染-vscode-memo-的短链接"},{"key":"测试一下","href":"#测试一下","heading":1,"title":"测试一下","children":[],"id":"测试一下"},{"key":"不足之处","href":"#不足之处","heading":1,"title":"不足之处","children":[],"id":"不足之处"},{"key":"补充","href":"#补充","heading":1,"title":"补充","children":[],"id":"补充"}],"wikiRefAliases":[],"richRefAliases":["这部分内容会被转换为图片.png"]}},{"pathMapping":{"filePath":"public/content/articles/2022-03-26-create-blog-cicd-by-github.md","pagePath":"/articles/create-blog-cicd-by-github","slug":"create-blog-cicd-by-github"},"meta":{"content":"\nGitHub Action 自动化构建发布到 GitHub Pages 大家都见得多了，甚至 Hexo 官方自己都有相关的文档。\n但我今天要做的不是发布到 GitHub 这么简单，而是要同时发布到 GitHub 和自己的域名下。\n\n# 这篇文章的目标\n\n我们需要构建一个 CI/CD 过程。这个过程需要做到以下目标：\n1. 将文章 push 到 GitHub 的 master branch 后，自动触发。\n2. 我们博客使用 Hexo 引擎，需要先构建静态文件。\n3. 需要将静态文件部署到 GitHub Page 。\n4. 需要将静态文件部署到自己域名下。\n    这里我们使用 AWS 的 S3 服务与 CloudFront 服务直接部署到 CDN 上。 CloudFront 直接通过 OAI 访问 S3 ，不允许用户直接通过 S3 访问。\n5. 博客在 GitHub Page 与 S3 需要处于不同的路径下。\n    为了延续以往的情况，博客在 GitHub Page 需要部署在 `/blog/` 下。\n    而在 AWS 上我则希望直接部署在根目录下，这就导致需要两份配置文件。\n    当然弄两份配置文件我是不乐意的，于是就需要从模板自动生成配置文件...\n\n其中，一二三点都很好解决，而第四点会是一个比较难又比较坑爹的地方。\n\n# 先做简单的 —— CI/CD 构建并发布到 GitHub Pages\n\n这一步其实没什么难的， Hexo 官网上就有[这篇文章](https://hexo.io/docs/github-pages.html)写的十分详细了，可以作为参考。\n\n```yaml\nname: Pages\n\non:\n  push:\n    branches:\n      - master  # default branch\n\njobs:\n  pages:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js 16.x\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Cache NPM dependencies\n        uses: actions/cache@v2\n        with:\n          path: node_modules\n          key: ${{ runner.OS }}-npm-cache\n          restore-keys: |\n            ${{ runner.OS }}-npm-cache\n      - name: Install Dependencies\n        run: npm install\n      - name: Build\n        run: npm run build\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n          publish_branch: gh-pages  # deploying branch\n```\n\n这个 yaml 就是 GitHub Action 的 workflow 文件，在这个 workflow 里：\n1. 先用 `npm run build` 把静态文件生成到 `./public` 下\n2. 用 `peaceiris/actions-gh-pages@v3` 这个 action 把 `./public` 的文件放到 `gh-pages` 分支下。\n\n把上面这个 yaml 文件复制到 `.github/workflows/build.yml` 中，这样 master 分支上发生任何提交都会触发构建流程了。按照 Hexo 官网上的文档跑一边就能成功发布到 GitHub Pages 上了。\n\n不过我需要部署到 `/blog/` 下，这叫 Project Page ，因此我走的是 Hexo 文档的 Project Page 这一小节的流程，需要把 `_config.yml` 里做如下设置：\n\n```yaml\nurl: https://ryojerryyu.github.io/blog # 这个其实不是很重要，现在用的主题没有用到这个字段\nroot: /blog/ # 这个比较重要，这个不设定好，整个页面的超链接都会歪掉\n```\n\n当然， “没什么难” 的前提是你首先要对 Hexo 和 GitHub Action 有一个了解...\n\n# 难一点 —— 搭建 AWS 基础设施\n\n我为什么不止用 GitHub Pages 还要配一套 AWS 呢？其实主要还是想以后可能会做一下 Backend ，而且放 AWS 上还能利用 AWS 的服务做一下流量分析之类的。没这么些需求的小伙伴可以不用继续看了...\n\n我们打算使用 AWS 的 S3 与 CloudFront 服务， CloudFront 直接通过 OAI 访问 S3 。\n\n## S3\n\nS3 是 AWS 的对象储存服务，简单来说就是可以当网盘用，往里面放文件。\nS3 有静态网站托管服务，把静态文件放到 S3 里，配置一番就直接可以通过 HTTP 访问了，还能用自己的域名。\n但我们不打算使用 S3 的静态网站托管，因为我打算直接上 CDN ，又不想用户可以直接通过 S3 来访问我们的静态文件。\n\n## CloudFront\n\nCloudFront 是 AWS 的内容分发服务，简单来说就是 CDN 。其实它不只有 CDN 的功能，它还能加速动态调用，还能通过 CloudFront 连接 Web Socket ... 不过我们这次主要是用 CDN 功能。\nCloudFront 访问 S3 的方式还是有好几种的。中文教程最常见的是让你先打开 S3 静态网站托管，然后将 CloudFront 的源设为 S3 的域名。\n这个方法是最早支持的，因此推广的也比较开。但其实我觉得这个方法有些问题：\n\n1. S3 不做另外配置的话是可以直接访问的，比较 low\n2. S3 自己的 HTTP Endpoint 不能上 TLS ，所以 CloudFront 到 S3 这一段是裸奔的\n\n因此我打算使用 AWS 最近推荐的 OAI 方式访问 S3 。这种方式不走 HTTP Endpoint 而是 S3 自己的 S3 Endpoint ，可以通过 AWS 的 IAM 机制统一管理。\nOAI 是 Origin Access Identity ，简单来说就是给 CloudFront 一个 AWS IAM Policy 的 Principal 身份， S3 可以通过如下 Bucket Policy 限制外部只能通过这个 Principal 访问：\n```json\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": \"arn:aws:iam::cloudfront:user/\u003cCloudFront Origin Access Identity ID\u003e\"\n            },\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::\u003cbucket name\u003e/*\"\n        }\n    ]\n}\n```\n上面这一段看不懂的同学，可以去补习一下 AWS IAM 权限管理机制，关键就是 Principal —— 主体 、 Action —— 动词 、 Resource —— 受体 的一个主谓宾模式。\n\n## 其他 AWS 服务\n\n当然，仅有 S3 和 CloudFront 是不足以实现全部功能的，我们还需要 Route53 来管理路由， ACM 来获取免费证书。\n但这些我都不打算细讲，因为内容真的很多-_-，而且大部分都是 AWS 的细节，搬到别的云上不一定适用...而且手动操作麻烦死了...\n\n## Pulumi\n\n综上嘛，我们需要：\n1. 建一个 Route53 Hosted Zone ，把域名交给 Route53 管理\n2. 用 ACM 给域名申请一个 us-east-1 Region 的免费证书（CloudFront 的证书必须在 us-east-1 ）\n3. 建一个 S3 储存桶，把 Public Access Block 配置一下\n4. 建一个 CloudFront Distribution ，通过 OAI 来访问 S3 ，还要指定一下证书\n5. 给 S3 配一个 Bucket Policy ，允许 CloudFront 访问\n6. 把 Route53 里的域名弄个 DNS 记录指向 CloudFront\n\n手动操作麻烦死了，于是我打算用 IaC (Infrastructure-as-Code) 来解决。我把这些基础设施定义用 Pulumi 写成的代码放在[这里](https://github.com/RyoJerryYu/aws-blog-infra/tree/c97f0fe41b5c0306d5343ddfc22f4a3775d79b88/website)了，大家可以参考一下（做了模块化，跟我其他基础设施放一起了）。\n\n当然，用 Pulumi 没什么特别原因，纯粹是因为我最近在写 Pulumi... 你完全可以用其他 IaC 工具（Ansible、Terraform、CloudFormation）来做。而且 Pulumi 太新了，用起来挺多 Bug 的...（也许是我不会用）\n\n## 测试一下\n\nS3 桶啥的都建好之后，本地把文件 build 一下，用 `aws s3 cp ./public/ s3://\u003cbucket\u003e/ --recursive` 之类的命令上传到 S3 ，给 CloudFront 创建一个 Invalidation 刷新一下 CloudFront 缓存，访问域名看看，有返回个 HTML 我们的基础设施就算是跑通了。此时可能会出现以下情况，都属正常：\n1. 访问返回 307 ：\n    是 S3 储存桶 Region 不在 us-east-1 导致的。\n    CloudFront 是通过 s3 的 global endpoint 访问 s3 的，但不在 us-east-1 的 s3 刚新建时还不能通过 global endpoint 访问。\n    参考 so 的[这个问题](https://stackoverflow.com/questions/38706424/aws-cloudfront-returns-http-307-when-origin-is-s3-bucket)：\n\n    \u003e All buckets have at least two REST endpoint hostnames. In eu-west-1, they are example-bucket.s3-eu-west-1.amazonaws.com and example-bucket.s3.amazonaws.com. The first one will be immedately valid when the bucket is created. The second one -- sometimes referred to as the \"global endpoint\" -- which is the one CloudFront uses -- will not, unless the bucket is in us-east-1. Over a period of seconds to minutes, variable by location and other factors, it becomes globally accesible as well. Before that, the 307 redirect is returned. Hence, the bucket was not ready.\n    \n    这时候只要等个十几分钟就好了。\n2. 本地 build 的时候没配置好的话，js 之类的静态文件可能返回不了，但问题不大，我们接下来再处理。\n\n\n# 搭建 S3 的 workflow\n\n基础设施搭好了，我们就要像 deploy 到 GitHub Pages 一样，造一个自动管线发布到 S3 了。\n整理一下，我们的 workflow 里要包括：\n\n1. 从模板生成配置文件\n    别忘了，我需要的是静态文件部署在 GitHub Pages 和自己域名下的不同路径上。 Hexo 生成静态文件前配置文件必须要改的。\n2. 把原先 s3 上的文件删除，并上传新的文件到 s3\n3. 给 CloudFront 创建一个 Invalidation 刷新缓存\n\n## 生成配置文件\n\n这一步其实方案很多，甚至 bash 直接全文替换都可以...\n不过怕以后要改的东西变多，这里还是选择一些模板生成工具。有如下选择：\n\n1. 屠龙刀 Ansible\n2. Python Jinja2\n3. Go Template\n\n这里用 Ansible 确实是大材小用了，而且 Ansible 不能在 Windows 下用还是有点不方便，只能弃选。而 Python 和 Go 里我选了 Go Template ，原因是... 不想写 Python...\n这里其实确实是装逼了，这种小型脚本应该 Python 比 Go 合适的多。不过还好 Go run 可以不先 go mod 就能运行，不算是个太差的选择。不过以后还是大概率要改回 Python 。\n\n写 golang 脚本没有难度，大致如下：\n\ngolang template 的 name 要是 file name\n```golang\nname := path.Base(*tmpl)\nt := template.Must(template.New(name).ParseFiles(*tmpl))\nerr = t.Execute(os.Stdout, config)\nif err != nil {\n    log.Fatal(err)\n}\n```\ngithub workflow 如下\n```yaml            \n- name: Use Go 1.16\n    uses: actions/setup-go@v1\n    with:\n    go-version: '1.16.1'\n\n- name: generate config\n    run: go run ./genconfig/main.go --env=gh-pages \u003e _config.yml\n\n```\nwindows 玩家可能要注意一下，windows 下编码有问题， `go run ./genconfig/main.go --env=gh-pages \u003e _config.yml` 这段命令直接在 PowerShell 下跑生成出来的文件不能被 Hexo 识别。不过没什么关系，反正这段到时候是在 GitHub Action Runner 上跑的，只不过是不能本地生成用来测试而已。\n\n[参考代码](https://raw.githubusercontent.com/RyoJerryYu/blog/2f407cb6ee723d0e17c97af1289bd2231bb265ab/genconfig/main.go)\n\n## 上传 s3 与刷新 CloudFront\n\n后两步搜一下发现其实有很多现成的 GitHub Action 可以用。\n不过我没有采用，原因是——真的没必要啊...就几个命令的事，又不是不会敲...\n\nworkflows yaml 如下：\n```yaml\n- name: Configure AWS\n    uses: aws-actions/configure-aws-credentials@v1\n    with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: ap-northeast-1\n- name: Deploy\n    env:\n        S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}\n        DISTRIBUTION_ID: ${{ secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID }}\n    run: |\n        aws s3 rm s3://$S3_BUCKET/* --recursive\n        aws s3 cp ./public s3://$S3_BUCKET/ --recursive\n        aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths '/*' --region=us-east-1\n```\n\n[完整 yaml 参考代码](https://raw.githubusercontent.com/RyoJerryYu/blog/f0affb812f2de437943d9cf2a4f8a5fe690d1efd/.github/workflows/clouds.yml)\n\n由于改为了生成配置文件， deploy 到 Github Pages 的 yaml 也要做相应改动，这里就不多说。\n\n# CloudFront 的一点小问题（不太小）\n\n这样我们的整个流程是不是跑完了？我们的博客已经部署到自己的域名下了？\n浏览器打开自己的域名看看，完美显示！\n\n等等，别高兴的太早，点进去一篇文章... 403 了...\n\n403 的原因：\n1. hexo 生成出来的 page 连接是 `/` 结尾的，如 `/2022/03/26/create-blog-cicd-by-github/` ，然后通过 HTTP 服务器的自动转义指向 `/2022/03/26/create-blog-cicd-by-github/index.html` 文件。\n2. CloudFront 可以定义默认根对象，没有为每个子路径都自动转义的功能。\n3. S3 的 HTTP endpoint 可以配置索引文档，为每个子路径自动转义，但 CloudFront 通过 OAI 访问 S3 时通过 REST endpoint 访问，不会触发自动转义。\n\n一大波参考阅读：\n\n[Specifying a default root object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html)\n\u003e Here's an example of how a default root object works. Suppose the following request points to the object image.jpg:\n\u003e ```\n\u003e https://d111111abcdef8.cloudfront.net/image.jpg\n\u003e ```\n\u003e In contrast, the following request points to the root URL of the same distribution instead of to a specific object, as in the first example:\n\u003e ```\n\u003e https://d111111abcdef8.cloudfront.net/\n\u003e ```\n\u003e When you define a default root object, an end-user request that calls the root of your distribution returns the default root object. For example, if you designate the file index.html as your default root object, a request for:\n\u003e ```\n\u003e https://d111111abcdef8.cloudfront.net/\n\u003e ```\n\u003e Returns:\n\u003e ```\n\u003e https://d111111abcdef8.cloudfront.net/index.html\n\u003e ```\n\u003e However, if you define a default root object, an end-user request for a subdirectory of your distribution does not return the default root object. For example, suppose index.html is your default root object and that CloudFront receives an end-user request for the install directory under your CloudFront distribution:\n\u003e ```\n\u003e https://d111111abcdef8.cloudfront.net/install/\n\u003e ```\n\u003e CloudFront does not return the default root object even if a copy of index.html appears in the install directory.\n\u003e \n\u003e If you configure your distribution to allow all of the HTTP methods that CloudFront supports, the default root object applies to all methods. For example, if your default root object is index.php and you write your application to submit a POST request to the root of your domain (http://example.com), CloudFront sends the request to http://example.com/index.php.\n\u003e \n\u003e The behavior of CloudFront default root objects is different from the behavior of Amazon S3 index documents. When you configure an Amazon S3 bucket as a website and specify the index document, Amazon S3 returns the index document even if a user requests a subdirectory in the bucket. (A copy of the index document must appear in every subdirectory.) For more information about configuring Amazon S3 buckets as websites and about index documents, see the Hosting Websites on Amazon S3 chapter in the Amazon Simple Storage Service User Guide.\n\n[Configuring an index document](https://docs.aws.amazon.com/AmazonS3/latest/userguide/IndexDocumentSupport.html)\n\u003e In Amazon S3, a bucket is a flat container of objects. It does not provide any hierarchical organization as the file system on your computer does. However, you can create a logical hierarchy by using object key names that imply a folder structure.\n\u003e \n\u003e For example, consider a bucket with three objects that have the following key names. Although these are stored with no physical hierarchical organization, you can infer the following logical folder structure from the key names:\n\u003e - sample1.jpg — Object is at the root of the bucket.\n\u003e - photos/2006/Jan/sample2.jpg — Object is in the photos/2006/Jan subfolder.\n\u003e - photos/2006/Feb/sample3.jpg — Object is in the photos/2006/Feb subfolder.\n\u003e \n\u003e In the Amazon S3 console, you can also create a folder in a bucket. For example, you can create a folder named photos. You can upload objects to the bucket or to the photos folder within the bucket. If you add the object sample.jpg to the bucket, the key name is sample.jpg. If you upload the object to the photos folder, the object key name is photos/sample.jpg.\n\u003e \n\u003e If you create a folder structure in your bucket, you must have an index document at each level. In each folder, the index document must have the same name, for example, index.html. When a user specifies a URL that resembles a folder lookup, the presence or absence of a trailing slash determines the behavior of the website. For example, the following URL, with a trailing slash, returns the photos/index.html index document.\n\u003e ```\n\u003e http://bucket-name.s3-website.Region.amazonaws.com/photos/\n\u003e ```\n\u003e \n\u003e However, if you exclude the trailing slash from the preceding URL, Amazon S3 first looks for an object photos in the bucket. If the photos object is not found, it searches for an index document, photos/index.html. If that document is found, Amazon S3 returns a 302 Found message and points to the photos/ key. For subsequent requests to photos/, Amazon S3 returns photos/index.html. If the index document is not found, Amazon S3 returns an error.\n\n[Implementing Default Directory Indexes in Amazon S3-backed Amazon CloudFront Origins Using Lambda@Edge](https://aws.amazon.com/blogs/compute/implementing-default-directory-indexes-in-amazon-s3-backed-amazon-cloudfront-origins-using-lambdaedge/)\n\u003e If you implement CloudFront in front of S3, you can achieve this by using an OAI. However, in order to do this, you cannot use the HTTP endpoint that is exposed by S3’s static website hosting feature. Instead, CloudFront must use the S3 REST endpoint to fetch content from your origin so that the request can be authenticated using the OAI. This presents some challenges in that the REST endpoint does not support redirection to a default index page.\n\n\u003e CloudFront does allow you to specify a default root object (index.html), but it only works on the root of the website (such as http://www.example.com \u003e http://www.example.com/index.html). It does not work on any subdirectory (such as http://www.example.com/about/). If you were to attempt to request this URL through CloudFront, CloudFront would do a S3 GetObject API call against a key that does not exist.\n\n\n\n那么，我们要怎么解决这个问题呢？我觉得，这个问题有三种解决方法：\n\n1. 不使用 OAI ，让 CloudFront 直接指向 S3 的域名，让 CloudFront 使用 S3 HTTP Endpoint 的特性\n2. 调整 Hexo 配置，更改生成文件路径或连接路径\n3. 使用 AWS 推荐的 Lambda@Edge 功能，在 CloudFront 上修改路径\n\n其中第二种方案是最下策，我们不能在还有其他方案的情况下，因为基础设施的一个性质就去修改我们的产品。况且我们的产品在大多数场景下都是适用的。\n第一种方案是中策，也许实行起来也是最简单的。但我不想用，原因上面也说过了。\n第三种方案是实施起来难度最大的，我们要引入 Lambda 这一新概念。但反正折腾嘛，试试就试试，反正失败了再变回第一种方案就是。\n\n## 创建 Lambda\n\n[Implementing Default Directory Indexes in Amazon S3-backed Amazon CloudFront Origins Using Lambda@Edge](https://aws.amazon.com/blogs/compute/implementing-default-directory-indexes-in-amazon-s3-backed-amazon-cloudfront-origins-using-lambdaedge/)\n\n参考上面的文档，我们直接在 Console 创建一个 Lambda 函数，内容如下：\n\n```javascript\n'use strict';\nexports.handler = (event, context, callback) =\u003e {\n    \n    // Extract the request from the CloudFront event that is sent to Lambda@Edge \n    var request = event.Records[0].cf.request;\n\n    // Extract the URI from the request\n    var olduri = request.uri;\n\n    // Match any '/' that occurs at the end of a URI. Replace it with a default index\n    var newuri = olduri.replace(/\\/$/, '\\/index.html');\n    \n    // Log the URI as received by CloudFront and the new URI to be used to fetch from origin\n    console.log(\"Old URI: \" + olduri);\n    console.log(\"New URI: \" + newuri);\n    \n    // Replace the received URI with the URI that includes the index page\n    request.uri = newuri;\n    \n    // Return to CloudFront\n    return callback(null, request);\n\n};\n```\n这一段代码主要作用是把接收到每个以 `/` 结尾的请求，都转换为以 `/index.html` 结尾的请求。\n\nDeploy 之后，为 Lambda 添加 Trigger ，选择 CloudFront 作为 Trigger ， Event 选择 On Request 。按照界面的提示为 Lambda 创建专用的 Role 。\n提交后，我们就可以通过 Url 访问，发现 `/` 结尾的 URL 也会正常显示了。\n\n# 之后的事\n\n这个过程仍有以下问题：\n- 对 Lambda 的认识仍有不足，今后需继续学习运用\n- Lambda@Edge 还没有结合到 IaC 中\n- 配置文件生成过程仍有改进空间\n\n留下这些问题，今后再修改。\n","title":"用 GitHub Action 自动化构建 Hexo 并发布到 S3","abstract":"GitHub Action 自动化构建发布到 GitHub Pages 大家都见得多了，甚至 Hexo 官方自己都有相关的文档。\n但我今天要做的不是发布到 GitHub 这么简单，而是要同时发布到 GitHub 和自己的域名下。\n我们需要构建一个 CI/CD 过程。这个过程需要做到以下目标：","length":342,"created_at":"2022-03-26T23:55:08.000Z","updated_at":"2022-03-27T13:31:04.000Z","tags":["Blog","GitHub","AWS","CI/CD","IaC","DevOps"],"license":false,"headingTrees":[{"key":"这篇文章的目标","href":"#这篇文章的目标","heading":1,"title":"这篇文章的目标","children":[],"id":"这篇文章的目标"},{"key":"先做简单的--cicd-构建并发布到-github-pages","href":"#先做简单的--cicd-构建并发布到-github-pages","heading":1,"title":"先做简单的 —— CI/CD 构建并发布到 GitHub Pages","children":[],"id":"先做简单的--cicd-构建并发布到-github-pages"},{"key":"难一点--搭建-aws-基础设施","href":"#难一点--搭建-aws-基础设施","heading":1,"title":"难一点 —— 搭建 AWS 基础设施","children":[{"key":"s3","href":"#s3","heading":2,"title":"S3","children":[],"id":"s3"},{"key":"cloudfront","href":"#cloudfront","heading":2,"title":"CloudFront","children":[],"id":"cloudfront"},{"key":"其他-aws-服务","href":"#其他-aws-服务","heading":2,"title":"其他 AWS 服务","children":[],"id":"其他-aws-服务"},{"key":"pulumi","href":"#pulumi","heading":2,"title":"Pulumi","children":[],"id":"pulumi"},{"key":"测试一下","href":"#测试一下","heading":2,"title":"测试一下","children":[],"id":"测试一下"}],"id":"难一点--搭建-aws-基础设施"},{"key":"搭建-s3-的-workflow","href":"#搭建-s3-的-workflow","heading":1,"title":"搭建 S3 的 workflow","children":[{"key":"生成配置文件","href":"#生成配置文件","heading":2,"title":"生成配置文件","children":[],"id":"生成配置文件"},{"key":"上传-s3-与刷新-cloudfront","href":"#上传-s3-与刷新-cloudfront","heading":2,"title":"上传 s3 与刷新 CloudFront","children":[],"id":"上传-s3-与刷新-cloudfront"}],"id":"搭建-s3-的-workflow"},{"key":"cloudfront-的一点小问题不太小","href":"#cloudfront-的一点小问题不太小","heading":1,"title":"CloudFront 的一点小问题（不太小）","children":[{"key":"创建-lambda","href":"#创建-lambda","heading":2,"title":"创建 Lambda","children":[],"id":"创建-lambda"}],"id":"cloudfront-的一点小问题不太小"},{"key":"之后的事","href":"#之后的事","heading":1,"title":"之后的事","children":[],"id":"之后的事"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2021-12-12-init-a-new-hexo-project.md","pagePath":"/articles/init-a-new-hexo-project","slug":"init-a-new-hexo-project"},"meta":{"content":"\n## 使用 hexo 搭建博客\n\n最近使用 hexo 搭建了一个博客，并打算挂载在 github page 上。\n对之前的那个博客进行替代，并将之前的文章逐渐搬移过来。\n\n使用的[这个主题](https://github.com/Yue-plus/hexo-theme-arknights)功能还是比较完善的。\n\n我们可以尝试一下代码块高亮：\n\n```python\ndef func_echo(s: str):\n    print(s)\n\n\nclass HelloPrinter:\n    printer: Callable[[str]]\n\n    def __init__(self, printer: Callable[[str]]):\n        self.printer = printer\n    \n    def call(self, s: str):\n        self.printer(s)\n\n\np = HelloPrinter(func_echo)\np.call(\"hello world!\")\n```\n\n试试下标语法吧：\n\n这是一句话。[^sub]\n\n没想到还支持下标语法，还是比较惊艳的。\n\n来几句 mermaid 吧\n\n```mermaid\ngraph LR\n\nohmy--\u003ecoll\n\n```\n\n原本是不能渲染的， 这个主题渲染代码块时把 mermaid 代码当作普通代码，往里面里插换行符号了。\n使用了 hexo-filter-mermaid-diagrams 插件，添加 mermaid 过滤器，解决问题。\n\n\n来几句 LaTeX:\n\n$$\n\\begin{aligned}\nf(x) \u0026= \\sum_{i=2}^{\\infty}{\\Join} \\\\\n\u0026= \\sum_{i=2}^{\\infty}{\\frac{1}{i}}\n\\end{aligned}\n$$\n\n原本是不能渲染的，因为与 hexo 的渲染器有冲突，需要转义。\n我因为需要从以前的博客把文章转移过来觉得比较麻烦...\n于是魔改了一下主题，用上 mathjax 插件，能渲染了，感觉挺不错的。\n再改善一下推个 PR 吧。\n\n\n\n\n[^sub]: 这是脚注","title":"init-a-new-hexo-project","abstract":"最近使用 hexo 搭建了一个博客，并打算挂载在 github page 上。\n对之前的那个博客进行替代，并将之前的文章逐渐搬移过来。\n使用的[这个主题](https://github.com/Yue-plus/hexo-theme-arknights)功能还是比较完善的。","length":66,"created_at":"2021-12-12T20:09:13.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["Blog"],"license":false,"headingTrees":[{"key":"使用-hexo-搭建博客","href":"#使用-hexo-搭建博客","heading":2,"title":"使用 hexo 搭建博客","children":[],"id":"使用-hexo-搭建博客"},{"key":"footnote-label","href":"#footnote-label","heading":2,"title":"Footnotes","children":[],"id":"footnote-label"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2021-03-21-Handy-heap-cheat-sheet.md","pagePath":"/articles/Handy-heap-cheat-sheet","slug":"Handy-heap-cheat-sheet"},"meta":{"content":"\n# 如何手撕一个堆\n\n# 写在前面\n\n在参加如AtCoder等算法竞技，或是刷Leetcode等算法题时，我们总是不可避免地遇到堆这种数据结构。\n\n当然，一般来说我们只要理解堆，知道堆的性质，知道怎么样用堆就足够了。在做题时只需要调用系统类库即可——在参加AtCoder时你甚至不会有时间去自己实现一个堆。\n\n但是，如果哪一天你把编程语言的类库全忘光了，又遇到一题需要频繁求最值的题目——你明知这里要用堆，却又忘记该调用的类名了，咋办？我还真遇到过这问题：三年没刷算法，只能对着一道自己明显会的题干着急，愣是想不起PriorityQueue的名字。这时候，只能自己实现一个堆出来了。\n\n# 首先要理解，然后才能实现\n\n就像人总不会忘记自行车怎么骑一样，只要理解了数据结构的原理，身体就会自动来帮我们记忆，总不会忘。那要怎么理解一个堆呢？\n\n## 先抓住重点：堆是一种树结构\n\n首先最重要的，要理解堆是一种树结构。不管实际是基于数组实现还是别的什么实现，逻辑结构是树结构没变的。\n\n再进一步，在堆这种树结构中，最重要的约束就是：**对于树中的每个节点，总有父节点大于两个子节点**（以大顶堆为例，下同）。\n\n如此一来，大小关系在树中层层传递，最终可得树的根节点（堆顶）就是整个堆的最大节点，读取堆中最大值的时间复杂度为O(1)。而我们使用堆也一般是为了利用这种堆顶元素就是最大值的特点，读取、删除操作一般会限制为只允许读取、删除堆顶元素。\n\n而且我们可以注意到，与二叉查找树比起来，堆的约束十分之弱：堆只约束父节点与子节点的大小关系，而不需要管左右子树的大小关系，甚至不需要管左右两个子节点之间谁大谁小。这样一来堆就有很多很好的性质了：\n\n1. 堆并不关注左右子树之间的大小情况，那么**要维护一个堆，基本只需要做交换父节点与子节点的操作**，而不需要像二叉查找树那样做各种旋转操作。\n2. 因为维护一个堆不需要做旋转操作，那么几乎不需要花任何代价，就可以把堆的树结构维持在完全二叉树状态。因此堆的物理结构可以设计得很紧凑，**可以使用数组进行实现**。\n3. 因为堆可以维持在完全二叉树状态，那么堆的树结构的高度就可以控制为O(logn)范围内。而如上所述，要维护一个堆我们不需要关注左右子树的关系。因此我们要在堆上做增删操作，都只需要上下交换若干次父子节点。而交换次数最多时，也只是从树根一直交换到树叶，或是从树叶一直交换到树根，最多交换logn次。那么我们可得：**堆的增删操作最坏时间复杂度为O(logn)**。\n\n## 再抓基本操作：上浮与下沉\n\n上面也提到，要维护一个堆，我们只需要上下交换若干次父子节点即可。若一个节点**过大**，就跟他的父节点**向上交换**；若一个节点**过小**，就跟他的子节点**向下交换**。\n\n假设p节点过大破坏了堆结构，即p节点比其父节点g还要大，向上交换如下图：\n\n![p与g交换](/img/in-post/2021-03-21-Handly-heap-cheat-sheet/change.png)\n\n由于除了p过大破坏堆结构以外，其他节点都符合堆结构，则有：\n\n1. p \u003e g \u003e p2\n2. g \u003e 原p \u003e c1与c2\n\n则向上交换后有只有一种破坏堆结构的可能性：p节点过大，比gg节点还要大。而解决方法也很简单，就是递归地进行向上交换，最坏情况下一直交换到堆根节点为止。\n\n同理可得，p节点过小，小于他的子节点时，向下交换后有可能需要递归地向下交换，最坏情况下一直交换到叶子节点为止。要注意向下交换时需要先比较一下两个子节点的大小，再跟较大的子节点交换，才能交换后的大小关系符合堆的要求。\n\n为了简化，我们把前面那种递归地向上交换称为**上浮操作**，把后面这种递归地向下交换称为**下沉操作**。所有需要维护堆结构的操作：增、删、建堆，都可以拆分为上浮操作或是下沉操作的组合。\n\n# 各种接口的逻辑\n\n## 插入元素——入堆\n\n把一个元素p加入堆中，我们可以先把p加到堆尾，然后对p做上浮操作。\n\n虽然堆是一个树结构，但由于堆可以用数组实现，那我们只要用O(1)的时间就可以找到堆尾。而如上面所述上浮操作最多交换到根节点 。由于用数组实现的堆是完全二叉树，交换到根节点时间复杂度为O(logn)。因此我们可得入堆的最坏时间复杂度为O(logn)。\n\n## 删除堆顶元素——出堆\n\n我们从堆中删除元素时，一般只会删除堆顶元素。\n\n删除堆顶元素时，我们可以摘出堆尾元素p填到堆顶的空缺中，再对p做下沉操作。找到堆尾元素需要O(1)时间，下沉操作最多交换到叶子节点，时间复杂度为O(logn)。因此出堆最坏时间复杂度为O(logn)。\n\n这里加点餐：出堆时把堆尾元素p放到堆顶后下沉，而p原先在堆中的最下层，一般在整个堆中都算较小的元素。因此下沉p时有较大概率需要一直把p下沉到最下层或是倒数第二层，即出堆时最坏情况出现概率较高。\n\n## 堆的初始化——建堆\n\n建立一个堆，我们有两种思路：\n\n1. 将元素一个一个插入，即对每个元素都做一次入堆操作。\n2. 当节点p左子树和右子树都各自为一个堆时，只要把p下沉就可以把左右两个堆合并成一个更大的堆。即不断地进行堆合并操作。\n\n下面我们来分析这两种建堆策略。\n\n### 元素逐个入堆\n\n上面说到，入堆就是把元素加到堆尾，再做上浮操作。把元素逐个入堆，就是把元素逐个上浮。\n\n插入第i个元素时，堆的大小为$i$（在不影响计算情况下的近似，下同），则有堆的高度为，则上浮时间复杂度为：\n\n$$T(i) = logi$$\n\n那么把所有元素上浮，则总时间复杂度为：\n\n$$\n\\begin{aligned}\nT(n) \u0026= \\sum_{i=1}^{n}logi\\\\\n\u0026= 1\\times0 + 2\\times1 + ... + 2^{logn}\\times{logn} \\\\\n\u0026=O(nlogn)\n\\end{aligned}\n$$\n\n通过把元素逐个入堆来建堆时，元素的时间复杂度可以用下图直观显示：\n\n![](/img/in-post/2021-03-21-Handly-heap-cheat-sheet/insert-length.png)\n\n（每条红线的长度就是插入该元素所需的时间，红线的总长度就是建堆所需的总时间复杂度）\n\n### 堆合并\n\n我们就可以从树结构的最底层出发不断进行堆合并，小堆合并成大堆，最后合并到根节点就建成整个堆结构。\n\n当节点的左右两个子树都是堆时，只需要对该节点进行下沉操作就可以合并左右两个堆。 不断进行堆合并，就是从下层开始把元素逐个下沉。\n\n下沉第i个元素（从顶到底数）时，以其为顶点的树高度约为$logn-logi$，则有下沉时间复杂度为：\n\n$$\nT(i) = logn-logi\n$$\n\n那么把所有元素下沉，则总时间复杂度为：\n\n$$\n\\begin{aligned}\nT(n) \u0026= \\sum_{i=1}^{n}logn-logi \\\\\n\u0026= \\frac{n}{2^{logn}}\\times{logn}+ ... + \\frac{n}{4}\\times2+\\frac{n}{2}\\times1 \\\\\n\u0026= O(n)\n\\end{aligned}\n$$\n\n同样的，我们也可以把逐个元素下沉所耗费的时间用下图来示意：\n\n![](/img/in-post/2021-03-21-Handly-heap-cheat-sheet/merge-length.png)\n\n### 两种策略的比较与理解\n\n逐个元素入堆的策略时间复杂度为$O(logn)$，堆合并策略的时间复杂度为$O(n)$，为什么会出现差异呢？我们可以从两个角度来理解：\n\n1. 从元素移动路径的角度\n\n    我们从前一小节的两幅图中可发现，元素入堆策略的图中根节点附近红线十分密集。而堆合并策略的红线则整体来说比较稀疏。\n\n    这说明元素入堆策略中，在根节点附近元素做了较多重复无效的移动——也就是说插入一个元素时上浮到了根节点附近，然后又被其他后来的元素顶替下来。一上一下自然消耗了多余的时间，而这种消耗在元素入堆策略中出现频率高，无可忽视。\n\n2. 从元素移动数量与移动距离的角度\n\n    我们知道一般来说树的越下层节点数量越多。特别是用数组实现的堆是个完全二叉树，最下层节点数量占了总数的一半。 因此**建堆的时间复杂度主要取决于底层元素**的移动距离。\n\n    用元素入堆策略需要每个元素进行上浮操作，而偏偏元素数量最多的底层移动距离最长，$O(n)$个元素需要移动$O(logn)$的距离，因此时间复杂度较高。\n\n    而堆合并策略则反过来，需要每个元素进行下沉操作。移动距离最长的只有一个根元素，底层元素几乎不需要移动，因此时间复杂度加起来只有$O(n)$。\n\n    如图所示，颜色越深代表移动距离越长。颜色深度对面积的积分即为建堆时间复杂度。\n\n    ![](/img/in-post/2021-03-21-Handly-heap-cheat-sheet/move-length.png)\n\n综上分析我们可以得出，通过堆合并策略建堆较优，时间复杂度只需$O(n)$。因此我们建堆一般采用堆合并策略，从下往上逐个元素下沉。\n\n# 代码实现\n\n其实理解了上面这些，要写一个堆出来也已经是水到渠成了。但正如Linus所说，Talk is cheap, show me the code。我们还是要亲手写一段，才能知道堆到底长啥样。\n\n```python\nT = TypeVar(\"T\")\nclass Heap(Generic[T]):\n    '''堆结构\n\n    有两个成员：\n    self.A: List[T] # 堆内元素集合，元素类型为T，储存为数组\n    self.fCompare: Callable[[T,T],bool] # 比较函数\n    \n    下面假设堆为大顶堆\n    即有self.fCompare = lambda a,b: a\u003eb\n    '''\n```\n\n## 实现树结构\n\n堆可以实现为基于数组的完全二叉树，以下标为零的节点为树根节点。\n\n对于下标为i的节点，其左子节点、右子节点、父节点的下标分别如下所示：\n\n```python\ndef lfChildOf(i:int):\n    return (i + 1) \u003c\u003c 1 - 1\n\ndef rtChildOf(i:int):\n    return (i + 1) \u003c\u003c 1\n\ndef parentOf(i:int):\n    return (i - 1) \u003e\u003e 1\n```\n\n至于为什么是这样，是因为完全二叉树与数组的对应规则如下图所示。这三个函数也没必要记住，到时候纸上画一画就记起来了。\n\n![](/img/in-post/2021-03-21-Handly-heap-cheat-sheet/tree-struct-function.png)\n\n## 实现基本操作——上浮与下沉\n\n### 上浮\n\n上浮就是递归地进行向上交换，下沉就是递归地进行向下交换。\n\n```python\ndef floatUp(self, i:int):\n    '''上浮操作\n\n    对下标为i的元素递归地进行上浮操作\n    直到该元素小于其父节点或该元素上浮到根节点\n    '''\n    # 元素i上浮到根节点时结束递归\n    if i \u003c= 0:\n        return\n    \n    # 当元素i小于其父节点时符合堆结构，结束递归\n    pr = parentOf(i)\n    if self.fCompare(self.A[pr], self.A[i]):\n        return\n    \n    # 元素i大于其父节点，交换i与其父节点并继续上浮\n    self.A[pr], self.A[i] = self.A[i], self.A[pr]\n    self.floatUp(pr)\n```\n\n### 下沉\n\n而下沉要稍微比上浮复杂。向下交换时，需要先找出较大的子节点，再跟较大的子节点进行交互。还要考虑左右子节点不存在的情况：当子节点下标超出堆大小时，子节点不存在。\n\n```python\ndef size(self):\n    '''返回堆大小\n    '''\n    return len(self.A)\n\ndef sinkDown(self, i:int):\n    '''下沉操作\n\n    对下标为i的元素递归地进行下沉操作\n    直到该元素大于其两个子节点或该元素下沉到叶子节点\n    '''\n    lc = lfChildOf(i)\n    rc = rtChildOf(i)\n\n    # 比较元素i与其两个子节点，获取三个元素中存在且最大的元素\n    larger = i\n    if lc \u003c self.size() and self.fCompare(self.A[lc], self.A[larger]):\n        larger = lc\n    if rc \u003c self.size() and self.fCompare(self.A[rc], self.A[larger]):\n        larger = rc\n    \n    # 当元素i大于其两个子节点时符合堆结构，结束递归\n    # 当元素i下沉到叶子节点时，左右子节点不存在，也会在此结束递归\n    if larger == i:\n        return\n    \n    # 元素i小于其中一个子节点，交换i与较大子节点并继续下沉\n    self.A[larger], self.A[i] = self.A[i], self.A[larger]\n    self.sinkDown(larger)\n```\n\n注意这里上浮和下沉操作使用了递归，会占用递归栈空间，因此额外空间复杂度并不是$O(1)$。\n\n但上浮和下沉都可以改为循环迭代实现，迭代实现时额外空间复杂度为$O(1)$。要改成迭代实现并不困难，还请大家尝试自己实现。\n\n## 实现各种借口——读、增、删、初始化\n\n### 读取堆顶\n\n堆一般只允许读取堆顶，即全堆最大元素。\n\n```python\ndef top(self):\n    '''返回堆顶\n    '''\n    return self.A[0]\n```\n\n### 入堆\n\n入堆时，把元素加到堆尾，再做上浮操作。\n\n```python\ndef insert(self, v:T):\n    '''入堆\n    '''\n    # 将元素加到堆尾并做上浮操作\n    self.A.append(v)\n    self.floatUp(len(self.A) - 1)\n```\n\n### 出堆\n\n出堆时，取出堆顶，把堆尾元素填到堆顶后，再做下沉操作。\n\n```python\ndef pop(self)-\u003eT:\n    '''出堆\n    '''\n    # 取出堆顶元素\n    res = self.A[0]\n\n    # 将堆尾元素填到堆顶并做下沉操作\n    self.A[0] = self.A[len(self.A) - 1]\n    self.A.pop()\n    self.sinkDown(0)\n\n    return res\n```\n\n注意入堆与出堆操作都要保证堆的大小会相应变化。\n\n### 堆初始化\n\n堆的初始化采用堆合并策略，从堆尾到堆顶逐个元素做下沉操作。\n\n```python\ndef __init__(self, A:List[T]=[], \n             fCompare:Callable[[T,T],bool]=lambda a,b:a\u003eb\n             ) -\u003e None:\n    '''堆初始化\n\n    :param A: 在数组A上进行初始化\n    :param fCompare: 比较函数，对堆中节点p与子节点c，有fCompare(p,c)==True\n    '''\n    self.A = A\n    self.fCompare = fCompare\n    for i in reversed(range(len(A))):\n        self.sinkDown(i)\n```\n\n## 整体代码\n\n### 堆的整体实现\n\n综上，堆的整体代码实现如下：\n\n```python\nfrom typing import Any, Callable, Generic, List, TypeVar\n\nT = TypeVar(\"T\")\n\ndef lfChildOf(i:int):\n    return (i + 1) \u003c\u003c 1 - 1\n\ndef rtChildOf(i:int):\n    return (i + 1) \u003c\u003c 1\n\ndef parentOf(i:int):\n    return (i - 1) \u003e\u003e 1\n\nclass Heap(Generic[T]):\n    '''堆结构\n\n    有两个成员：\n    self.A: List[T] # 堆内元素集合，元素类型为T，储存为数组\n    self.fCompare: Callable[[T,T],bool] # 比较函数\n    \n    下面假设堆为大顶堆\n    即有self.fCompare = lambda a,b: a\u003eb\n    '''\n    def __init__(self, A:List[T]=[], \n                 fCompare:Callable[[T,T],bool]=lambda a,b:a\u003eb\n                 ) -\u003e None:\n        '''堆初始化\n\n        :param A: 在数组A上进行初始化\n        :param fCompare: 比较函数，对堆中节点p与子节点c，有fCompare(p,c)==True\n        '''\n        self.A = A\n        self.fCompare = fCompare\n        for i in reversed(range(len(A))):\n            self.sinkDown(i)\n    \n    def size(self):\n        '''返回堆大小\n        '''\n        return len(self.A)\n    \n    def top(self):\n        '''返回堆顶\n        '''\n        return self.A[0]\n    \n    def sinkDown(self, i:int):\n        '''下沉操作\n\n        对下标为i的元素递归地进行下沉操作\n        直到该元素大于其两个子节点或该元素下沉到叶子节点\n        '''\n        lc = lfChildOf(i)\n        rc = rtChildOf(i)\n\n        # 比较元素i与其两个子节点，获取三个元素中存在且最大的元素\n        larger = i\n        if lc \u003c self.size() and self.fCompare(self.A[lc], self.A[larger]):\n            larger = lc\n        if rc \u003c self.size() and self.fCompare(self.A[rc], self.A[larger]):\n            larger = rc\n        \n        # 当元素i大于其两个子节点时符合堆结构，结束递归\n        # 当元素i下沉到叶子节点时，左右子节点不存在，也会在此结束递归\n        if larger == i:\n            return\n        \n        # 元素i小于其中一个子节点，交换i与较大子节点并继续下沉\n        self.A[larger], self.A[i] = self.A[i], self.A[larger]\n        self.sinkDown(larger)\n\n    def floatUp(self, i:int):\n        '''上浮操作\n\n        对下标为i的元素递归地进行上浮操作\n        直到该元素小于其父节点或该元素上浮到根节点\n        '''\n        # 元素i上浮到根节点时结束递归\n        if i \u003c= 0:\n            return\n        \n        # 当元素i小于其父节点时符合堆结构，结束递归\n        pr = parentOf(i)\n        if self.fCompare(self.A[pr], self.A[i]):\n            return\n        \n        # 元素i大于其父节点，交换i与其父节点并继续上浮\n        self.A[pr], self.A[i] = self.A[i], self.A[pr]\n        self.floatUp(pr)\n    \n    def insert(self, v:T):\n        '''入堆\n        '''\n        # 将元素加到堆尾并做上浮操作\n        self.A.append(v)\n        self.floatUp(len(self.A) - 1)\n\n    def pop(self)-\u003eT:\n        '''出堆\n        '''\n        # 取出堆顶元素\n        res = self.A[0]\n\n        # 将堆尾元素填到堆顶并做下沉操作\n        self.A[0] = self.A[len(self.A) - 1]\n        self.A.pop()\n        self.sinkDown(0)\n\n        return res\n```\n\n### 单元测试\n\n入堆、出堆等操作的简单单元测试如下：\n\n```python\nimport pytest\nimport heap\n\n@pytest.fixture\ndef initHeap():\n    return heap.Heap([1,3,4,7,2,6,5,9,0,8], \n                     lambda a,b:a\u003eb)\n\nclass Test_TestHeap:\n    def test_init_notNull(self, initHeap:heap.Heap):\n        assert initHeap.size() == 10\n        assert initHeap.top() == 9\n    \n    def test_insert_notTop(self, initHeap:heap.Heap):\n        initHeap.insert(6)\n        assert initHeap.size() == 11\n        assert initHeap.top() == 9\n    \n    def test_insert_top(self, initHeap:heap.Heap):\n        initHeap.insert(10)\n        assert initHeap.size() == 11\n        assert initHeap.top() == 10\n    \n    def test_pop(self, initHeap:heap.Heap):\n        p = initHeap.pop()\n        assert p == 9\n        assert initHeap.size() == 9\n        assert initHeap.top() == 8\n```\n\n# 关于堆排序\n\n算法竞赛中除了原生使用堆结构以外，还有一个使用到堆的地方——堆排序。堆排序有原地排序、最坏时间复杂度为$O(nlogn)$等优秀的性质，是比较常用的一个排序算法。\n\n然而，手写堆排序要注意的地方与手写堆结构有比较大的不同。堆排序时要注意的点如下：\n\n1. 堆排序时一般要求在给入数组上原地排序，不需要内部维护一个数组结构，反之，需要记录堆结构的大小。\n2. 堆结构一般占用数组前端，因此从小到大排序时，有序部分从数组末尾开始扩张，建立的堆为大顶堆。\n3. 堆排序只需要建堆与出堆操作，因此只需要实现下沉操作。\n\n关于堆排序的具体讨论，有机会的话我会另外写一篇来讲解。","title":"如何手撕一个堆","abstract":"在参加如AtCoder等算法竞技，或是刷Leetcode等算法题时，我们总是不可避免地遇到堆这种数据结构。\n当然，一般来说我们只要理解堆，知道堆的性质，知道怎么样用堆就足够了。在做题时只需要调用系统类库即可——在参加AtCoder时你甚至不会有时间去自己实现一个堆。\n但是，如果哪一天你把编程语言的类库全忘光了，又遇到一题需要频繁求最值的题目——你明知这里要用堆，却又忘记该调用的类名了，咋办？我还真遇到过这问题：三年没刷算法，只能对着一道自己明显会的题干着急，愣是想不起PriorityQueue的名字。这时候，只能自己实现一个堆出来了。","length":483,"created_at":"2021-08-28T23:09:14.000Z","updated_at":"2025-09-29T15:43:23.000Z","tags":["数据结构","算法","算法竞赛"],"license":false,"headingTrees":[{"key":"如何手撕一个堆","href":"#如何手撕一个堆","heading":1,"title":"如何手撕一个堆","children":[],"id":"如何手撕一个堆"},{"key":"写在前面","href":"#写在前面","heading":1,"title":"写在前面","children":[],"id":"写在前面"},{"key":"首先要理解然后才能实现","href":"#首先要理解然后才能实现","heading":1,"title":"首先要理解，然后才能实现","children":[{"key":"先抓住重点堆是一种树结构","href":"#先抓住重点堆是一种树结构","heading":2,"title":"先抓住重点：堆是一种树结构","children":[],"id":"先抓住重点堆是一种树结构"},{"key":"再抓基本操作上浮与下沉","href":"#再抓基本操作上浮与下沉","heading":2,"title":"再抓基本操作：上浮与下沉","children":[],"id":"再抓基本操作上浮与下沉"}],"id":"首先要理解然后才能实现"},{"key":"各种接口的逻辑","href":"#各种接口的逻辑","heading":1,"title":"各种接口的逻辑","children":[{"key":"插入元素入堆","href":"#插入元素入堆","heading":2,"title":"插入元素——入堆","children":[],"id":"插入元素入堆"},{"key":"删除堆顶元素出堆","href":"#删除堆顶元素出堆","heading":2,"title":"删除堆顶元素——出堆","children":[],"id":"删除堆顶元素出堆"},{"key":"堆的初始化建堆","href":"#堆的初始化建堆","heading":2,"title":"堆的初始化——建堆","children":[{"key":"元素逐个入堆","href":"#元素逐个入堆","heading":3,"title":"元素逐个入堆","children":[],"id":"元素逐个入堆"},{"key":"堆合并","href":"#堆合并","heading":3,"title":"堆合并","children":[],"id":"堆合并"},{"key":"两种策略的比较与理解","href":"#两种策略的比较与理解","heading":3,"title":"两种策略的比较与理解","children":[],"id":"两种策略的比较与理解"}],"id":"堆的初始化建堆"}],"id":"各种接口的逻辑"},{"key":"代码实现","href":"#代码实现","heading":1,"title":"代码实现","children":[{"key":"实现树结构","href":"#实现树结构","heading":2,"title":"实现树结构","children":[],"id":"实现树结构"},{"key":"实现基本操作上浮与下沉","href":"#实现基本操作上浮与下沉","heading":2,"title":"实现基本操作——上浮与下沉","children":[{"key":"上浮","href":"#上浮","heading":3,"title":"上浮","children":[],"id":"上浮"},{"key":"下沉","href":"#下沉","heading":3,"title":"下沉","children":[],"id":"下沉"}],"id":"实现基本操作上浮与下沉"},{"key":"实现各种借口读增删初始化","href":"#实现各种借口读增删初始化","heading":2,"title":"实现各种借口——读、增、删、初始化","children":[{"key":"读取堆顶","href":"#读取堆顶","heading":3,"title":"读取堆顶","children":[],"id":"读取堆顶"},{"key":"入堆","href":"#入堆","heading":3,"title":"入堆","children":[],"id":"入堆"},{"key":"出堆","href":"#出堆","heading":3,"title":"出堆","children":[],"id":"出堆"},{"key":"堆初始化","href":"#堆初始化","heading":3,"title":"堆初始化","children":[],"id":"堆初始化"}],"id":"实现各种借口读增删初始化"},{"key":"整体代码","href":"#整体代码","heading":2,"title":"整体代码","children":[{"key":"堆的整体实现","href":"#堆的整体实现","heading":3,"title":"堆的整体实现","children":[],"id":"堆的整体实现"},{"key":"单元测试","href":"#单元测试","heading":3,"title":"单元测试","children":[],"id":"单元测试"}],"id":"整体代码"}],"id":"代码实现"},{"key":"关于堆排序","href":"#关于堆排序","heading":1,"title":"关于堆排序","children":[],"id":"关于堆排序"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2021-08-21-The-beauty-of-design-parten.md","pagePath":"/articles/The-beauty-of-design-parten","slug":"The-beauty-of-design-parten"},"meta":{"content":"\n# 导读\n\n## 02：如何评价代码好坏？\n\n从7个方面评价代码的好坏：\n\n1. 易维护性：根本\n2. 可读性：最重要\n3. 易扩展性：对修改关闭，对扩展开放\n4. 灵活性\n5. 简洁性：KISS\n6. 可复用性：DRY\n7. 可测试性：TDD，单元测试，控制反转与依赖注入\n\n## 03：编程方法论\n\n设计模式之美这一课程不单止讲设计模式，而会讲包括设计模式在内的指导我们进行代码设计的方法论。包括以下5个方面：\n\n1. 面向对象：封装，抽象，继承，多态\n2. 设计原则：SOLID（单一职责，开闭原则，里氏替换，接口隔离，依赖倒置），DRY，KISS，YAGNI，LOD\n3. 设计模式\n4. 编程规范：可读性，命名规范\n5. 重构技巧：（目的，对象，时机，方法），保证手段（单元测试与可测性），两种规模\n\n整个课程会以编程方法论为纵轴，以代码好坏的评价为横轴，来讲提高代码质量的方法以及采用这种方法的原因。\n\n\n# 面向对象\n\n使用封装，抽象，继承，多态，作为代码设计和实现的基石。\n\n1. 面向对象分析（做什么），设计（怎么做），编程\n\n## 05：封装，抽象，继承，多态\n\n|      | 是什么                 | 怎么做                 | 为什么                                                         |\n| ---- | ---------------------- | ---------------------- | -------------------------------------------------------------- |\n| 封装 | 信息隐藏、数据访问保护 | 访问控制关键字         | 减少不可控因素、统一修改方式、保证可读性与可维护性、提高易用性 |\n| 抽象 | 隐藏实现方法           | 函数、接口类、抽象类   | 提高可扩展性与维护性、过滤非必要信息                           |\n| 继承 | is-a关系               | 继承机制               | 代码复用、反映真实世界关系                                     |\n| 多态 | 子类替代父类           | 继承、接口类、鸭子类型 | 提高扩展性与复用性                                             |\n\n- 继承不应过度使用，会导致层次过深，导致低可读性与低可维护性\n- 在我看来，多态的本质与其说是子类替代父类，更应说是用同一个过程方法能适应多种不同类型的对象。\n- 有些观点认为，多态除了表中这三种实现方式以外，还有泛型的实现方式，被称为连接时多态。\n\n## 06，07：面向过程与面向对象\n\n1. 面向过程是：数据与方法分离\n2. 面向对象优势：适应大规模开发，代码组织更清晰；易复用、易扩展、易维护；人性化；\n3. 看似面向对象实际面向过程：滥用getter、setter破坏封装；滥用全局变量与全局方法，Constants类与Utils类；数据与方法分离，贫血模型；\n4. 为什么容易面向过程：略\n5. 面向过程的用处：略\n\n## 08：接口与抽象类\n\n1. 接口类与抽象类语法特性：略\n2. 抽象类表示is-a，为了解决代码复用。接口表示能做什么，为了解耦，隔离接口与实现。\n3. 应用场景区别：\n    - 抽象类：代表is-a关系，解决代码复用问题\n    - 接口类：解决抽象、解耦问题","title":"设计模式之美读书笔记","abstract":"从7个方面评价代码的好坏：\n1. 易维护性：根本\n2. 可读性：最重要","length":62,"created_at":"2021-08-21T08:53:27.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["设计模式","笔记"],"license":false,"headingTrees":[{"key":"导读","href":"#导读","heading":1,"title":"导读","children":[{"key":"02如何评价代码好坏","href":"#02如何评价代码好坏","heading":2,"title":"02：如何评价代码好坏？","children":[],"id":"02如何评价代码好坏"},{"key":"03编程方法论","href":"#03编程方法论","heading":2,"title":"03：编程方法论","children":[],"id":"03编程方法论"}],"id":"导读"},{"key":"面向对象","href":"#面向对象","heading":1,"title":"面向对象","children":[{"key":"05封装抽象继承多态","href":"#05封装抽象继承多态","heading":2,"title":"05：封装，抽象，继承，多态","children":[],"id":"05封装抽象继承多态"},{"key":"0607面向过程与面向对象","href":"#0607面向过程与面向对象","heading":2,"title":"06，07：面向过程与面向对象","children":[],"id":"0607面向过程与面向对象"},{"key":"08接口与抽象类","href":"#08接口与抽象类","heading":2,"title":"08：接口与抽象类","children":[],"id":"08接口与抽象类"}],"id":"面向对象"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2021-01-11-Sort-algorithm.md","pagePath":"/articles/Sort-algorithm","slug":"Sort-algorithm"},"meta":{"content":"\n# 序言\n\n我们知道排序是算法入门基本功，排序算法有多重要想必也不需要我在这里说明了。因此这一篇就按着我的理解，聊一聊排序算法。\n\n当然我不打算随便弄个什么十大排序算法或是经典排序总结之类响当当的名头，各个算法走马看花一样拉出来遛一遍，最后变得跟网上搜索到的其他讲排序的文章一样换汤不换药。你会发现这篇文章的结构跟在网上搜索到的任何讲排序的文章都有所不同：\n\n在这篇文章里，你会发现你找不到冒泡排序——因为我认为冒泡排序只不过是一种低效率的选择排序。\n\n你会发现堆排序被当成是选择排序的一种优化——因为我认为堆排序主要在于使用了堆这种数据结构，而总体思想与选择排序相比没有太大变化。\n\n你还会找到其他与别的文章不一样的地方。因为这篇文章是我按照自己的理解来写的，我脑子里是这样想的，那文章里就是这样写的。我会按照我的理解，从纵向与横向两个维度，来理清楚各个排序算法的特性与异同。\n\n# 整篇文章的要点\n\n整篇文章以纵向——算法分类、以及横向——算法评价两个维度来进行组织。\n\n排序算法可以按照以下方式来进行分类：\n\n- 基于比较的排序算法\n    - 基于分治思想\n        - 快速排序\n        - 归并排序\n    - 基于有序区域扩展\n        - 插入排序\n        - 选择排序\n- 不基于比较的排序算法\n    - 计数排序\n    - 桶排序\n    - 基数排序\n\n文章中还会讲一讲为什么会这么分，每种分类有什么共性，分类之间有什么差异。此外，在最后还会稍微提一提外部排序与适用于并行运算的排序等。\n\n而对于纵向分类中的每一个端点，我们又会从以下五个方面，来对各个算法进行一个总体评价：\n\n- 时间复杂度（最坏，最好，平均※）\n- 空间复杂度\n- 是否原地排序\n- 是否稳定排序\n- 能否用于链表排序\n\n而由于复杂度主要只关注数量级，因此在这篇文章里会在不影响计算结果的前提下对复杂度计算进行适当的近似与简化。\n\n# 快排\n\n## 思想\n\n分治法：先把序列分为小的部分和大的部分，再将两部分分别排序。即：复杂分割，简单合并，主要操作在于分割。\n\n## 要点\n\n### 时间复杂度\n\n推导式：T(n) = T(找) + T(左) + T(右) = O(n) + 两个子问题时间复杂度。\n\n- 最好时间复杂度为每次都正好找到最中间的一个数时时间复杂度为O（nlogn）。证明略。\n- 最坏时间复杂度为每次都正好找到最旁边的数时时间复杂度为O(n^2)。证明略。\n- 平均时间复杂度为O（nlogn），推导式如下：\n\n    快速排序每一步中，将元素分为左右两边需要遍历整个列表，耗时T(n)。假设最后定位的元素为最终第i个元素，则两个子问题复杂度分别为T(i)和T(n-i-1)。\n\n    则有：\n\n    $$\n    \\begin{aligned}\n    T(n) \u0026= n + \\frac{\\sum_{i=0}^{n-1}{T(i)+T(n-i-1)}}{n} \\\\\n    \u0026=n + \\frac{2}{n}\\times\\sum_{i=0}^{n-1}{T(i)} \\\\\n    \\end{aligned}\n    $$\n\n    令 $$\\sum_{i=0}^{n}T(i) = Sum(n)$$ ，即有：\n\n    $$\n    \\begin{aligned}\n    T(n) \u0026= n + \\frac{2}{n} \\times Sum(n-1) \\\\\n    Sum(n) \u0026= \\frac{n+1}{2}T(n+1) - \\frac{n+1}{2}(n+1)\n    \\end{aligned}\n    $$\n\n    错位相减：\n\n    $$\n    \\begin{aligned}\n    Sum(n) - Sum(n-1) \u0026= \\frac{n+1}{2}T(n+1) - \\frac{n+1}{2}(n+1) - \\frac{n}{2}T(n) + \\frac{n}{2}(n) \n    \\\\\n    T(n) \u0026= \\frac{n+1}{2}T(n+1) - \\frac{n}{2}T(n) - \\frac{2n+1}{2} \n    \\\\\n    \\frac{T(n+1)}{n+2} \u0026= \\frac{T(n)}{n+1}+\\frac{2n+1}{(n+1)(n+2)} \n    \\\\\n    \u0026= \\frac{T(n)}{n+1}+\\frac{1}{n}+\\frac{1}{n+1} \n    \\\\\n    \u0026=...\n    \\\\\n    \u0026= \\frac{T(1)}{2}+1+2\\times(\\frac{1}{2}+\\frac{1}{3}+...+\\frac{1}{n})+\\frac{1}{n+1}\n    \\\\\n    \\\\\n    \\frac{T(n)}{n+1}\u0026=\\frac{T(1)}{2}+1+2\\times(\\frac{1}{2}+...+\\frac{1}{n-1})+\\frac{1}{n}\n    \\\\\n    \u0026= O(1)+O(1)+O(logn)+O(\\frac{1}{n})\n    \\\\\n    \u0026= O(logn)\n    \\end{aligned}\n    $$\n\n    其中由于 $$\\frac{1}{x}=\\frac{d(logx)}{dx}$$ ，因此 $$\\frac{1}{2}+...+\\frac{1}{n-1}=O(logn)$$ 。\n\n    则有：\n\n    $$\n    \\begin{aligned}\n    T(n)\u0026=(n+1)\\times O(logn)\\\\\n    \u0026=O(n)\\times O(logn)\\\\\n    \u0026=O(nlogn)\n    \\end{aligned}\n    $$\n\n### 额外空间复杂度\n\n考虑栈深度，额外空间复杂度为O（logn）。由于快速排序主要步骤在于分，因此必须自上而下的进行递归，无法避免栈深度。\n\n### 原地排序\n\n虽然快速排序有额外空间复杂度，但并不妨碍它是一个原地排序。\n\n### 不稳定\n\n堆排序在分操作时将元素左右交换，会破坏稳定性。\n\n### 链表形式特点\n\n- 时间复杂度不变\n- 空间复杂度不变\n- 变为稳定排序※\n\n## 手写时的易错点\n\n- 分成左右子序列时最好完全分开（一边用`\u003c=`一边用`\u003e`），不然容易造成死循环。\n- 分左右子序列时仔细考虑最初下标位置与最终下标位置，以及对应位置的值的大小。\n- 不要忘记递归的结束条件。\n\n# 归并排序\n\n## 思想\n\n分治法：先把两个子序列各自排好序，然后再合并两个子序列。即：简单分割，复杂合并。主要步骤在于合并。\n\n## 要点\n\n- 时间复杂度推导式：T(n) = 2T(n/2) + T(合)\n- 平均、最好、最坏时间复杂度都是O（nlogn），推导过程略。\n- 额外空间复杂度为O（n），合并时必须准备额外空间。但由于主要步骤在于合并，可以自下而上地进行迭代合并，可以不使用栈。\n- 非原地排序\n- 稳定排序\n\n### 链表形式\n\n- 时间复杂度不变\n- 额外空间复杂度变为O(1)※\n- 稳定排序\n- 只能使用迭代形式，不能使用递归形式\n\n## 易错点\n\n- 合并时一边结束时另一边还未结束，需要把那一边也放入合并后序列中\n- 保持稳定排序：合并时左序列等于右序列时也采用左序列\n- 不要忘记递归结束条件\n- 不要忘记循环递进条件\n\n## 进阶\n\n- 原地归并排序：时间复杂度为O（log^2n），牺牲合并的时间复杂度进行原地排序。\n- 多路归并排序：使用竞标树，多路归并，用于磁盘IO。\n\n# 插入排序\n\n## 思想\n\n有序序列不断扩张，每次从无序序列中取出元素加入有序序列，直至长度为N则完成排序。\n\n每次将无序序列当前元素插入有序序列，复杂度取决于有序序列。\n\n## 要点\n\n- 最坏、平均时间复杂度：O（n2）\n- 最好时间复杂度：基本有序情况下，O（n）\n- 额外空间复杂度：O（1）\n- 原地排序\n- 稳定排序\n- 每次插入时都要移动序列，写次数较多\n- 若查找插入位置时使用二分法查找，则可加快时间。（但不足以对时间复杂度造成影响，且最好时间复杂度也会上升为O(nlogn)）\n\n### 链表形式\n\n- 最好，最坏，平均时间复杂度不变\n- 额外空间复杂度不变\n- 稳定排序\n- 插入时不再需要移动序列，但也不能使用二分法查找\n\n## 进阶——希尔排序\n\n- 要点：\n\n    插入排序的优点在于当序列基本有序时，时间复杂度可逼近为O(n)。\n\n    但插入时移动有序序列中元素所耗时间较多，而每次只移动一步。但实际上当序列分布均匀时，有序序列中排靠后的元素在整个序列中也会排靠后。\n\n    可以把序列分为几个大步长序列，在最初的几次插入放开移动步长，让大的元素直接移动到较后位置。再往后慢慢缩小步长，此时序列基本有序，可以利用基本有序时插入排序的优势。\n\n- 时间复杂度\n    1. 当步长为2^i时，不能使时间复杂度缩短为O(nlogn)。因为一个子序列所有元素有可能比另一个子序列最大元素都要大，这时插入排序仍需进行约n^2次操作\n    2. 当步长为2^i时效率较低，因为当步长为4已经有序时，步长为2再比较是无用比较。但由于1.的问题，不能节省比较时间。\n    3. 当步长之间最小公约数较少，甚至互质时，无用比较次数会降低。\n    4. 最坏时间复杂度下限为 $$O(nlog^2n)$$ （当步长采用 $$2^i3^j$$ 时），但一般希尔排序平均时间复杂度都为 $$O(n^{\\frac{3}{2}})$$\n- 额外空间复杂度O(1)\n- 原地排序\n- 不稳定排序：希尔排序步长较大时会发生前后跳转。\n- 不能写为链表形式\n\n# 选择排序\n\n## 思想\n\n有序序列不断扩张，每次从无序序列中取出元素加入有序序列，直至长度为N则完成排序。\n\n每次将选无序序列中最小元素加到有序序列末尾，复杂度取决于无序序列。\n\n## 要点\n\n- 最坏、平均时间复杂度：O（n2）\n- 最好时间复杂度：O（n2），如能保证无序部分的最小元素所在位置一定（堆排序），能降低时间复杂度\n- 额外空间复杂度：O（1）\n- 原地排序\n- 不稳定排序（采用元素交换策略时）\n- 每次找到最小元素后，只需交换一次位置即可，写次数较少。\n- 若找到最小元素后，不直接交换而是进行数组移动，则可进行稳定排序，但写次数变多，与插入排序相比没有优势，也不能使用二分查找进行简化。\n\n### 链表形式\n\n- 最好，最坏，平均时间复杂度不变\n- 额外空间复杂度不变\n- 变为稳定排序※（因为链表不需要数组移动，稳定排序方式的缺点得以消除）\n\n## 进阶——堆排序\n\n- 要点：\n\n    选择排序中耗时最多的是取出无序序列中最小值的时间，需要遍历整个无序序列。\n\n    但实际上我们只关心无序序列中的最小值，而不关心其他值的位置。通过将无序序列建为堆，减少选择时间，降低总的时间复杂度。\n\n- 时间复杂度O（nlogn）\n- 额外空间复杂度O（1）\n- 原地排序\n- 不稳定排序\n- 操作时间复杂度：每次向下比较关注一个节点与其左右子堆顶元素，每次向上比较只关注节点与其父元素（大顶堆，堆大小为n）\n    - 下沉：向下比较，若顶元素不是最大，将顶元素与较大的子堆堆顶元素交换。递归处理该子堆顶元素，直到向下比较顶元素最大。\n\n        最好时间复杂度O（1），最坏时间复杂度为O（h）=O（logn），平均O（logn）\n\n    - 上浮：向上比较，若元素比其上层要大，交换该元素与其上层元素。递归处理其上层元素，直到向上比较不比上层要大。\n\n        最好时间复杂度O（1），最坏时间复杂度O（h）=O（logn），平均O（logn）\n\n    - 入堆：堆扩容一位，将新元素插到尾部，将该元素上浮，最坏、平均时间复杂度O（logn）\n    - 出堆：取出堆顶元素，将尾部放到堆顶，将该元素下沉，最坏、平均时间复杂度O（logn）\n    - 缺点：通常堆尾元素较小，出堆时将堆尾元素放到堆顶再下沉基本要沉到堆底，无用比较较多\n- 建堆时间复杂度O（n）\n    - 策略1：从头开始建堆，逐个元素插入，时间复杂度取决于最后一层，时间复杂度为O（nlogn）\n        - 每次将堆扩容一位，将末尾元素上浮。\n        - 时间复杂度推导：\n\n            每次插入时间：\n\n            $$\n            \\begin{aligned} T(i) \u0026= h\\\\\n            \u0026= logi\n            \\end{aligned}\n            $$\n\n            则有总时间：\n\n            $$\n            \\begin{aligned}\n            T(n) \u0026= \\sum_{i=0}^{n}logi\\\\\n            \u0026= 1\\times1 + 2\\times2+ 3\\times4 + ...+h\\times \\frac{n}{2} \\\\\n            \\\\\n            2T(n) \u0026= 1\\times2 + 2\\times4+ 3\\times8 + ...+h\\times n \\\\\n            \\\\\n            2T(n)-T(n) \u0026= h\\times n - (1+2+4+...+2^{h-1}) \\\\\n            \u0026= h\\times n - O(2^h) \\\\\n            \\\\\n            T(n) \u0026= nlogn - O(2^h) \\\\\n            \u0026= O(nlogn)\n            \\end{aligned}\n            $$\n\n            即时间复杂度为 $$O(nlogn)$$\n\n    - 策略2：从后开始建堆，小堆合并（逐个元素下沉），时间复杂度为O（n）\n        - 每次堆合并时，有三部分：左子堆，右子堆，顶元素。下沉顶元素。\n        - 时间复杂度推导：\n\n            第i个元素合并时，时间为：\n\n            $$\n            \\begin{aligned}\n            T(i) \u0026= h_{子堆}\n            \\end{aligned}\n            $$\n\n            则有总时间：\n\n            $$\n            \\begin{aligned}\n            T(n) \u0026= \\sum_{i=0}^{n} (h_{子堆}) \\\\\n            \u0026= h + (h-1)\\times2 + ... + 2 \\times \\frac{n}{4} + 1 \\times\\frac{n}{2}\\\\\n            \\\\\n            2T(n) \u0026= h \\times 2 + (h-1) \\times 4 + ... + 2 \\times \\frac{n}{2} + n \\\\\n            \\\\\n            2T(n) - T(n) \u0026= n + \\frac{n}{2} + ... + 2 - h \\\\\n            \\\\\n            T(n) \u0026= O(n) - h \\\\ \n            \u0026= O(n)\n            \\end{aligned}\n            $$\n\n            即时间复杂度为 $$O(n)$$ \n\n        - 虽说每步是做一个小堆合并，但实际上从堆尾到堆头遍历，相当于仅关注元素没有稳定，相当于可以直接使用下沉操作。\n\n# 基于比较的排序算法时间复杂度下限：逆序对思想\n\n基于比较的排序算法可以看作序列逆序对的消除。完全随机序列逆序对数量为O(n^2)，若一次元操作只消除一个逆序对，则时间复杂度不会低于O(n^2)。降低时间复杂度关键在于一次消除多个逆序对。\n\n1. 希尔排序通过增大最初的步长来企图一次消除多个逆序对。\n2. 归并排序消除逆序对最主要在于归并步骤。最后几次合并每个子步骤用O(1)时间消除O(n)个逆序对。\n3. 快速排序消除逆序对最主要在于划分步骤。每个划分步骤用O(n)时间消除O(n)+O(左长度×右长度)个逆序对。\n4. 堆排序逆序对消除方式比较Tricky，但可以看出消除逆序对大致在于出堆步骤，通过O(logn)时间复杂度消除O(n)个逆序对。（左小右大排序时需要建立左大右小的大顶堆，建堆时基本没有消除逆序对）\n\n# 最后\n\n这篇文章我们主要关注了排序算法中的大头——基于比较的排序算法。在下篇文章，我们再来看一下不基于比较的排序算法，以及外排序与并行排序。","title":"排序算法","abstract":"我们知道排序是算法入门基本功，排序算法有多重要想必也不需要我在这里说明了。因此这一篇就按着我的理解，聊一聊排序算法。\n当然我不打算随便弄个什么十大排序算法或是经典排序总结之类响当当的名头，各个算法走马看花一样拉出来遛一遍，最后变得跟网上搜索到的其他讲排序的文章一样换汤不换药。你会发现这篇文章的结构跟在网上搜索到的任何讲排序的文章都有所不同：\n在这篇文章里，你会发现你找不到冒泡排序——因为我认为冒泡排序只不过是一种低效率的选择排序。","length":342,"created_at":"2021-01-11T22:57:10.000Z","updated_at":"2025-09-29T15:16:03.000Z","tags":["数据结构","算法","排序"],"license":false,"headingTrees":[{"key":"序言","href":"#序言","heading":1,"title":"序言","children":[],"id":"序言"},{"key":"整篇文章的要点","href":"#整篇文章的要点","heading":1,"title":"整篇文章的要点","children":[],"id":"整篇文章的要点"},{"key":"快排","href":"#快排","heading":1,"title":"快排","children":[{"key":"思想","href":"#思想","heading":2,"title":"思想","children":[],"id":"思想"},{"key":"要点","href":"#要点","heading":2,"title":"要点","children":[{"key":"时间复杂度","href":"#时间复杂度","heading":3,"title":"时间复杂度","children":[],"id":"时间复杂度"},{"key":"额外空间复杂度","href":"#额外空间复杂度","heading":3,"title":"额外空间复杂度","children":[],"id":"额外空间复杂度"},{"key":"原地排序","href":"#原地排序","heading":3,"title":"原地排序","children":[],"id":"原地排序"},{"key":"不稳定","href":"#不稳定","heading":3,"title":"不稳定","children":[],"id":"不稳定"},{"key":"链表形式特点","href":"#链表形式特点","heading":3,"title":"链表形式特点","children":[],"id":"链表形式特点"}],"id":"要点"},{"key":"手写时的易错点","href":"#手写时的易错点","heading":2,"title":"手写时的易错点","children":[],"id":"手写时的易错点"}],"id":"快排"},{"key":"归并排序","href":"#归并排序","heading":1,"title":"归并排序","children":[{"key":"思想-1","href":"#思想-1","heading":2,"title":"思想","children":[],"id":"思想-1"},{"key":"要点-1","href":"#要点-1","heading":2,"title":"要点","children":[{"key":"链表形式","href":"#链表形式","heading":3,"title":"链表形式","children":[],"id":"链表形式"}],"id":"要点-1"},{"key":"易错点","href":"#易错点","heading":2,"title":"易错点","children":[],"id":"易错点"},{"key":"进阶","href":"#进阶","heading":2,"title":"进阶","children":[],"id":"进阶"}],"id":"归并排序"},{"key":"插入排序","href":"#插入排序","heading":1,"title":"插入排序","children":[{"key":"思想-2","href":"#思想-2","heading":2,"title":"思想","children":[],"id":"思想-2"},{"key":"要点-2","href":"#要点-2","heading":2,"title":"要点","children":[{"key":"链表形式-1","href":"#链表形式-1","heading":3,"title":"链表形式","children":[],"id":"链表形式-1"}],"id":"要点-2"},{"key":"进阶希尔排序","href":"#进阶希尔排序","heading":2,"title":"进阶——希尔排序","children":[],"id":"进阶希尔排序"}],"id":"插入排序"},{"key":"选择排序","href":"#选择排序","heading":1,"title":"选择排序","children":[{"key":"思想-3","href":"#思想-3","heading":2,"title":"思想","children":[],"id":"思想-3"},{"key":"要点-3","href":"#要点-3","heading":2,"title":"要点","children":[{"key":"链表形式-2","href":"#链表形式-2","heading":3,"title":"链表形式","children":[],"id":"链表形式-2"}],"id":"要点-3"},{"key":"进阶堆排序","href":"#进阶堆排序","heading":2,"title":"进阶——堆排序","children":[],"id":"进阶堆排序"}],"id":"选择排序"},{"key":"基于比较的排序算法时间复杂度下限逆序对思想","href":"#基于比较的排序算法时间复杂度下限逆序对思想","heading":1,"title":"基于比较的排序算法时间复杂度下限：逆序对思想","children":[],"id":"基于比较的排序算法时间复杂度下限逆序对思想"},{"key":"最后","href":"#最后","heading":1,"title":"最后","children":[],"id":"最后"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2020-08-02-python-dict.md","pagePath":"/articles/python-dict","slug":"python-dict"},"meta":{"content":"\n\u003e CPython从3.6开始，字典（dict）不再是无序的了——字典的修改了原先的底层实现，变得能按字典插入的顺序进行遍历。而Python从3.7开始将字典的有序性写入语言特性，不管是Jython、IronPython还是其他Python实现，从3.7开始大家的字典都是有序的了。\n\n# 前言\n\n以前参加Python相关的面试时，面试官经常都会问一个问题：Python里的字典（dict）是有序的吗？\n\n这自然难不倒我，我也照本宣科地讲：Python的字典底层是用哈希表实现的，在不发生冲突时读写的时间复杂度是O（1），比读写时间复杂度为O（logn）的红黑树要更快。但红黑树可以按下标的大小顺序进行遍历，而Dict遍历时是无序的。\n\n我讲的时候没感觉到任何的违和感，估计面试官们也没觉得任何的不对。直到有一天，我查Python各个版本的新特性时，发现Python 3.6的What's New里有[这么一条](https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation)：\n\n\u003e New dict implementation\n\u003e \n\u003e The dict type now uses a “compact” representation based on a proposal by Raymond Hettinger which was first implemented by PyPy. The memory usage of the new dict() is between 20% and 25% smaller compared to Python 3.5.\n\u003e \n\u003e The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5).\n\n啥情况？CPython的dict竟然优化了内存，还变有序了！？\n\n# Python 3.5 以前dict的实现\n\n先不着急看Python 3.6 里的dict，我们先来看看Python 3.5之前的dict是怎么实现的，再拿3.6来做对比。\n\n在Python 3.5以前，dict是用Hash表来实现的，而且Key和Value直接储存在Hash表上。想通过Key获取Value，只需通过Python内部的Hash函数计算出Key对应的Hash值，再映射到Hash表上对应的地址，访问该地址即可获取Key对应的Value。如下图所示：\n\n我们知道，Hash表读写时间复杂度在不发生冲突的情况下都是O（1）。\n\n为什么呢？我们可以把Hash表读写的步骤分开来看：\n\n1. 首先用Hash函数计算key的Hash值，Hash函数一般来说时间复杂度都是O（1）的。\n2. 计算出Hash值后，映射到Hash表内的数组下标，一般用取余数或是取二进制后几位的方式实现，时间复杂度也是O（1）。\n3. 然后用数组下标读取数组中实际储存的键值，数组的下标读取时间复杂度也是O（1）。\n\n这三个步骤串起来后复杂度并没有提升，总的时间复杂度自然也是O（1）的。\n\n而内部储存空间，Python字典中称为entries。entries相当于一个数组，是一段连续的内存空间，每个位置储存一个（Hash值，指向Key的指针，指向Value的指针）三元组。\n\n当然，由于抽屉原理，我们知道Hash表不可避免的会出现Hash冲突，Python的dict也不例外。\n\n而解决Hash冲突的方法有很多，比如C++的unordered_map和Go的map就用链地址法来解决冲突，用链表储存发生冲突的值。而Java更进一步，当链表长度超过8时就转换成红黑树，将链表O（n）的查找复杂度降为O（logn）。C#的HashTable则是用再散列法，内部有多个Hash函数，一次冲突了就换一个函数再算，直到不冲突为止。\n\n而Python的dict则是利用开放寻址法。当插入数据发生冲突时，就会从那个位置往后找，直到找到有空位的地址为止。要查的时候，也是把下标值映射到到地址后，先对比一下下标值相不相等，若不相等则往后继续对比。\n\n这也造成个问题，dict中的元素不能直接从entries中清理掉，不然往后寻找的查找链就会断掉了。只能是先标记住删除，等到一定时机再一并清理。\n\n此外我们也知道，当冲突过发生得过多，dict读写所需的时间也会变多，时间复杂度不再是O(1)，这也是Hash表的通病了。\n\nPython中dict初始化时，内部储存空间entries容量为8。当内部储存空间占用到一定程度（entries容量×装填因子，Python的dict中装填因子是2/3）后，就会进行倍增扩容。每次扩容都要遍历原先的元素，时间复杂度为O(n)，但基本上插入O(n)次之后才会进行一次扩容，所以扩容的均摊时间复杂度为O(1)。而扩容时会重新进行Hash值到entries位置的映射，此时就是把标记删除但仍留在entries中的元素清理掉的最佳时机。\n\nPython3.5之前这种dict的实现就有两个毛病：\n\n1. 元素的顺序不被记录。两个Key值通过Hash函数的出来的Hash值不一定能保证原来的大小关系，由于Hash冲突、扩容等影响元素的顺序也会变化。当然这种无序性也是Hash表通用的特点了。\n2. 占用了太多了无用空间。上面说到entries中每个位置储存一个（Hash值，指向Key的指针，指向Value的指针）三元组，没用到或是标记删除的位置占用了大量的空间。\n\n于是，Raymond Hettinger就提出了一种新的dict实现方式。在CPython3.6中就使用了这种新的实现方式。\n\n# CPython3.6中dict的实现\n\n当要实现一个如下的dict时：\n\n```python\nd = {\n    'timmy': 'red', \n    'barry': 'green', \n    'guido': 'blue'\n}\n```\n\n如在上一节中所讲，在Python3.5以前，在内存储存的形式可以表示成这样子：\n\n```python\nentries = [['--', '--', '--'],\n           [-8522787127447073495, 'barry', 'green'],\n           ['--', '--', '--'],\n           ['--', '--', '--'],\n           ['--', '--', '--'],\n           [-9092791511155847987, 'timmy', 'red'],\n           ['--', '--', '--'],\n           [-6480567542315338377, 'guido', 'blue']]\n```\n\n而CPython3.6以后，是以这种形式储存在内存中的：\n\n```python\nindices =  [None, 1, None, None, None, 0, None, 2]\nentries =  [[-9092791511155847987, 'timmy', 'red'],\n            [-8522787127447073495, 'barry', 'green'],\n            [-6480567542315338377, 'guido', 'blue']]\n```\n\n改变了什么？\n\n1. dict内部的entries改为按插入顺序存储，新增了一个indices用于储存元素在entries中的下标。dict整体仍是Hash表结构，但Hash值映射到indices中，而不是直接映射到entries中。\n2. 由于entries改为了按插入顺序存储，使得申请entries容量时只要申请Hash表长度的2/3即可，省去了Hash表中的无用空间，储存更紧凑。\n3. dict读写步骤从原先的3步变为4步：计算key的Hash值，映射到indices内存空间，从indices读取entries的下标值，用下标从entries中读写数据。读写时间复杂度仍保持为O(1)，冲突、删除标记等Hash表的特性也仍然存在。indices的扩容策略也仍然是倍增扩容，但因为填充因子仍然为2/3，entries每次扩容时只需申请indices长度的2/3即可。\n\n有什么好处？\n\n1. 压缩空间：原先Hash映射是直接映射到entries上，会有大量的空隙。现在Hash映射到indices上，而entries中可更紧凑地存储元素。而indices中储存的entries下标占用内存可以比entries元素要小得多——当entries长度足够短时每个下标只需占一个字节。indices中确实也还仍有空隙，但占用空间总要比旧的dict实现要小得多了。\n2. 更快的遍历：以前的实现遍历dict要遍历整个Hash表，需要挨个位置读取一下，判断它是空闲位置还是实际存在的元素。而现在只需要对变得更紧凑的entries遍历就行了。这也带来一个新的特性：entries是按照元素插入的顺序存储的，遍历entries自然也会按元素插入的顺序输出。这就给dict带来了有序性。\n3. 扩容时关注的内存块更少。原先的entries扩容时所有数据都要重新映射到内存上，cache利用率不好。现在扩容时基本可以整个entries直接复制（当然，有删除标记的数据这时要忽略）。\n\n综上，CPython3.6以后通过增加了一个indices增加了空间利用率，在维持读写时间复杂度不变的情况下增加了遍历与扩容效率。至于dict遍历变得有序，倒是有点次要的特性了。\n\n# 我们是否应利用新dict的有序性？\n\n既然Python中dict变得有序了，那我们是否应该主动去利用它呢？我是这么认为的：\n\n1. 在Python3.6中，我们不推荐利用dict的有序性。3.6时dict的有序性还只是CPython的一个实现细节，并不是Python的语言特性。当我们的代码不是在CPython环境下运行，dict的有序性就不起作用，就容易出莫名其妙的BUG了。\n2. 在Python3.7后，dict按插入顺序进行遍历的性质被写入Python语言特性中。这时确实在代码中利用dict有序性也没什么大问题。但dict这种数据结构，最主要的特性还是表现在Key映射到Value的这种关系，以及O(1)的读写时间复杂度。当我们的代码中需要关注到dict的遍历顺序时，我们就要先质问一下自己：是否应该改为用队列或是其他数据结构来实现？\n\n\n# 参考文献\n\n- [Are dictionaries ordered in Python 3.6+?](https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6)\n- [[Python-Dev] Python 3.6 dict becomes compact and gets a private version; and keywords become ordered](https://mail.python.org/pipermail/python-dev/2016-September/146327.html)\n- [[Python-Dev] More compact dictionaries with faster iteration](https://mail.python.org/pipermail/python-dev/2012-December/123028.html)\n- [关于python3.6中dict如何保证有序](https://zhuanlan.zhihu.com/p/36167600)\n- [python3.7源码分析－字典_小屋子大侠的博客-CSDN博客_python 字典源码](https://blog.csdn.net/qq_33339479/article/details/90446988)\n- [《深度剖析CPython解释器》9. 解密Python中字典和集合的底层实现，深度分析哈希表](https://www.cnblogs.com/traditional/p/13503114.html)\n- [CPython 源码阅读 - dict](http://blog.dreamfever.me/2018/03/12/cpython-yuan-ma-yue-du-dict/)","title":"Python字典的实现原理","abstract":"\u003e CPython从3.6开始，字典（dict）不再是无序的了——字典的修改了原先的底层实现，变得能按字典插入的顺序进行遍历。而Python从3.7开始将字典的有序性写入语言特性，不管是Jython、IronPython还是其他Python实现，从3.7开始大家的字典都是有序的了。\n以前参加Python相关的面试时，面试官经常都会问一个问题：Python里的字典（dict）是有序的吗？\n这自然难不倒我，我也照本宣科地讲：Python的字典底层是用哈希表实现的，在不发生冲突时读写的时间复杂度是O（1），比读写时间复杂度为O（logn）的红黑树要更快。但红黑树可以按下标的大小顺序进行遍历，而Dict遍历时是无序的。","length":121,"created_at":"2020-08-02T00:10:10.000Z","updated_at":"2025-09-29T15:16:00.000Z","tags":["Python","数据结构"],"license":false,"headingTrees":[{"key":"前言","href":"#前言","heading":1,"title":"前言","children":[],"id":"前言"},{"key":"python-35-以前dict的实现","href":"#python-35-以前dict的实现","heading":1,"title":"Python 3.5 以前dict的实现","children":[],"id":"python-35-以前dict的实现"},{"key":"cpython36中dict的实现","href":"#cpython36中dict的实现","heading":1,"title":"CPython3.6中dict的实现","children":[],"id":"cpython36中dict的实现"},{"key":"我们是否应利用新dict的有序性","href":"#我们是否应利用新dict的有序性","heading":1,"title":"我们是否应利用新dict的有序性？","children":[],"id":"我们是否应利用新dict的有序性"},{"key":"参考文献","href":"#参考文献","heading":1,"title":"参考文献","children":[],"id":"参考文献"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2020-01-28-the-using-in-cpp.md","pagePath":"/articles/the-using-in-cpp","slug":"the-using-in-cpp"},"meta":{"content":"\n## using的用法\n#### using与命名空间\n\n1. 引入整个命名空间中的成员\n   \n   不引入命名空间时，使用其中变量需要使用`\u003c命名空间名\u003e::\u003c变量名\u003e`的方式使用。\n   ```C++\n   using namespace foo;\n   ```\n   如此会将命名空间foo下所有的成员名称引入，可在直接以 `\u003c变量名\u003e` 的形式使用。但如此做有可能会使得命名空间foo中部分变量与当前定义的变量名冲突，违反命名空间隔离编译时名称冲突的初衷，因此不建议如此使用。\n\n2. 引入命名空间中的部分成员\n   \n   可通过仅引入命名空间中部分的成员，避免命名冲突。\n   ```C++\n   using foo::bar;\n   ```\n   这种方法仅会引入在语句中明确声明的名称。如using一个枚举类时，不会连其定义的枚举常量也一同引入。\n\n#### using与基类成员\n\n1. 子类中引入基类名称\n   \n   ```C++\n    class Base {\n    public:\n        std::size_t size() const { return n; }\n    protected:\n        std::size_t n;\n    };\n\n    class Derived : private Base {\n    public:\n        using Base::size;\n    protected:\n        using Base::n;\n    // ...\n    };\n    ```\n    例中子类private继承基类，由于private继承使得`Base::size`与`Base::n`可视性变为private。而使用`using Base::size`、`using Base::n`后，可分别使其变为public与protected。\n\n2. 子类成员函数与基类同名时保留基类函数用以重载\n   \n   ```C++\n    class Base\n    {\n    public:\n        int Func(){return 0;}\n    };\n    class Derived : Base\n    {\n    public:\n        using Base::Func;\n        int Func(int);\n    };\n    ```\n    子类中定义的成员函数与基类中重名时，即使函数原型不同，子类函数也会覆盖基类函数。\n    \n    如果基类中定义了一个函数的多个重载，而子类中又重写或重定义了其中某些版本，或是定义了一个新的重载，则基类中该函数的所有重载均被隐藏。\n\n    此时可以在子类中使用`using Base::Func`，令基类中所有重载版本在子类中可见，再重定义需要更改的版本。\n\n又如cppreference中的[例子](https://en.cppreference.com/w/cpp/language/using_declaration#In_class_definition)：\n```C++\n#include \u003ciostream\u003e\nstruct B {\n    virtual void f(int) { std::cout \u003c\u003c \"B::f\\n\"; }\n    void g(char)        { std::cout \u003c\u003c \"B::g\\n\"; }\n    void h(int)         { std::cout \u003c\u003c \"B::h\\n\"; }\nprotected:\n    int m; // B::m is protected\n    typedef int value_type;\n};\n\nstruct D : B {\n    using B::m; // D::m is public\n    using B::value_type; // D::value_type is public\n\n    using B::f;\n    void f(int) { std::cout \u003c\u003c \"D::f\\n\"; } // D::f(int) overrides B::f(int)\n    using B::g;\n    void g(int) { std::cout \u003c\u003c \"D::g\\n\"; } // both g(int) and g(char) are visible\n                                        // as members of D\n    using B::h;\n    void h(int) { std::cout \u003c\u003c \"D::h\\n\"; } // D::h(int) hides B::h(int)\n};\n\nint main()\n{\n    D d;\n    B\u0026 b = d;\n\n//    b.m = 2; // error, B::m is protected\n    d.m = 1; // protected B::m is accessible as public D::m\n    b.f(1); // calls derived f()\n    d.f(1); // calls derived f()\n    d.g(1); // calls derived g(int)\n    d.g('a'); // calls base g(char)\n    b.h(1); // calls base h()\n    d.h(1); // calls derived h()\n}\n```\n`using`语句可以改变基类成员的可访问性，也能在子类中重载(Overload)、重写(Override)基类的函数，或是通过重定义隐藏(Hide)对应的基类函数。\n\n\n#### using与别名\n\nusing在C++11开始，可用于别名的声明。用法如下：\n```C++\nusing UPtrMapSS = std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e;//普通别名\nusing FP = void (*) (int, const std::string\u0026);//函数指针别名\n\ntemplate \u003ctypename T\u003e\nusing Vec = MyVector\u003cT, MyAlloc\u003cT\u003e\u003e;//模板别名\nVec\u003cint\u003e vec;//模板别名的使用\n```\n\n## using关键字与typedef关键字定义别名的不同\n\n在STL容器或是其他泛型中若是再接受一个容器类型，类型名称就会写得很长。使用typedef或using定义别名会变得比较方便：\n```C++\ntypedef std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e UPtrMapSS;\n\nusing UPtrMapSS = std::unique_ptr\u003cstd::unordered_map\u003cstd::string, std::string\u003e\u003e;\n```\n\n对于函数指针，使用using语句可以把函数原型与别名强制分到左右两边，比使用typedef易读得多：\n```C++\ntypedef void (*FP) (int, const std::string\u0026);\n\nusing FP = void (*) (int, const std::string\u0026);\n```\n\n---\n\n在C++中，若试图使用typedef定义一个模板：\n```C++\ntemplate \u003ctypename T\u003e\ntypedef MyVector\u003cT, MyAlloc\u003cT\u003e\u003e Vec;\n\n// usage\nVec\u003cint\u003e vec;\n```\n编译就会报错，提示：\n\u003e error: a typedef cannot be a template\n\n在一些STL中，通过如下方式包装一层来使用：\n```C++\ntemplate \u003ctypename T\u003e\nstruct Vec\n{\n  typedef MyVector\u003cT, MyAlloc\u003cT\u003e\u003e type;\n};\n\n// usage\nVec\u003cint\u003e::type vec;\n```\n\n如此显得十分不美观，且要是在模板类中或参数传递时使用typename强制这为类型，而不是其他如静态成员等语法：\n```C++\ntemplate \u003ctypename T\u003e\nclass Widget\n{\n  typename Vec\u003cT\u003e::type vec;\n};\n```\n\n而using关键字可定义模板别名，则一切都会显得十分自然：\n```C++\ntemplate \u003ctypename T\u003e\nusing Vec = MyVector\u003cT, MyAlloc\u003cT\u003e\u003e;\n\n// usage\nVec\u003cint\u003e vec;\n\n// in a class template\ntemplate \u003ctypename T\u003e\nclass Widget\n{\n  Vec\u003cT\u003e vec;\n};\n```\n\n---\n\n能做到类似别名功能的，还有宏#define。但#define运行在编译前的宏处理阶段，对代码进行字符串替换。没有类型检查或其他编译、链接阶段才能进行的检查，不具备安全性。在C++11中不提倡使用#define。\n\n\n\n   \n   ","title":"C++中using关键字的使用","abstract":"1. 引入整个命名空间中的成员\n   不引入命名空间时，使用其中变量需要使用`\u003c命名空间名\u003e::\u003c变量名\u003e`的方式使用。\n   ```C++","length":192,"created_at":"2020-01-28T18:00:00.000Z","updated_at":"2025-09-29T15:15:23.000Z","tags":["C++","杂技"],"license":false,"headingTrees":[{"key":"using的用法","href":"#using的用法","heading":2,"title":"using的用法","children":[{"key":"using与命名空间","href":"#using与命名空间","heading":4,"title":"using与命名空间","children":[],"id":"using与命名空间"},{"key":"using与基类成员","href":"#using与基类成员","heading":4,"title":"using与基类成员","children":[],"id":"using与基类成员"},{"key":"using与别名","href":"#using与别名","heading":4,"title":"using与别名","children":[],"id":"using与别名"}],"id":"using的用法"},{"key":"using关键字与typedef关键字定义别名的不同","href":"#using关键字与typedef关键字定义别名的不同","heading":2,"title":"using关键字与typedef关键字定义别名的不同","children":[],"id":"using关键字与typedef关键字定义别名的不同"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2020-01-27-Building-this-blog.md","pagePath":"/articles/Building-this-blog","slug":"Building-this-blog"},"meta":{"content":"\n\u003e “Stop Trying to Reinvent the Wheel.”\n\n## 博客构建\n\n\n#### 把仓库clone到本地\n\n参考[BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]，先将[Huxpro][Huxpro]提供的[博客模板仓库][origin_repo]fork出来，`git clone`到本地。\n\n整个网站文件夹大致结构如下：\n\n```\n├── _config.yml\n|\n├── _posts/\n|   ├── 2007-10-29-awsome-file-name.md\n|   └── 2009-04-26-stupid-file-name.md\n├── img/\n|   ├── in-post/\n|   ├── awsome-bg.jpg\n|   ├── avatar-ryo.png\n|   ├── favicon.ico\n|   └── icon_wechat.jpg\n├── other_awsome_directory/\n|   └── awsomefiles\n|\n|\n├── 404.html\n├── about.html\n├── index.html\n└── other_awsome_files\n```\n\n博客的文章上传到`_posts`文件夹中，网站中用到的图片上传到`img`文件夹中，网站的全局设置在`_config.yml`中进行。\n\n\n\n#### 修改**_config.yml**文件\n\n修改根目录下的`_config.yml`文件，将其中的内容更改为自己的信息。\n\n```yml\n# Site settings\ntitle: Ryo's Blog\nSEOTitle: 阿亮仔的博客 | 亮のブログ | Ryo's Blog\nheader-img: img/home-bg.jpg\nemail: qq250707340@163.com\ndescription: \"君の夢が　叶うのは　誰かのおかげじゃないぜ。\"\nkeyword: \"Ryo, Blog, 阿亮仔, りょう, 博客, ブログ, Algorithm, Unity, Python, C-Sharp\"\nurl: \"http://RyoJerryYu.github.io\"              # your host, for absolute URL\nbaseurl: \"\"         # for example, '/blog' if your blog hosted on 'host/blog'\ngithub_repo: \"https://github.com/RyoJerryYu/RyoJerryYu.github.io.git\" # you code repository\n```\n- `SEOTitle`: `\u003ctitle\u003e`标签，即显示在浏览器标题中的文字。\n- `header-img`: 首页显示的图像，可以把路径更改为自己的图片。\n- `description`: `\u003cmeta name=\"description\"\u003e`中的内容。\n- `keyword`: `\u003cmeta name=\"keyword\"\u003e`中的内容。\n- `url`, `baseurl`: 分别为博客域名地址与其下路径。如不想将博客直接架在根路径下，需要对`baseurl`进行设置。\n- `github_repo`: 博客所在的GitHub仓库。\n\n---\n\n\n```yml\n# SNS settings\nRSS: false\n# weibo_username:     huxpro\n# zhihu_username:     huxpro\ngithub_username:    RyoJerryYu\ntwitter_username:  ryo_okami\n# facebook_username:  huxpro\n```\n分别为各个社交网站上的账号信息，以供在侧边栏中直接跳转到对应的页面。可通过在行首添加或删除`#`进行注释或取消注释。\n\n从[原仓库][origin_repo]中直接fork出来时，社交网站的图标可能会有[无法显示的问题](https://github.com/Huxpro/huxblog-boilerplate/issues/17)，其解决方法在[后面](#FixSNS)介绍。\n\n---\n\n\n```yml\n# Disqus settings\n#disqus_username: _your_disqus_short_name_\n\n# Duoshuo settings\n# duoshuo_username: huxblog\n# Share component is depend on Comment so we can NOT use share only.\n# duoshuo_share: true                     # set to false if you want to use Comment without Sharing\n\n# Gitalk\ngitalk:\n    enable: false    #是否开启Gitalk评论\n    clientID: f2c84e7629bb1446c1a4                            #生成的clientID\n    clientSecret: ca6d6139d1e1b8c43f8b2e19492ddcac8b322d0d    #生成的clientSecret\n    repo: qiubaiying.github.io    #仓库名称\n    owner: qiubaiying    #github用户名\n    admin: qiubaiying\n    distractionFreeMode: true #是否启用类似FB的阴影遮罩  \n```\n分别为各种评论系统。均未开启。\n\n---\n\n\n```yml\n# Analytics settings\n# Baidu Analytics\n# ba_track_id: 4cc1f2d8f3067386cc5cdb626a202900\n# Google Analytics\nga_track_id: 'UA-156933256-1'            # Format: UA-xxxxxx-xx\nga_domain: auto\n```\n分别为百度与谷歌的网站统计。我只启用了Google Analytics。可先到[Google Marketing Platform](https://marketingplatform.google.com/about/)注册，开启Google Analytics。在`设置`-\u003e`媒体资源设置`中获得Track ID，并填入`ga_track_id`中。\n\n---\n\n\n```yml\n# Sidebar settings\nsidebar: true                           # whether or not using Sidebar.\nsidebar-about-description: \"记录平时遇到的问题，以及对应的解决方法。偶尔上传些许宅活或是娱乐方面的记录。\"\nsidebar-avatar: /img/avatar-ryo.png      # use absolute URL, seeing it's used in both `/` and `/about/`\n```\n`sidebar`: 是否开启侧边栏，为`true`或`false`。\n`sidebar-about-description`: 显示在侧边栏中的个人简介。\n`sidebar-avatar`: 显示在侧边栏中的头像。\n\n---\n\n\n```yml\n# Featured Tags\nfeatured-tags: true                     # whether or not using Feature-Tags\nfeatured-condition-size: 2              # A tag will be featured if the size of it is more than this condition value\n```\n是否开启tag功能，以及最少要达到多少篇文章才能使tag显示在首页上。\n\n\n\n#### 修改主页等信息\n\n修改`index.html`、`404.html`、`about.html`、`tags.html`等文件，将其中的内容更改为自己的信息。\n\n- 在`index`中，修改`description`对应的内容，亦即主页中标题下方的描述。\n- 在`404`、`tags`、`about`中，修改`description`的内容，亦即404页面中的描述信息。如有需要，也可以修改`header-img`，即404页面的图片地址。\n- 在`about`中，还有修改自我介绍对应的内容。\n\n\n\n#### 修改图片信息\n\n修改`img/`下的图片，替换为自己的图片。要记得替换以下图片：\n- `avatar-ryo.png`\n- `favicon.ico`\n- `icon_wechat.png`\n\n\n\n#### 修改README.md\n\nREADME.md为Github仓库的介绍，可以在README.md中写上这个博客主要的内容，让别人了解这个博客。\n\n\n\n#### 完成\n\n将`_posts`中的博文全部删除后，将本地文件全部push到GitHub仓库中。稍等后用浏览器浏览`\u003c用户名\u003e.github.io`（或是你在`_config.yml`中设定的路径）。若发现网页已更新，即博客搭建成功，可以开始写博文了。\n\n*然而，并没有成功。*\n\n\n\n## Fix Bug\n\n\u003cp id = \"FixReadmeCh\"\u003e\u003c/p\u003e\n\n#### 修复README.zh.md引发的错误\n\n按上述步骤搭建完毕后，网页并没有正常显示。此时GitHub账号所关联的邮箱中收到标题为**Page build failure**的邮件，内容如下：\n\u003e The page build failed for the `master` branch with the following error:\n\u003e The tag `if` on line 235 in `README.zh.md` was not properly closed.\n\n如[原仓库][origin_repo]中的[issue#11](https://github.com/Huxpro/huxblog-boilerplate/issues/11)所示，在`README.zh.md`中存在`if`语句，会触发错误。\n\n因并无其他特别的需求，此处采用暴力删除`README.zh.md`的方法解决。\n\n对应commit：[删除README.zh.md，尝试修复因...](https://github.com/RyoJerryYu/RyoJerryYu.GitHub.io/commit/098d710160775df9b6d2cf04d7d4eec526a67bf4)\n\n\n\u003cp id = \"FixSNS\"\u003e\u003c/p\u003e\n\n#### 修复SNS链接不正常显示\n\n修复上述错误后，稍等即可正常打开网页。但是，我们在`_config.yml`中设置好的SNS链接并没有在侧边栏以及网页底部正常显示。如原仓库中的[issue#17](https://github.com/Huxpro/huxblog-boilerplate/issues/17)所示，原因是gitpage必须通过https访问bootcss.com等的cdn。\n\n此处采用原仓库[pull request#21](https://github.com/Huxpro/huxblog-boilerplate/pull/21)的方法，修改`_includes/head.html`, `_includes/footer.html`, `_layouts/keynote.html`, `_layouts/post.html`文件，将其中`http`修改为`https`。\n\n对应commit：[fix: change http into https](https://github.com/RyoJerryYu/RyoJerryYu.GitHub.io/commit/ec954c380472f30f09efdfadd074cb7967c2fa11)\n\n\n\n## 上传文章\n\n文章主要放在_posts文件夹中，用`git push`的方式推送到GitHub仓库，即可完成文章上传。\n\n文章正文以**markdown**语法书写，在文本头部增加如下格式的信息：\n\n```yaml\n---\nlayout:     post\ntitle:      \"Welcome to Ryo's Blog!\"\nsubtitle:   \" \\\"Hello World, Hello Blog\\\"\"\ndate:       2020-01-27 12:00:00\nauthor:     \"Ryo\"\nheader-img: \"img/post-bg-default.jpg\"\ntags:\n    - 杂技\n    - 杂谈\n---\n```\n\n其中：\n- `layout`为文章所用的模板，可选`post`或`keynote`，也可自己写一个模板html放在`_layouts`文件夹下。\n- `title`为文章标题，`subtitle`为文章副标题。\n- `date`为博客中显示的文章发表时间。\n- `author`为博客中显示的作者。\n- `header-img`为文章顶部显示的封面。\n- `tags`为文章的标签，我们的博客网站可以通过标签来快速寻找文章。\n\n把文章的文件名命名为时间+标题的形式，后缀名使用markdown文本的通用后缀名`md`，如`2020-01-27-hello-world.md`。完成后将此文本文件放到`_posts/`文件夹下。文章中使用到的图片建议放到`img/in-post/`文件夹下。\n\n完成后，使用`git push`推送到GitHub仓库，稍等后刷新博客网页即可看见刚才上传的文章。文章的url一般为：`\u003c博客地址\u003e/\u003c文章文件名中的年\u003e/\u003c月\u003e/\u003c日\u003e/\u003c文件名中剩余部分\u003e`。\n\n\n\n\n## 祝你开始愉快的博客生活。\n\n\n#### 感谢\n\n- [Huxpro][Huxpro]提供的博客模板：[huxblog-boilerplate][origin_repo]\n- [BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]\n- [Luo Yifan（罗一凡）](https://github.com/iVanlIsh)提供的Bug解决方案。\n\n\n\n\n[Huxpro]: https://github.com/huxpro\n[BruceZhao]: https://github.com/BruceZhaoR\n[origin_repo]: https://github.com/Huxpro/huxblog-boilerplate\n[READMEzh]: https://github.com/Huxpro/huxpro.github.io/blob/master/README.zh.md","title":"搭建博客的过程","abstract":"\u003e “Stop Trying to Reinvent the Wheel.”\n参考[BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md][READMEzh]，先将[Huxpro][Huxpro]提供的[博客模板仓库][origin_repo]fork出来，`git clone`到本地。\n整个网站文件夹大致结构如下：","length":252,"created_at":"2020-01-27T14:00:00.000Z","updated_at":"2024-04-16T13:30:33.000Z","tags":["杂技","Blog"],"license":false,"headingTrees":[{"key":"博客构建","href":"#博客构建","heading":2,"title":"博客构建","children":[{"key":"把仓库clone到本地","href":"#把仓库clone到本地","heading":4,"title":"把仓库clone到本地","children":[],"id":"把仓库clone到本地"},{"key":"修改_configyml文件","href":"#修改_configyml文件","heading":4,"title":"修改_config.yml文件","children":[],"id":"修改_configyml文件"},{"key":"修改主页等信息","href":"#修改主页等信息","heading":4,"title":"修改主页等信息","children":[],"id":"修改主页等信息"},{"key":"修改图片信息","href":"#修改图片信息","heading":4,"title":"修改图片信息","children":[],"id":"修改图片信息"},{"key":"修改readmemd","href":"#修改readmemd","heading":4,"title":"修改README.md","children":[],"id":"修改readmemd"},{"key":"完成","href":"#完成","heading":4,"title":"完成","children":[],"id":"完成"}],"id":"博客构建"},{"key":"fix-bug","href":"#fix-bug","heading":2,"title":"Fix Bug","children":[{"key":"修复readmezhmd引发的错误","href":"#修复readmezhmd引发的错误","heading":4,"title":"修复README.zh.md引发的错误","children":[],"id":"修复readmezhmd引发的错误"},{"key":"修复sns链接不正常显示","href":"#修复sns链接不正常显示","heading":4,"title":"修复SNS链接不正常显示","children":[],"id":"修复sns链接不正常显示"}],"id":"fix-bug"},{"key":"上传文章","href":"#上传文章","heading":2,"title":"上传文章","children":[],"id":"上传文章"},{"key":"祝你开始愉快的博客生活","href":"#祝你开始愉快的博客生活","heading":2,"title":"祝你开始愉快的博客生活。","children":[{"key":"感谢","href":"#感谢","heading":4,"title":"感谢","children":[],"id":"感谢"}],"id":"祝你开始愉快的博客生活"}],"wikiRefAliases":[],"richRefAliases":[]}},{"pathMapping":{"filePath":"public/content/articles/2020-01-27-hello-world.md","pagePath":"/articles/hello-world","slug":"hello-world"},"meta":{"content":"\n\u003e “Hello World!”\n\n## 这是我的第一篇博文\n\n自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。\n\n感谢[Huxpro][Huxpro]提供的博客模板，以及[BruceZhao][BruceZhao]编写的中文ReadMe。\n\n这个博客的使用流程：\n- 写作时利用**Markdown**语法书写，与日常编写GitHub上的文档相同。\n- 使用**Git Workflow**进行博客的更新。\n- 利用**GitHub Pages**提供的域名与免费空间，以及其支持的**Jekyll**进行网站搭建。\n\n我以后会利用这个博客，记录些许编程中遇到的问题。同时还有记录一下生活娱乐上的琐事。\n\n这第一篇博文主要用于测试一下博客是否运行成功，不打算写太多东西。今后有时间的话会记录一下搭建博客的过程。\n\n\n#### 感谢\n\n- [Huxpro][Huxpro]提供的博客模板：[huxblog-boilerplate](https://github.com/Huxpro/huxblog-boilerplate)\n- [BruceZhao][BruceZhao]提供的中文翻译：[README.zh.md](https://github.com/Huxpro/huxpro.github.io/blob/master/README.zh.md)\n\n\n\n\n[Huxpro]: https://github.com/huxpro\n[BruceZhao]: https://github.com/BruceZhaoR","title":"Welcome to Ryo's Blog!","abstract":"\u003e “Hello World!”\n自己盲人摸象折腾了一两天，终于利用GitHub Pages，把自己的博客搭好了。\n感谢[Huxpro][Huxpro]提供的博客模板，以及[BruceZhao][BruceZhao]编写的中文ReadMe。","length":29,"created_at":"2020-01-27T12:00:00.000Z","updated_at":"2022-03-27T13:30:33.000Z","tags":["杂技","杂谈"],"license":false,"headingTrees":[{"key":"这是我的第一篇博文","href":"#这是我的第一篇博文","heading":2,"title":"这是我的第一篇博文","children":[{"key":"感谢","href":"#感谢","heading":4,"title":"感谢","children":[],"id":"感谢"}],"id":"这是我的第一篇博文"}],"wikiRefAliases":[],"richRefAliases":[]}}],"allTagsList":[{"tag":"杂技","slug":"杂技","path":"/tags/杂技","postSlugs":[{"postType":"articles","postPagePath":"/articles/Building-this-blog"},{"postType":"articles","postPagePath":"/articles/hello-world"},{"postType":"articles","postPagePath":"/articles/the-using-in-cpp"}]},{"tag":"Blog","slug":"blog","path":"/tags/blog","postSlugs":[{"postType":"articles","postPagePath":"/articles/Building-this-blog"},{"postType":"articles","postPagePath":"/articles/init-a-new-hexo-project"},{"postType":"articles","postPagePath":"/articles/create-blog-cicd-by-github"},{"postType":"articles","postPagePath":"/articles/use-paste-image-and-vscode-memo"},{"postType":"ideas","postPagePath":"/ideas/blog-in-next"},{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"杂谈","slug":"杂谈","path":"/tags/杂谈","postSlugs":[{"postType":"articles","postPagePath":"/articles/hello-world"},{"postType":"articles","postPagePath":"/articles/try-cursor-and-thinking"},{"postType":"articles","postPagePath":"/articles/ygomd-synchro-cup-crystron"},{"postType":"articles","postPagePath":"/articles/ygomd-chronicle-cup-six-samurai"}]},{"tag":"C++","slug":"c++","path":"/tags/c++","postSlugs":[{"postType":"articles","postPagePath":"/articles/the-using-in-cpp"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/cpp-rvo-and-rust-move-semantics"}]},{"tag":"Python","slug":"python","path":"/tags/python","postSlugs":[{"postType":"articles","postPagePath":"/articles/python-dict"}]},{"tag":"数据结构","slug":"数据结构","path":"/tags/数据结构","postSlugs":[{"postType":"articles","postPagePath":"/articles/python-dict"},{"postType":"articles","postPagePath":"/articles/Sort-algorithm"},{"postType":"articles","postPagePath":"/articles/Handy-heap-cheat-sheet"}]},{"tag":"算法","slug":"算法","path":"/tags/算法","postSlugs":[{"postType":"articles","postPagePath":"/articles/Sort-algorithm"},{"postType":"articles","postPagePath":"/articles/Handy-heap-cheat-sheet"}]},{"tag":"排序","slug":"排序","path":"/tags/排序","postSlugs":[{"postType":"articles","postPagePath":"/articles/Sort-algorithm"}]},{"tag":"算法竞赛","slug":"算法竞赛","path":"/tags/算法竞赛","postSlugs":[{"postType":"articles","postPagePath":"/articles/Handy-heap-cheat-sheet"}]},{"tag":"设计模式","slug":"设计模式","path":"/tags/设计模式","postSlugs":[{"postType":"articles","postPagePath":"/articles/The-beauty-of-design-parten"}]},{"tag":"笔记","slug":"笔记","path":"/tags/笔记","postSlugs":[{"postType":"articles","postPagePath":"/articles/The-beauty-of-design-parten"}]},{"tag":"GitHub","slug":"github","path":"/tags/github","postSlugs":[{"postType":"articles","postPagePath":"/articles/create-blog-cicd-by-github"}]},{"tag":"AWS","slug":"aws","path":"/tags/aws","postSlugs":[{"postType":"articles","postPagePath":"/articles/create-blog-cicd-by-github"}]},{"tag":"CI/CD","slug":"ci-cd","path":"/tags/ci-cd","postSlugs":[{"postType":"articles","postPagePath":"/articles/create-blog-cicd-by-github"}]},{"tag":"IaC","slug":"iac","path":"/tags/iac","postSlugs":[{"postType":"articles","postPagePath":"/articles/create-blog-cicd-by-github"}]},{"tag":"DevOps","slug":"devops","path":"/tags/devops","postSlugs":[{"postType":"articles","postPagePath":"/articles/create-blog-cicd-by-github"},{"postType":"articles","postPagePath":"/articles/introduction-for-k8s"},{"postType":"articles","postPagePath":"/articles/introduction-for-k8s-2"},{"postType":"ideas","postPagePath":"/ideas/newest"}]},{"tag":"VSCode","slug":"vscode","path":"/tags/vscode","postSlugs":[{"postType":"articles","postPagePath":"/articles/use-paste-image-and-vscode-memo"}]},{"tag":"Hexo","slug":"hexo","path":"/tags/hexo","postSlugs":[{"postType":"articles","postPagePath":"/articles/use-paste-image-and-vscode-memo"}]},{"tag":"JavaScript","slug":"javascript","path":"/tags/javascript","postSlugs":[{"postType":"articles","postPagePath":"/articles/use-paste-image-and-vscode-memo"}]},{"tag":"Kubernetes","slug":"kubernetes","path":"/tags/kubernetes","postSlugs":[{"postType":"articles","postPagePath":"/articles/introduction-for-k8s"},{"postType":"articles","postPagePath":"/articles/introduction-for-k8s-2"},{"postType":"ideas","postPagePath":"/ideas/newest"}]},{"tag":"Docker","slug":"docker","path":"/tags/docker","postSlugs":[{"postType":"articles","postPagePath":"/articles/introduction-for-k8s"},{"postType":"articles","postPagePath":"/articles/introduction-for-k8s-2"},{"postType":"ideas","postPagePath":"/ideas/newest"}]},{"tag":"Cloud Native","slug":"cloud-native","path":"/tags/cloud-native","postSlugs":[{"postType":"articles","postPagePath":"/articles/introduction-for-k8s"},{"postType":"articles","postPagePath":"/articles/introduction-for-k8s-2"},{"postType":"ideas","postPagePath":"/ideas/newest"}]},{"tag":"Cursor","slug":"cursor","path":"/tags/cursor","postSlugs":[{"postType":"articles","postPagePath":"/articles/try-cursor-and-thinking"}]},{"tag":"游戏王","slug":"游戏王","path":"/tags/游戏王","postSlugs":[{"postType":"articles","postPagePath":"/articles/ygomd-synchro-cup-crystron"},{"postType":"articles","postPagePath":"/articles/ygomd-chronicle-cup-six-samurai"}]},{"tag":"游戏王MD","slug":"游戏王md","path":"/tags/游戏王md","postSlugs":[{"postType":"articles","postPagePath":"/articles/ygomd-synchro-cup-crystron"},{"postType":"articles","postPagePath":"/articles/ygomd-chronicle-cup-six-samurai"}]},{"tag":"游戏王大师决斗","slug":"游戏王大师决斗","path":"/tags/游戏王大师决斗","postSlugs":[{"postType":"articles","postPagePath":"/articles/ygomd-synchro-cup-crystron"},{"postType":"articles","postPagePath":"/articles/ygomd-chronicle-cup-six-samurai"}]},{"tag":"可视化","slug":"可视化","path":"/tags/可视化","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog 画图 Iframe 测试"}]},{"tag":"数学","slug":"数学","path":"/tags/数学","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog 画图 Iframe 测试"}]},{"tag":"工具","slug":"工具","path":"/tags/工具","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog 画图 Iframe 测试"}]},{"tag":"Nextjs","slug":"nextjs","path":"/tags/nextjs","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-in-next"},{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"Tag1","slug":"tag1","path":"/tags/tag1","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"Tag2","slug":"tag2","path":"/tags/tag2","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"单行Tag","slug":"单行tag","path":"/tags/单行tag","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"Tag","slug":"tag","path":"/tags/tag","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"Tag/Tag2","slug":"tag-tag2","path":"/tags/tag-tag2","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"Tag3","slug":"tag3","path":"/tags/tag3","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-syntax"}]},{"tag":"Linux","slug":"linux","path":"/tags/linux","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/blog-syntax"},{"postType":"ideas","postPagePath":"/ideas/Linux Systemd"},{"postType":"ideas","postPagePath":"/ideas/Linux 信号处理 —— Signal"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 内存分页、分段"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 堆和栈"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 虚拟内存"},{"postType":"ideas","postPagePath":"/ideas/Linux 调度 —— 进程与线程"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"systemctl","slug":"systemctl","path":"/tags/systemctl","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux Systemd"}]},{"tag":"journalctl","slug":"journalctl","path":"/tags/journalctl","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux Systemd"}]},{"tag":"timedatectl","slug":"timedatectl","path":"/tags/timedatectl","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux Systemd"}]},{"tag":"BasicKnowledge","slug":"basicknowledge","path":"/tags/basicknowledge","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux Systemd"},{"postType":"ideas","postPagePath":"/ideas/Linux 信号处理 —— Signal"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 内存分页、分段"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 堆和栈"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 虚拟内存"},{"postType":"ideas","postPagePath":"/ideas/Linux 调度 —— 进程与线程"}]},{"tag":"Operation","slug":"operation","path":"/tags/operation","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux Systemd"},{"postType":"ideas","postPagePath":"/ideas/Linux 信号处理 —— Signal"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 内存分页、分段"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 虚拟内存"}]},{"tag":"Signal","slug":"signal","path":"/tags/signal","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux 信号处理 —— Signal"}]},{"tag":"memory","slug":"memory","path":"/tags/memory","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 内存分页、分段"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 堆和栈"},{"postType":"ideas","postPagePath":"/ideas/Linux 内存 —— 虚拟内存"}]},{"tag":"schedule","slug":"schedule","path":"/tags/schedule","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/Linux 调度 —— 进程与线程"}]},{"tag":"Cloud Computing","slug":"cloud-computing","path":"/tags/cloud-computing","postSlugs":[{"postType":"ideas","postPagePath":"/ideas/newest"}]},{"tag":"PyTorch","slug":"pytorch","path":"/tags/pytorch","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/deep-learning-model-formats"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-backpropagation-mechanism"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-model-save-and-load"}]},{"tag":"ONNX","slug":"onnx","path":"/tags/onnx","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/deep-learning-model-formats"}]},{"tag":"深度学习","slug":"深度学习","path":"/tags/深度学习","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/deep-learning-model-formats"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/lora-matrix-initialization-strategy"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-backpropagation-mechanism"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-unet-structure"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-lora-training-methods"}]},{"tag":"模型部署","slug":"模型部署","path":"/tags/模型部署","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/deep-learning-model-formats"}]},{"tag":"学习笔记","slug":"学习笔记","path":"/tags/学习笔记","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/deep-learning-model-formats"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/opencv-coordinate-system-conventions"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/lora-matrix-initialization-strategy"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-backpropagation-mechanism"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/mqtt-protocol-principles-applications"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-unet-structure"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-lora-training-methods"}]},{"tag":"OpenCV","slug":"opencv","path":"/tags/opencv","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/opencv-coordinate-system-conventions"}]},{"tag":"图像处理","slug":"图像处理","path":"/tags/图像处理","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/opencv-coordinate-system-conventions"}]},{"tag":"Rust","slug":"rust","path":"/tags/rust","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/cpp-rvo-and-rust-move-semantics"}]},{"tag":"编程语言","slug":"编程语言","path":"/tags/编程语言","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/cpp-rvo-and-rust-move-semantics"}]},{"tag":"Windows","slug":"windows","path":"/tags/windows","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"macOS","slug":"macos","path":"/tags/macos","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"可执行文件","slug":"可执行文件","path":"/tags/可执行文件","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/executable-file-formats"}]},{"tag":"LoRA","slug":"lora","path":"/tags/lora","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/lora-matrix-initialization-strategy"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-unet-structure"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-lora-training-methods"}]},{"tag":"参数高效微调","slug":"参数高效微调","path":"/tags/参数高效微调","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/lora-matrix-initialization-strategy"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-unet-structure"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-lora-training-methods"}]},{"tag":"模型训练","slug":"模型训练","path":"/tags/模型训练","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/lora-matrix-initialization-strategy"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-unet-structure"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-lora-training-methods"}]},{"tag":"反向传播","slug":"反向传播","path":"/tags/反向传播","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-backpropagation-mechanism"}]},{"tag":"自动微分","slug":"自动微分","path":"/tags/自动微分","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-backpropagation-mechanism"}]},{"tag":"GoLang","slug":"golang","path":"/tags/golang","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/golang-new-and-memory-management"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/golang-scheduler-preemption"}]},{"tag":"Memory Management","slug":"memory-management","path":"/tags/memory-management","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/golang-new-and-memory-management"}]},{"tag":"Deep Learning","slug":"deep-learning","path":"/tags/deep-learning","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-model-save-and-load"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/resnet-math-and-gradient-vanishing"}]},{"tag":"Model Management","slug":"model-management","path":"/tags/model-management","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/pytorch-model-save-and-load"}]},{"tag":"Neural Networks","slug":"neural-networks","path":"/tags/neural-networks","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/resnet-math-and-gradient-vanishing"}]},{"tag":"ResNet","slug":"resnet","path":"/tags/resnet","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/resnet-math-and-gradient-vanishing"}]},{"tag":"Mathematics","slug":"mathematics","path":"/tags/mathematics","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/resnet-math-and-gradient-vanishing"}]},{"tag":"协议","slug":"协议","path":"/tags/协议","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/mqtt-protocol-principles-applications"}]},{"tag":"IoT","slug":"iot","path":"/tags/iot","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/mqtt-protocol-principles-applications"}]},{"tag":"物联网","slug":"物联网","path":"/tags/物联网","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/mqtt-protocol-principles-applications"}]},{"tag":"消息队列","slug":"消息队列","path":"/tags/消息队列","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/mqtt-protocol-principles-applications"}]},{"tag":"Stable Diffusion","slug":"stable-diffusion","path":"/tags/stable-diffusion","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-unet-structure"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/stable-diffusion-lora-training-methods"}]},{"tag":"Concurrency","slug":"concurrency","path":"/tags/concurrency","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/golang-scheduler-preemption"}]},{"tag":"Scheduler","slug":"scheduler","path":"/tags/scheduler","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/golang-scheduler-preemption"}]},{"tag":"Goroutine","slug":"goroutine","path":"/tags/goroutine","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/golang-scheduler-preemption"}]},{"tag":"线性代数","slug":"线性代数","path":"/tags/线性代数","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/products-for-vector-in-space-1"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/products-for-vector-in-space-2"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/products-for-vector-in-space-3"}]},{"tag":"群论","slug":"群论","path":"/tags/群论","postSlugs":[{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/products-for-vector-in-space-1"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/products-for-vector-in-space-2"},{"postType":"learn_from_ai","postPagePath":"/learn_from_ai/products-for-vector-in-space-3"}]},{"tag":"test","slug":"test","path":"/tags/test","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page1"},{"postType":"testwiki","postPagePath":"/testwiki/page1/subpage1"},{"postType":"testwiki","postPagePath":"/testwiki/page2"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage2"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3/subpage34"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage1"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage2"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage3"}]},{"tag":"wiki","slug":"wiki","path":"/tags/wiki","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page1"},{"postType":"testwiki","postPagePath":"/testwiki/page1/subpage1"},{"postType":"testwiki","postPagePath":"/testwiki/page2"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage2"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3/subpage34"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage1"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage2"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage3"}]},{"tag":"page1","slug":"page1","path":"/tags/page1","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page1"},{"postType":"testwiki","postPagePath":"/testwiki/page1/subpage1"}]},{"tag":"subpage1","slug":"subpage1","path":"/tags/subpage1","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page1/subpage1"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage1"}]},{"tag":"page2","slug":"page2","path":"/tags/page2","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page2"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage2"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3/subpage34"}]},{"tag":"subpage2","slug":"subpage2","path":"/tags/subpage2","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage2"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage2"}]},{"tag":"subpage3","slug":"subpage3","path":"/tags/subpage3","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3"},{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3/subpage34"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage3"}]},{"tag":"subpage34","slug":"subpage34","path":"/tags/subpage34","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page2/subpage3/subpage34"}]},{"tag":"page3","slug":"page3","path":"/tags/page3","postSlugs":[{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage1"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage2"},{"postType":"testwiki","postPagePath":"/testwiki/page3/subpage3"}]}]},"__N_SSG":true},"page":"/articles","query":{},"buildId":"_266gU8SGVnSWMafFo461","assetPrefix":"/blog-next","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>